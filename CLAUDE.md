# CLAUDE.md

> 用于在新项目中快速建立开发规范和最佳实践。

---

## 项目概述

**New API** - 新一代大模型网关与AI资产管理系统

### 项目类型

**Monorepo** (前后端分离)

### 项目架构（Monorepo）

**整体架构**:
```
Monorepo 根目录
├── 根目录（后端） - New API Backend (Go + Gin)
└── web/ - New API Frontend (React + Vite)
```

**子项目详情**:

#### New API Backend (根目录)
- **技术栈**: Gin + Go 1.25.1
- **职责**: 提供大模型网关与AI资产管理的 RESTful API 服务
- **主要目录**:
  - `controller/` - HTTP 请求处理层
  - `service/` - 业务逻辑层
  - `model/` - 数据模型层
  - `relay/` - 中继服务（AI 模型转发）
  - `middleware/` - 中间件
  - `router/` - 路由配置
  - `common/` - 通用工具
  - `constant/` - 常量定义
  - `dto/` - 数据传输对象
- **数据存储**: PostgreSQL（主数据库）, Redis（缓存）, MySQL（可选）
- **架构模式**: 分层架构（Controller → Service → Model）

#### New API Frontend (`web/`)
- **技术栈**: React 18.2 + Vite 5.2
- **职责**: 提供 Web 管理界面
- **主要目录**:
  - `src/` - 源代码
  - `public/` - 静态资源
- **UI 框架**: Semi Design, Tailwind CSS
- **架构模式**: 组件化架构

**项目间关系**:
- web/ → 后端: HTTP API 调用（前端通过 axios 调用后端 REST API）

### 核心技术栈

**整体技术栈**:
- **语言**: Go 1.25.1, JavaScript (React 18.2)
- **框架**: Gin (后端), React + Vite (前端)
- **数据存储**: PostgreSQL, Redis, MySQL
- **代码风格**: 驼峰命名 (camelCase)

---

## 测试规范
- 各子项目测试覆盖率 > 80%
- 使用 Mock 模拟外部依赖和跨项目依赖
- Mock 数据存放在各子项目的 `test/data/` 目录
- 测试文件存放在各子项目的 `test/` 目录
- 集成测试放在根目录 `integration-tests/` 目录

---

## 架构规则（强制）

### Monorepo 管理规则

1. **子项目独立性**
   - ✅ 每个子项目应该能独立构建和测试
   - ✅ 子项目间的依赖应该明确声明
   - ❌ 禁止直接引用其他子项目的内部实现
   - ❌ 禁止循环依赖

2. **共享代码管理**
   - ✅ 共享工具库放在 `common/` 目录
   - ✅ 共享类型定义统一管理
   - ❌ 禁止复制粘贴代码到多个子项目

3. **版本控制策略**
   - ✅ 前端使用 package.json 管理依赖
   - ✅ 后端使用 go.mod 管理依赖

### 层职责定义

**后端项目（根目录）**:
- **Controller 层**: ✅ 处理 HTTP 请求、参数验证、响应格式化 / ❌ 不包含业务逻辑、不直接访问数据库
- **Service 层**: ✅ 实现业务逻辑、调用 Model 层 / ❌ 不处理 HTTP 请求、不做参数验证
- **Model 层**: ✅ 数据模型定义、数据库操作 / ❌ 不包含业务逻辑

**前端项目（web/）**:
- **Components 层**: ✅ UI 组件、视图渲染 / ❌ 不包含业务逻辑
- **Services 层**: ✅ API 调用、数据获取 / ❌ 不包含 UI 逻辑
- **Utils 层**: ✅ 工具函数、通用逻辑 / ❌ 不直接操作 DOM

### 开发规则
1. **命名规范** - 统一使用驼峰命名 (camelCase)，Go 代码遵循 Go 官方规范（导出标识符使用 PascalCase）
2. **依赖管理** - 后端使用 go.mod，前端使用 package.json
3. **错误处理** -
   - 后端：使用统一的错误处理中间件，返回标准 JSON 格式错误
   - 前端：使用 try-catch 包裹 API 调用，使用 toast 提示用户
4. **版本控制** -
   - Git 提交必须使用 AskUserQuestion 工具询问用户同意
   - 提交消息必须包含：
     - 问题描述（What）
     - 根本原因（Why）
     - 修复内容（How）
     - 技术细节（Details）
     - 影响范围（Impact）
   - **严格禁止**包含以下内容：
     - `🤖 Generated with [Claude Code](https://claude.com/claude-code)`
     - `Co-Authored-By: Claude <noreply@anthropic.com>`
     - 其他任何 AI 工具的标识或署名
5. **禁止行为**
   - 禁止子项目间的紧耦合
   - 禁止绕过 API 直接访问其他子项目的数据库
   - 禁止在代码中硬编码敏感信息（使用环境变量）

### Claude Code 工具使用规范

**AI 必须使用的工具**：
- **AskUserQuestion**: 数据不足或需要决策时，必须主动询问用户
- **TodoWrite**: 跟踪多步骤任务的进度，及时更新任务状态
- **Read/Grep/Glob**: 修改前必须先分析现有代码，避免重复定义
- **Plan**: 设计实施方案时，必须使用 Plan 工具进行规划和架构设计
- **跨项目影响分析**: 修改子项目代码时，必须分析对其他子项目的影响

### Skills 技能使用规范（强制）

Skills 是可扩展的专业能力模块，**必须**根据场景强制使用对应技能。

#### 强制使用场景映射表

| 触发场景 | 关键词识别 | 必须使用的技能 |
|---------|-----------|--------------|
| 架构设计 | 架构、系统设计、技术选型、设计方案 | `example-skills:canvas-design` |
| 前端界面设计 | UI设计、界面原型、组件设计、前端设计 | `example-skills:frontend-design` |
| 生成艺术 | 算法艺术、生成艺术、p5.js | `example-skills:algorithmic-art` |
| 内部文档 | 内部沟通、状态报告、项目更新 | `example-skills:internal-comms` |
| MCP 服务器 | MCP、Model Context Protocol | `example-skills:mcp-builder` |
| 创建技能 | 新技能、skill 开发 | `example-skills:skill-creator` |
| Slack GIF | Slack动图、GIF | `example-skills:slack-gif-creator` |
| 主题样式 | 主题、样式、配色 | `example-skills:theme-factory` |
| Web Artifact | 复杂 web 应用、React artifact | `example-skills:web-artifacts-builder` |
| Web 测试 | Playwright、浏览器测试 | `example-skills:webapp-testing` |

#### 强制触发规则

**以下场景必须调用对应技能，禁止跳过**：

1. **架构设计类**（触发 `example-skills:canvas-design`）
   - 用户要求设计系统架构
   - 需要绘制架构图、流程图
   - 用户提及"架构"、"设计方案"、"技术选型"

2. **前端界面设计**（触发 `example-skills:frontend-design`）
   - 用户要求创建 Web 界面
   - 需要设计前端组件
   - 用户提及"UI设计"、"界面"、"前端设计"

3. **文档处理**（触发 `example-skills:internal-comms`）
   - 需要创建内部报告或文档
   - 用户提及"状态报告"、"项目更新"

#### 技能调用检查清单

在完成任务前，必须检查：
- [ ] 是否识别到上述强制触发场景？
- [ ] 是否已调用对应的必需技能？
- [ ] 如未调用，是否有合理理由？（需向用户说明）

#### 禁止行为

- ❌ **禁止**在强制场景下不调用对应技能
- ❌ **禁止**用文字描述替代可视化输出（有可视化技能时）
- ❌ **禁止**跳过专业技能直接输出低质量结果

#### 技能调用语法

```
使用 Skill 工具，参数 skill 设置为技能名称：
- example-skills:algorithmic-art
- example-skills:canvas-design
- example-skills:frontend-design
- example-skills:internal-comms
- example-skills:mcp-builder
- example-skills:skill-creator
- example-skills:slack-gif-creator
- example-skills:theme-factory
- example-skills:web-artifacts-builder
- example-skills:webapp-testing
```

#### 动态技能发现流程

1. **识别任务类型**：分析用户需求，判断是否需要专业技能支持
2. **查看可用技能**：通过系统提供的 `<available_skills>` 列表确认当前可用的技能
3. **匹配场景映射**：根据上表的场景映射，确定必须调用的技能
4. **调用技能**：使用 `Skill` 工具调用对应技能

**Token 管理规范（强制）**：

在开始每个 todo 任务前，必须评估剩余 token 是否足够完成该任务：

1. **评估标准**：
   - 当前剩余 token < 30000：存在风险
   - 当前剩余 token < 20000：高风险
   - 当前剩余 token < 10000：极高风险

2. **风险处理流程**：

   **如果存在风险**，必须使用 AskUserQuestion 工具询问用户：

   ```yaml
   question: "⚠️ Token 预警：当前剩余 [X] tokens，即将开始「[Todo任务名称]」可能存在 token 不足风险。您希望如何处理？"
   header: "Token 管理"
   multiSelect: false
   options:
     - label: "继续执行当前任务"
       description: "继续完成当前任务，可能需要在新会话中继续未完成的工作"
     - label: "生成进度总结文档"
       description: "生成包含当前进度总结和剩余待办事项实施方案的文档，便于在新会话中继续"
   ```

3. **生成进度总结文档**（用户选择选项 2 时）：

   创建文档：`docs/progress/YYYY-MM-DD-HH-MM-[任务名称]-进度总结.md`

   文档必须包含：
   ```markdown
   # [任务名称] - 进度总结与实施方案

   **创建时间**: YYYY-MM-DD HH:MM
   **当前状态**: 进行中
   **完成度**: X/Y 个任务
   **项目类型**: Monorepo

   ---

   ## 一、已完成任务

   ### 1.1 任务清单
   - [x] 任务 1 - 完成情况描述
   - [x] 任务 2 - 完成情况描述
   - [x] 任务 3 - 完成情况描述

   ### 1.2 关键成果
   - **成果 1**: 具体内容和路径
   - **成果 2**: 具体内容和路径
   - **成果 3**: 具体内容和路径

   ### 1.3 已修改文件（Monorepo）
   ```
   [子项目1]/path/to/file1.ext - 修改内容描述
   [子项目2]/path/to/file2.ext - 修改内容描述
   共享库/path/to/shared.ext - 修改内容描述
   ```

   ### 1.4 跨项目影响
   - **[子项目1]**: 影响描述
   - **[子项目2]**: 影响描述
   - **共享代码**: 影响范围

   ---

   ## 二、剩余待办任务

   ### 2.1 待办清单
   - [ ] 任务 4 - 详细描述（涉及子项目：[列表]）
   - [ ] 任务 5 - 详细描述（涉及子项目：[列表]）
   - [ ] 任务 6 - 详细描述（涉及子项目：[列表]）

   ### 2.2 实施方案

   #### 任务 4: [任务名称]
   **目标**: [具体目标]
   **涉及子项目**: [子项目列表]

   **步骤**:
   1. [详细步骤 1]
   2. [详细步骤 2]
   3. [详细步骤 3]

   **需要修改的文件**:
   - `[子项目1]/path/to/file1.ext` - [修改说明]
   - `[子项目2]/path/to/file2.ext` - [修改说明]
   - `共享库/path/to/shared.ext` - [修改说明]

   **跨项目影响**:
   - [子项目1]: [影响说明]
   - [子项目2]: [影响说明]

   **注意事项**:
   - [注意点 1]
   - [注意点 2]

   #### 任务 5: [任务名称]
   ... (同上格式)

   ---

   ## 三、技术背景和上下文

   ### 3.1 Monorepo 架构
   ```
   [展示 monorepo 结构和子项目关系]
   ```

   ### 3.2 子项目信息
   - **[子项目1]**: [技术栈] - [职责]
   - **[子项目2]**: [技术栈] - [职责]

   ### 3.3 重要约束
   - [约束 1]
   - [约束 2]
   - [Monorepo 特定约束]

   ### 3.4 已知问题
   - [问题 1 及解决方案]
   - [问题 2 及解决方案]

   ---

   ## 四、继续工作指南

   ### 4.1 快速启动
   在新会话中执行以下步骤：
   1. 阅读本文档了解当前进度
   2. 使用 TodoWrite 工具恢复任务列表
   3. 从「任务 4」开始继续执行
   4. 注意跨项目影响分析

   ### 4.2 验证检查清单
   开始前请确认：
   - [ ] 已理解所有已完成任务的内容
   - [ ] 已查看所有修改过的文件（包括所有子项目）
   - [ ] 已理解剩余任务的实施方案
   - [ ] 已了解 Monorepo 架构和子项目关系
   - [ ] 已了解跨项目影响范围

   ---

   **🤖 Generated with Claude Code**
   ```

4. **文档生成后**：
   - 输出文档路径
   - 提示用户在新会话中使用 `@文档路径` 继续工作
   - 优雅结束当前会话

**最佳实践**：
- 定期评估 token 使用情况
- 在大型任务开始前进行评估
- Monorepo 项目由于涉及多个子项目，通常需要更多 tokens
- 预留至少 20000 tokens 的安全边际
- 及时保存进度，避免工作丢失

---

## AI 工作流程与质量门（强制）

### 工作流程总览

```
需求输入
   ↓
A. 立项/澄清（Gate 0）
   ↓  KISS + YAGNI + AskUserQuestion
   ↓
B. 方案设计（Gate 1）
   ↓  SoC/LoD/组合优于继承 + DIP/ISP
   ↓
C. 编码前置（Gate 2）
   ↓  DRY + 分层职责 + 前置条件信任
   ↓
D. 编码实现
   ↓  SOLID + 幂等/限流/熔断 + 可观测性
   ↓
E. 测试与验收（Gate 3）
   ↓  单测+契约 + Mock + 覆盖率
   ↓
开发完成 ✅
（发布与运维不在此范围）
```

---

### A. 立项/澄清阶段（Gate 0）

**目标**: 明确需求边界，拒绝过度设计

**使用原则**:
- **KISS + YAGNI** → 先砍需求，确认功能必要性
- **AskUserQuestion** → 明确边界与约束

**输出**:
- 需求边界清晰
- 最小方案草图
- 走审批流程

**质量门 Gate 0：问题澄清**
- [ ] 已使用 AskUserQuestion 收敛需求与约束
- [ ] KISS 四问已回答（特别是"真的需要这个功能吗？"）
- [ ] 需求边界明确，无歧义

---

### B. 方案设计阶段（Gate 1）

**目标**: 设计可扩展、可维护的方案

**使用原则**:
- **SoC/LoD/组合优于继承** → 明确分层边界，减少耦合
- **DIP/ISP** → 稳住扩展点，依赖抽象

**输出**:
- 方案文档（`docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`）
- 必须包含：
  - 完整调用链路分析（包括跨项目调用）
  - KISS 四问的回答
  - 性能影响评估
  - 跨项目影响分析
  - 风险分析和缓解措施

**质量门 Gate 1：方案评审**
- [ ] 方案文档已提交
- [ ] 调用链路分析完整
- [ ] KISS 四问已回答
- [ ] 性能影响已评估
- [ ] 跨项目影响已分析
- [ ] 风险与缓解措施明确
- [ ] 已获得用户审批

---

### C. 编码前置阶段（Gate 2）

**目标**: 确保代码质量，避免重复实现

**使用原则**:
- **DRY** → 全局检索避免重复（使用 grep，覆盖所有子项目）
- **SRP/SoC** → 划清分层职责
- **前置条件信任原则** → 避免重复验证

**输出**:
- 代码重复检查报告（覆盖所有子项目）
- 分层职责明确
- 前置条件明确

**质量门 Gate 2：实现前检查**
- [ ] 已使用 grep 全局检索所有子项目，无重复定义
- [ ] 分层边界清晰，职责明确
- [ ] 前置条件信任原则已应用
- [ ] 接口契约明确

---

### D. 编码实现阶段

**目标**: 高质量代码实现

**使用原则**:
- **SOLID** → 作为底座（SRP/OCP/LSP/ISP/DIP）
- **幂等/限流/熔断** → 进到关键路径
- **日志/指标/Trace** → 埋点就位

**输出**:
- 高质量代码
- 可观测性埋点
- 健壮性保障（幂等/限流/熔断）

**关键检查**:
- [ ] SOLID 原则已遵循
- [ ] 关键路径已添加幂等/限流/熔断
- [ ] 日志/指标/Trace 埋点完整

---

### E. 测试与验收阶段（Gate 3）

**目标**: 确保代码质量和功能正确性

**使用原则**:
- **测试金字塔** → 单测+契约优先
- **Mock** → 隔离外部依赖

**输出**:
- 测试报告（`docs/test/YYYY-MM-DD-HH-MM-功能名称-测试报告.md`）
- 测试覆盖率报告（各子项目）

**质量门 Gate 3：测试门**
- [ ] 单元测试覆盖率 ≥ 80%（或项目自定义值）
- [ ] 集成测试已通过（包括跨项目集成测试）
- [ ] 必要的契约测试已完成
- [ ] Mock 数据已准备（test/data/）
- [ ] 测试报告已生成

---

## 核心开发实践（强制）

### 1. 代码修改前的分析（强制）

**所有代码修改前，必须先完成深度分析，理解 Monorepo 架构后再设计方案。**

#### 调用链路分析要点（Monorepo）
```
用户请求 → web/前端界面 → HTTP API → 后端/controller → service → model → 数据存储
```

必须分析：
- **入口点**: 请求从哪个子项目的哪个端点进入
- **跨项目调用**: 数据如何在子项目间流转
- **依赖关系**: 各子项目之间的依赖
- **错误传播**: 错误如何跨项目传播
- **数据一致性**: 跨项目的事务和一致性保证

#### 方案设计原则: KISS

设计前必须回答4个问题:
1. **"这是真问题还是臆想的?"** - 拒绝过度设计
2. **"有更简单的方法吗?"** - 永远寻找最简方案
3. **"会破坏什么吗?"** - 向后兼容是铁律，考虑对所有子项目的影响
4. **"真的需要这个功能吗?"** - 确认功能必要性

**性能要求**:
- 最小化跨项目通信次数
- 优先使用批量操作
- 合理使用缓存减少跨项目调用
- 避免不必要的数据复制

**代码简洁性**:
- 能用30行解决，绝不写300行
- 复用现有代码和共享库
- 函数职责单一

#### 数据驱动的方案设计（强制）

**所有方案必须有充足的数据支撑**：

数据充足性判断：
- ✅ 是否完整理解现有代码实现逻辑？
- ✅ 是否掌握各子项目之间的调用关系？
- ✅ 是否了解跨项目的性能瓶颈？
- ✅ 是否分析业界 Monorepo 最佳实践？
- ✅ 是否评估不同方案优劣？

**数据不足时的处理**:
```
⚠️ 我没有足够的信心设计最佳方案

需要以下数据:
1. [具体需要的数据1]
2. [具体需要的数据2]
...

请提供这些数据或告诉我如何获取。
```

**禁止**:
- ❌ 基于猜测或假设进行方案设计
- ❌ 数据不足时强行给出方案
- ❌ 使用"可能"、"也许"等不确定词汇描述关键决策
- ❌ 忽视跨项目影响

#### 方案审批流程（强制）

**在实施任何代码修改前，必须先获得用户审批**:

**工作流程**:
1. **分析阶段**: AI 使用只读工具(Read/Grep/Glob)深度分析所有相关子项目的代码
2. **方案设计**: 制定详细的实施方案，包括跨项目影响分析
3. **展示方案**: 向用户清晰展示方案，等待批准
4. **执行修改**: 获得批准后才开始实际修改代码

**方案文档要求**:
1. **提交方案设计文档**，包含:
   - 完整调用链路分析（包括跨项目调用）
   - 问题诊断和根因分析
   - **支撑数据和分析**（必须包含）
   - 方案设计（架构图、时序图、代码片段）
   - KISS原则4问题的回答
   - 性能影响评估（特别是跨项目通信）
   - **跨项目影响分析**（列出所有受影响的子项目）
   - 风险分析和缓解措施
   - **文档保存**: 保存到 `docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`

2. **等待用户确认** - 批准后方可开始实施

3. **实施** - 严格按照批准方案执行

#### 分析检查清单

开始编码前必须完成:
- [ ] 已完整追踪调用链路（包括跨项目调用）
- [ ] 已理解所有涉及子项目的职责
- [ ] 已识别所有跨项目数据传递点
- [ ] 已回答KISS原则4个问题
- [ ] 已收集充足数据支撑方案
- [ ] 已分析对所有子项目的影响
- [ ] 已制定详细实施方案
- [ ] 已获得用户审批确认

### 2. SOLID原则（强制执行）

**所有架构设计和代码实现必须遵循SOLID原则**：

**Monorepo 特别注意**：
- 在 Monorepo 中，SOLID 原则不仅适用于单个子项目内部，也适用于子项目之间的关系
- 子项目间的接口设计同样需要遵循 SOLID 原则

#### 1. 单一职责原则（SRP - Single Responsibility Principle）
- **定义**：一个类/模块只负责一个功能领域的变化
- **实践要点**：
  - 每个包/模块职责单一且清晰
  - 工厂负责创建，适配器负责转换，具体实现负责执行
  - 避免"上帝类"或"万能函数"
  - 一个模块的修改原因只能有一个
- **Monorepo 应用**：
  - 每个子项目应该有明确且单一的职责
  - 避免子项目职责过于复杂或模糊

#### 2. 开闭原则（OCP - Open-Closed Principle）
- **定义**：对扩展开放，对修改封闭
- **实践要点**：
  - 添加新功能通过扩展实现，不修改现有代码
  - 使用接口和抽象类定义扩展点
  - 新增实现只需创建新文件，无需修改旧代码
  - 避免使用大量 switch/if-else 判断类型
- **Monorepo 应用**：
  - 添加新子项目不应该需要修改现有子项目
  - 子项目间的 API 应该稳定，通过版本控制实现兼容

#### 3. 里氏替换原则（LSP - Liskov Substitution Principle）
- **定义**：子类必须能够替换父类而不影响程序正确性
- **实践要点**：
  - 所有实现同一接口的类必须可互换
  - 接口契约必须保持一致
  - 不违反接口定义的前置条件和后置条件
  - 调用方不应关心具体实现类型
- **Monorepo 应用**：
  - 如果多个子项目实现相同的接口，它们应该可以互相替换
  - 共享接口的契约必须严格遵守

#### 4. 接口隔离原则（ISP - Interface Segregation Principle）
- **定义**：客户端不应该依赖它不需要的接口
- **实践要点**：
  - 接口应该小而专注，只包含必要方法
  - 避免臃肿的接口定义
  - 根据客户端需求定义最小接口
  - 大接口应拆分为多个小接口
- **Monorepo 应用**：
  - 子项目之间的 API 应该精简，只暴露必要的接口
  - 避免一个子项目暴露过多不相关的功能

#### 5. 依赖倒置原则（DIP - Dependency Inversion Principle）
- **定义**：高层模块不应该依赖低层模块，两者都应该依赖抽象
- **实践要点**：
  - 依赖接口而不是具体实现
  - 通过依赖注入传递依赖
  - 抽象层不依赖具体层
  - 具体实现可以随时替换
- **Monorepo 应用**：
  - 子项目之间应该通过定义良好的接口通信
  - 避免直接依赖其他子项目的具体实现
  - 使用共享接口定义实现解耦

#### SOLID原则检查清单

**设计新功能前必须回答**：
- [ ] **SRP**：每个模块的职责是否单一明确？（包括子项目级别）
- [ ] **OCP**：添加新功能是否需要修改现有代码？（包括其他子项目）
- [ ] **LSP**：所有实现是否可以互换使用？（包括跨子项目）
- [ ] **ISP**：接口是否臃肿，是否包含不必要的方法？（包括跨项目 API）
- [ ] **DIP**：是否依赖抽象而不是具体实现？（包括子项目间依赖）

**违反SOLID原则的后果**：
- 代码耦合度高，难以维护
- 功能扩展需要大量修改现有代码
- 子项目间紧耦合，难以独立开发和部署
- 测试困难，无法进行单元测试
- 技术债务快速累积

#### 2.2 DRY（Don't Repeat Yourself）
- **原则**: 避免重复实现，优先复用现有代码和共享库
- **实践**: 添加任何新定义前，必须先用 `grep -r "functionName\|className"` 检查所有子项目
- **目标**: 每个知识点在系统中只有唯一、明确的表达

#### 2.3 SoC（Separation of Concerns）
- **原则**: 关注点分离，不同关注点分离到不同模块
- **实践**: 与层职责定义和调用链分析一致，明确各层边界
- **目标**: 业务逻辑、数据访问、UI展示、基础设施各司其职
- **Monorepo 应用**: 每个子项目应有明确的关注点

#### 2.4 LoD（Law of Demeter / 最少知道原则）
- **原则**: 一个对象应当对其他对象有尽可能少的了解
- **实践**: 减少跨层/跨域/跨项目耦合，只与直接朋友通信
- **规则**: 只调用以下方法：
  - 对象自身的方法
  - 方法参数的方法
  - 方法内创建对象的方法
  - 对象直接持有的组件的方法

#### 2.5 组合优于继承
- **原则**: 优先使用对象组合而不是类继承来实现代码复用
- **实践**: 配合 OCP/LSP，把变更点外提为组合件
- **优点**: 更灵活、更易测试、避免继承层次过深

#### 2.6 YAGNI（You Aren't Gonna Need It）
- **原则**: 只实现当前需要的功能，不为未来可能的需求预先设计
- **实践**: 与 KISS 搭配，拒绝"也许将来会用到"的功能
- **目标**: 减少不必要的复杂性和维护成本

---

### 3. 架构与健壮性原则

#### 3.1 Clean/Hexagonal/Ports & Adapters 架构
- **原则**: 接口抽象 + 适配器模式，把外部依赖隔离进边界层
- **实践**:
  - 核心业务逻辑不依赖外部框架、数据库、UI
  - 通过端口（接口）定义核心与外部的交互契约
  - 通过适配器实现具体的外部集成（数据库、API、消息队列）
- **目标**: 与 DIP/ISP 强一致，实现核心业务的可测试性和可替换性

#### 3.2 12-Factor App（服务化应用实践）
- **配置外置**: 配置通过环境变量注入，不硬编码在代码中
- **无状态进程**: 进程无状态，会话状态存储在外部（Redis等）
- **日志标准输出**: 日志输出到 stdout/stderr，由日志收集系统统一处理
- **一次性进程**: 进程可以快速启动和优雅关闭
- **依赖隔离**: 显式声明依赖，不依赖系统全局包
- **端口绑定**: 服务通过端口暴露，自包含运行

#### 3.3 幂等性 & 去重
- **原则**: 写接口、任务重试、事件消费的第一性原则
- **实践**:
  - API设计: POST/PUT 使用幂等键（idempotency-key）
  - 消息消费: 使用消息ID去重，确保至少一次处理
  - 数据库操作: 使用唯一索引防止重复插入
- **目标**: 保证系统在重试、网络抖动情况下的数据一致性

#### 3.4 限流/熔断/重试/退避（服务健壮性四件套）
- **限流**:
  - 保护系统不被突发流量压垮
  - 实现: 令牌桶、漏桶、滑动窗口
  - 默认: 100 RPS/实例（可根据项目调整）

- **熔断**:
  - 快速失败，防止级联故障
  - 触发条件: 20%错误率或连续N次失败（可根据项目调整）
  - 状态: 关闭 → 打开 → 半开 → 关闭

- **重试**:
  - 应对临时性故障
  - 策略: 指数退避（1s, 2s, 4s），最多3次
  - 注意: 必须配合幂等性设计

- **退避**:
  - 避免雪崩效应
  - 策略: 固定退避、指数退避、带抖动的指数退避

---

### 4. 功能版本迭代限制

**禁止版本迭代**: 对于存量功能，严格禁止版本迭代(v1、v2、v3)

**核心原则**:
- **就地更新**: 所有改进必须直接修改现有代码
- **用户主导**: 只有用户明确要求才能创建新版本
- **单一实现**: 每个功能只能有一个实现版本
- **向后兼容**: 必须保持向后兼容，考虑所有依赖该功能的子项目
- **清理废弃**: 必须版本迭代时同时清理旧代码

### 5. 任务解析与影响分析

**任务前置分析原则**: 执行任何任务前，必须先进行全面分析

#### 文件影响评估（Monorepo）
- **主要修改文件**: 直接需要编辑的核心文件
- **关联影响文件**: 同一子项目中可能受影响的文件
- **跨项目影响文件**: 其他子项目中可能受影响的文件
- **共享代码影响**: 共享库和工具的影响范围
- **测试相关文件**: 需要更新或新增的测试文件（包括集成测试）
- **配置文件**: 可能需要调整的配置

#### 依赖关系分析（Monorepo）
- **子项目内依赖**: 识别导入/引用关系
- **跨项目依赖**: 识别子项目间的调用关系
- **共享代码依赖**: 识别对共享库的依赖

#### 重复定义检查

添加任何新定义前，必须先检查所有子项目：
```bash
# 检查所有子项目中的函数/类/接口定义
grep -r "functionName\|className" --include="*.go" .
grep -r "functionName\|className" --include="*.jsx" web/
```

**原则**: 避免重复实现，优先复用现有代码和共享库

### 6. 前置条件信任原则

**避免重复验证**: 信任调用链的前置条件

**分层职责**:
- **入口层**: 负责验证和防护（通常在面向用户的子项目）
- **业务层**: 信任前置条件，专注业务
- **数据层**: 处理持久化，不做业务验证
- **跨项目调用**: 调用其他子项目的 API 时，信任其已完成验证

---

## 交互规范（强制）

### 沟通原则
- **中文响应**: 所有响应使用中文
- **详细说明**: 提供清晰的操作步骤和说明
- **操作确认**: 重要操作前进行确认
- **透明度**: 如实汇报进度、问题和风险
- **跨项目影响说明**: 修改代码时明确说明对其他子项目的影响

### 主动提问机制（强制）
- **数据不足时提问**: 缺乏必要信息时，必须使用 `AskUserQuestion` 工具询问用户
- **明确性优先**: 遇到模糊需求时，通过提问明确用户意图
- **必须提问的场景**:
  - 技术方案有多种实现路径需权衡时
  - 需要删除或修改重要功能/数据时
  - 修改可能影响多个子项目时
  - 配置参数会显著影响系统行为时
  - 不确定用户具体需求时
  - 设计决策可能影响架构或性能时
  - 存在跨项目向后兼容性风险时
- **提问质量要求**:
  - 问题应具体、聚焦
  - 提供2-4个清晰选项
  - 每个选项附带详细说明
  - 说明各选项的影响和优缺点（包括对各子项目的影响）
- **等待确认**: 提问后必须等待用户回答

### 文件创建限制（强制）
- **禁止主动创建文档**: 不主动创建文档文件(*.md)或README，除非用户明确要求
- **优先编辑**: 优先编辑现有文件而非创建新文件
- **必要性原则**: 只创建绝对必要的文件
- **用户确认**: 创建新文件前必须征得用户同意

---

## Monorepo 特定规范

### 跨项目通信规范

1. **API 调用规范**
   - 使用明确定义的 API 接口
   - API 变更必须遵循版本管理策略
   - 禁止直接访问其他子项目的内部实现

2. **共享代码规范**
   - 共享代码放在 `common/` 目录
   - 共享代码必须有完善的文档和测试
   - 修改共享代码必须评估对所有依赖方的影响

3. **数据共享规范**
   - 优先使用 API 传递数据
   - 必要时可共享数据库，但需明确所有权
   - 禁止直接读写其他子项目的数据表

### 构建和部署规范

1. **独立构建**: 每个子项目应该能独立构建
   - 后端: `go build`
   - 前端: `npm run build` 或 `bun run build`
2. **依赖顺序**: 前端依赖后端 API，构建时后端优先
3. **并行构建**: 可以并行构建前后端
4. **增量构建**: 只构建有变更的子项目

---

**最后更新**: 2025-11-29

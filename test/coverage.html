
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/QuantumNous/new-api/controller/billing.go (0.0%)</option>
				
				<option value="file1">github.com/QuantumNous/new-api/controller/channel-billing.go (0.0%)</option>
				
				<option value="file2">github.com/QuantumNous/new-api/controller/channel-test.go (0.0%)</option>
				
				<option value="file3">github.com/QuantumNous/new-api/controller/channel.go (0.0%)</option>
				
				<option value="file4">github.com/QuantumNous/new-api/controller/console_migrate.go (0.0%)</option>
				
				<option value="file5">github.com/QuantumNous/new-api/controller/discord.go (0.0%)</option>
				
				<option value="file6">github.com/QuantumNous/new-api/controller/github.go (0.0%)</option>
				
				<option value="file7">github.com/QuantumNous/new-api/controller/group.go (0.0%)</option>
				
				<option value="file8">github.com/QuantumNous/new-api/controller/image.go (0.0%)</option>
				
				<option value="file9">github.com/QuantumNous/new-api/controller/linuxdo.go (0.0%)</option>
				
				<option value="file10">github.com/QuantumNous/new-api/controller/log.go (0.0%)</option>
				
				<option value="file11">github.com/QuantumNous/new-api/controller/midjourney.go (0.0%)</option>
				
				<option value="file12">github.com/QuantumNous/new-api/controller/misc.go (0.0%)</option>
				
				<option value="file13">github.com/QuantumNous/new-api/controller/missing_models.go (0.0%)</option>
				
				<option value="file14">github.com/QuantumNous/new-api/controller/model.go (31.4%)</option>
				
				<option value="file15">github.com/QuantumNous/new-api/controller/model_meta.go (0.0%)</option>
				
				<option value="file16">github.com/QuantumNous/new-api/controller/model_sync.go (1.7%)</option>
				
				<option value="file17">github.com/QuantumNous/new-api/controller/oidc.go (0.0%)</option>
				
				<option value="file18">github.com/QuantumNous/new-api/controller/option.go (0.0%)</option>
				
				<option value="file19">github.com/QuantumNous/new-api/controller/passkey.go (0.0%)</option>
				
				<option value="file20">github.com/QuantumNous/new-api/controller/playground.go (0.0%)</option>
				
				<option value="file21">github.com/QuantumNous/new-api/controller/prefill_group.go (0.0%)</option>
				
				<option value="file22">github.com/QuantumNous/new-api/controller/pricing.go (0.0%)</option>
				
				<option value="file23">github.com/QuantumNous/new-api/controller/ratio_config.go (0.0%)</option>
				
				<option value="file24">github.com/QuantumNous/new-api/controller/ratio_sync.go (0.0%)</option>
				
				<option value="file25">github.com/QuantumNous/new-api/controller/redemption.go (0.0%)</option>
				
				<option value="file26">github.com/QuantumNous/new-api/controller/relay.go (0.0%)</option>
				
				<option value="file27">github.com/QuantumNous/new-api/controller/secure_verification.go (0.0%)</option>
				
				<option value="file28">github.com/QuantumNous/new-api/controller/setup.go (0.0%)</option>
				
				<option value="file29">github.com/QuantumNous/new-api/controller/swag_video.go (0.0%)</option>
				
				<option value="file30">github.com/QuantumNous/new-api/controller/task.go (0.0%)</option>
				
				<option value="file31">github.com/QuantumNous/new-api/controller/task_video.go (0.0%)</option>
				
				<option value="file32">github.com/QuantumNous/new-api/controller/telegram.go (0.0%)</option>
				
				<option value="file33">github.com/QuantumNous/new-api/controller/token.go (9.6%)</option>
				
				<option value="file34">github.com/QuantumNous/new-api/controller/topup.go (0.0%)</option>
				
				<option value="file35">github.com/QuantumNous/new-api/controller/topup_creem.go (0.0%)</option>
				
				<option value="file36">github.com/QuantumNous/new-api/controller/topup_stripe.go (0.0%)</option>
				
				<option value="file37">github.com/QuantumNous/new-api/controller/twofa.go (0.0%)</option>
				
				<option value="file38">github.com/QuantumNous/new-api/controller/uptime_kuma.go (0.0%)</option>
				
				<option value="file39">github.com/QuantumNous/new-api/controller/usedata.go (0.0%)</option>
				
				<option value="file40">github.com/QuantumNous/new-api/controller/user.go (0.0%)</option>
				
				<option value="file41">github.com/QuantumNous/new-api/controller/vendor_meta.go (0.0%)</option>
				
				<option value="file42">github.com/QuantumNous/new-api/controller/video_proxy.go (0.0%)</option>
				
				<option value="file43">github.com/QuantumNous/new-api/controller/video_proxy_gemini.go (0.0%)</option>
				
				<option value="file44">github.com/QuantumNous/new-api/controller/wechat.go (0.0%)</option>
				
				<option value="file45">github.com/QuantumNous/new-api/model/ability.go (0.0%)</option>
				
				<option value="file46">github.com/QuantumNous/new-api/model/channel.go (0.0%)</option>
				
				<option value="file47">github.com/QuantumNous/new-api/model/channel_cache.go (0.0%)</option>
				
				<option value="file48">github.com/QuantumNous/new-api/model/log.go (0.0%)</option>
				
				<option value="file49">github.com/QuantumNous/new-api/model/main.go (0.0%)</option>
				
				<option value="file50">github.com/QuantumNous/new-api/model/midjourney.go (0.0%)</option>
				
				<option value="file51">github.com/QuantumNous/new-api/model/missing_models.go (0.0%)</option>
				
				<option value="file52">github.com/QuantumNous/new-api/model/model_extra.go (0.0%)</option>
				
				<option value="file53">github.com/QuantumNous/new-api/model/model_meta.go (0.0%)</option>
				
				<option value="file54">github.com/QuantumNous/new-api/model/option.go (0.0%)</option>
				
				<option value="file55">github.com/QuantumNous/new-api/model/passkey.go (0.0%)</option>
				
				<option value="file56">github.com/QuantumNous/new-api/model/prefill_group.go (0.0%)</option>
				
				<option value="file57">github.com/QuantumNous/new-api/model/pricing.go (0.0%)</option>
				
				<option value="file58">github.com/QuantumNous/new-api/model/pricing_default.go (0.0%)</option>
				
				<option value="file59">github.com/QuantumNous/new-api/model/pricing_refresh.go (0.0%)</option>
				
				<option value="file60">github.com/QuantumNous/new-api/model/redemption.go (0.0%)</option>
				
				<option value="file61">github.com/QuantumNous/new-api/model/setup.go (0.0%)</option>
				
				<option value="file62">github.com/QuantumNous/new-api/model/task.go (0.0%)</option>
				
				<option value="file63">github.com/QuantumNous/new-api/model/token.go (14.6%)</option>
				
				<option value="file64">github.com/QuantumNous/new-api/model/token_cache.go (0.0%)</option>
				
				<option value="file65">github.com/QuantumNous/new-api/model/topup.go (0.0%)</option>
				
				<option value="file66">github.com/QuantumNous/new-api/model/twofa.go (0.0%)</option>
				
				<option value="file67">github.com/QuantumNous/new-api/model/usedata.go (0.0%)</option>
				
				<option value="file68">github.com/QuantumNous/new-api/model/user.go (0.0%)</option>
				
				<option value="file69">github.com/QuantumNous/new-api/model/user_cache.go (0.0%)</option>
				
				<option value="file70">github.com/QuantumNous/new-api/model/utils.go (6.5%)</option>
				
				<option value="file71">github.com/QuantumNous/new-api/model/vendor_meta.go (0.0%)</option>
				
				<option value="file72">github.com/QuantumNous/new-api/service/audio.go (0.0%)</option>
				
				<option value="file73">github.com/QuantumNous/new-api/service/channel.go (0.0%)</option>
				
				<option value="file74">github.com/QuantumNous/new-api/service/channel_select.go (0.0%)</option>
				
				<option value="file75">github.com/QuantumNous/new-api/service/convert.go (0.0%)</option>
				
				<option value="file76">github.com/QuantumNous/new-api/service/download.go (0.0%)</option>
				
				<option value="file77">github.com/QuantumNous/new-api/service/epay.go (0.0%)</option>
				
				<option value="file78">github.com/QuantumNous/new-api/service/error.go (0.0%)</option>
				
				<option value="file79">github.com/QuantumNous/new-api/service/file_decoder.go (0.0%)</option>
				
				<option value="file80">github.com/QuantumNous/new-api/service/group.go (0.0%)</option>
				
				<option value="file81">github.com/QuantumNous/new-api/service/http.go (0.0%)</option>
				
				<option value="file82">github.com/QuantumNous/new-api/service/http_client.go (0.0%)</option>
				
				<option value="file83">github.com/QuantumNous/new-api/service/image.go (0.0%)</option>
				
				<option value="file84">github.com/QuantumNous/new-api/service/log_info_generate.go (0.0%)</option>
				
				<option value="file85">github.com/QuantumNous/new-api/service/midjourney.go (0.0%)</option>
				
				<option value="file86">github.com/QuantumNous/new-api/service/notify-limit.go (0.0%)</option>
				
				<option value="file87">github.com/QuantumNous/new-api/service/pre_consume_quota.go (0.0%)</option>
				
				<option value="file88">github.com/QuantumNous/new-api/service/quota.go (0.0%)</option>
				
				<option value="file89">github.com/QuantumNous/new-api/service/sensitive.go (0.0%)</option>
				
				<option value="file90">github.com/QuantumNous/new-api/service/str.go (0.0%)</option>
				
				<option value="file91">github.com/QuantumNous/new-api/service/task.go (0.0%)</option>
				
				<option value="file92">github.com/QuantumNous/new-api/service/token_counter.go (0.0%)</option>
				
				<option value="file93">github.com/QuantumNous/new-api/service/usage_helpr.go (0.0%)</option>
				
				<option value="file94">github.com/QuantumNous/new-api/service/user_notify.go (0.0%)</option>
				
				<option value="file95">github.com/QuantumNous/new-api/service/webhook.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/gin-gonic/gin"
)

func GetSubscription(c *gin.Context) <span class="cov0" title="0">{
        var remainQuota int
        var usedQuota int
        var err error
        var token *model.Token
        var expiredTime int64
        if common.DisplayTokenStatEnabled </span><span class="cov0" title="0">{
                tokenId := c.GetInt("token_id")
                token, err = model.GetTokenById(tokenId)
                expiredTime = token.ExpiredTime
                remainQuota = token.RemainQuota
                usedQuota = token.UsedQuota
        }</span> else<span class="cov0" title="0"> {
                userId := c.GetInt("id")
                remainQuota, err = model.GetUserQuota(userId, false)
                usedQuota, err = model.GetUserUsedQuota(userId)
        }</span>
        <span class="cov0" title="0">if expiredTime &lt;= 0 </span><span class="cov0" title="0">{
                expiredTime = 0
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                openAIError := dto.OpenAIError{
                        Message: err.Error(),
                        Type:    "upstream_error",
                }
                c.JSON(200, gin.H{
                        "error": openAIError,
                })
                return
        }</span>
        <span class="cov0" title="0">quota := remainQuota + usedQuota
        amount := float64(quota)
        // OpenAI 兼容接口中的 *_USD 字段含义保持“额度单位”对应值：
        // 我们将其解释为以“站点展示类型”为准：
        // - USD: 直接除以 QuotaPerUnit
        // - CNY: 先转 USD 再乘汇率
        // - TOKENS: 直接使用 tokens 数量
        switch operation_setting.GetQuotaDisplayType() </span>{
        case operation_setting.QuotaDisplayTypeCNY:<span class="cov0" title="0">
                amount = amount / common.QuotaPerUnit * operation_setting.USDExchangeRate</span>
        case operation_setting.QuotaDisplayTypeTokens:<span class="cov0" title="0"></span>
                // amount 保持 tokens 数值
        default:<span class="cov0" title="0">
                amount = amount / common.QuotaPerUnit</span>
        }
        <span class="cov0" title="0">if token != nil &amp;&amp; token.UnlimitedQuota </span><span class="cov0" title="0">{
                amount = 100000000
        }</span>
        <span class="cov0" title="0">subscription := OpenAISubscriptionResponse{
                Object:             "billing_subscription",
                HasPaymentMethod:   true,
                SoftLimitUSD:       amount,
                HardLimitUSD:       amount,
                SystemHardLimitUSD: amount,
                AccessUntil:        expiredTime,
        }
        c.JSON(200, subscription)
        return</span>
}

func GetUsage(c *gin.Context) <span class="cov0" title="0">{
        var quota int
        var err error
        var token *model.Token
        if common.DisplayTokenStatEnabled </span><span class="cov0" title="0">{
                tokenId := c.GetInt("token_id")
                token, err = model.GetTokenById(tokenId)
                quota = token.UsedQuota
        }</span> else<span class="cov0" title="0"> {
                userId := c.GetInt("id")
                quota, err = model.GetUserUsedQuota(userId)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                openAIError := dto.OpenAIError{
                        Message: err.Error(),
                        Type:    "new_api_error",
                }
                c.JSON(200, gin.H{
                        "error": openAIError,
                })
                return
        }</span>
        <span class="cov0" title="0">amount := float64(quota)
        switch operation_setting.GetQuotaDisplayType() </span>{
        case operation_setting.QuotaDisplayTypeCNY:<span class="cov0" title="0">
                amount = amount / common.QuotaPerUnit * operation_setting.USDExchangeRate</span>
        case operation_setting.QuotaDisplayTypeTokens:<span class="cov0" title="0"></span>
                // tokens 保持原值
        default:<span class="cov0" title="0">
                amount = amount / common.QuotaPerUnit</span>
        }
        <span class="cov0" title="0">usage := OpenAIUsageResponse{
                Object:     "list",
                TotalUsage: amount * 100,
        }
        c.JSON(200, usage)
        return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/types"

        "github.com/shopspring/decimal"

        "github.com/gin-gonic/gin"
)

// https://github.com/songquanpeng/one-api/issues/79

type OpenAISubscriptionResponse struct {
        Object             string  `json:"object"`
        HasPaymentMethod   bool    `json:"has_payment_method"`
        SoftLimitUSD       float64 `json:"soft_limit_usd"`
        HardLimitUSD       float64 `json:"hard_limit_usd"`
        SystemHardLimitUSD float64 `json:"system_hard_limit_usd"`
        AccessUntil        int64   `json:"access_until"`
}

type OpenAIUsageDailyCost struct {
        Timestamp float64 `json:"timestamp"`
        LineItems []struct {
                Name string  `json:"name"`
                Cost float64 `json:"cost"`
        }
}

type OpenAICreditGrants struct {
        Object         string  `json:"object"`
        TotalGranted   float64 `json:"total_granted"`
        TotalUsed      float64 `json:"total_used"`
        TotalAvailable float64 `json:"total_available"`
}

type OpenAIUsageResponse struct {
        Object string `json:"object"`
        //DailyCosts []OpenAIUsageDailyCost `json:"daily_costs"`
        TotalUsage float64 `json:"total_usage"` // unit: 0.01 dollar
}

type OpenAISBUsageResponse struct {
        Msg  string `json:"msg"`
        Data *struct {
                Credit string `json:"credit"`
        } `json:"data"`
}

type AIProxyUserOverviewResponse struct {
        Success   bool   `json:"success"`
        Message   string `json:"message"`
        ErrorCode int    `json:"error_code"`
        Data      struct {
                TotalPoints float64 `json:"totalPoints"`
        } `json:"data"`
}

type API2GPTUsageResponse struct {
        Object         string  `json:"object"`
        TotalGranted   float64 `json:"total_granted"`
        TotalUsed      float64 `json:"total_used"`
        TotalRemaining float64 `json:"total_remaining"`
}

type APGC2DGPTUsageResponse struct {
        //Grants         interface{} `json:"grants"`
        Object         string  `json:"object"`
        TotalAvailable float64 `json:"total_available"`
        TotalGranted   float64 `json:"total_granted"`
        TotalUsed      float64 `json:"total_used"`
}

type SiliconFlowUsageResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Status  bool   `json:"status"`
        Data    struct {
                ID            string `json:"id"`
                Name          string `json:"name"`
                Image         string `json:"image"`
                Email         string `json:"email"`
                IsAdmin       bool   `json:"isAdmin"`
                Balance       string `json:"balance"`
                Status        string `json:"status"`
                Introduction  string `json:"introduction"`
                Role          string `json:"role"`
                ChargeBalance string `json:"chargeBalance"`
                TotalBalance  string `json:"totalBalance"`
                Category      string `json:"category"`
        } `json:"data"`
}

type DeepSeekUsageResponse struct {
        IsAvailable  bool `json:"is_available"`
        BalanceInfos []struct {
                Currency        string `json:"currency"`
                TotalBalance    string `json:"total_balance"`
                GrantedBalance  string `json:"granted_balance"`
                ToppedUpBalance string `json:"topped_up_balance"`
        } `json:"balance_infos"`
}

type OpenRouterCreditResponse struct {
        Data struct {
                TotalCredits float64 `json:"total_credits"`
                TotalUsage   float64 `json:"total_usage"`
        } `json:"data"`
}

// GetAuthHeader get auth header
func GetAuthHeader(token string) http.Header <span class="cov0" title="0">{
        h := http.Header{}
        h.Add("Authorization", fmt.Sprintf("Bearer %s", token))
        return h
}</span>

// GetClaudeAuthHeader get claude auth header
func GetClaudeAuthHeader(token string) http.Header <span class="cov0" title="0">{
        h := http.Header{}
        h.Add("x-api-key", token)
        h.Add("anthropic-version", "2023-06-01")
        return h
}</span>

func GetResponseBody(method, url string, channel *model.Channel, headers http.Header) ([]byte, error) <span class="cov0" title="0">{
        req, err := http.NewRequest(method, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for k := range headers </span><span class="cov0" title="0">{
                req.Header.Add(k, headers.Get(k))
        }</span>
        <span class="cov0" title="0">client, err := service.NewProxyHttpClient(channel.GetSetting().Proxy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if res.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status code: %d", res.StatusCode)
        }</span>
        <span class="cov0" title="0">body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return body, nil</span>
}

func updateChannelCloseAIBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/dashboard/billing/credit_grants", channel.GetBaseURL())
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := OpenAICreditGrants{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(response.TotalAvailable)
        return response.TotalAvailable, nil</span>
}

func updateChannelOpenAISBBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("https://api.openai-sb.com/sb-api/user/status?api_key=%s", channel.Key)
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := OpenAISBUsageResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if response.Data == nil </span><span class="cov0" title="0">{
                return 0, errors.New(response.Msg)
        }</span>
        <span class="cov0" title="0">balance, err := strconv.ParseFloat(response.Data.Credit, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(balance)
        return balance, nil</span>
}

func updateChannelAIProxyBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://aiproxy.io/api/report/getUserOverview"
        headers := http.Header{}
        headers.Add("Api-Key", channel.Key)
        body, err := GetResponseBody("GET", url, channel, headers)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := AIProxyUserOverviewResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("code: %d, message: %s", response.ErrorCode, response.Message)
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(response.Data.TotalPoints)
        return response.Data.TotalPoints, nil</span>
}

func updateChannelAPI2GPTBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://api.api2gpt.com/dashboard/billing/credit_grants"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := API2GPTUsageResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(response.TotalRemaining)
        return response.TotalRemaining, nil</span>
}

func updateChannelSiliconFlowBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://api.siliconflow.cn/v1/user/info"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := SiliconFlowUsageResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if response.Code != 20000 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("code: %d, message: %s", response.Code, response.Message)
        }</span>
        <span class="cov0" title="0">balance, err := strconv.ParseFloat(response.Data.TotalBalance, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(balance)
        return balance, nil</span>
}

func updateChannelDeepSeekBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://api.deepseek.com/user/balance"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := DeepSeekUsageResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">index := -1
        for i, balanceInfo := range response.BalanceInfos </span><span class="cov0" title="0">{
                if balanceInfo.Currency == "CNY" </span><span class="cov0" title="0">{
                        index = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if index == -1 </span><span class="cov0" title="0">{
                return 0, errors.New("currency CNY not found")
        }</span>
        <span class="cov0" title="0">balance, err := strconv.ParseFloat(response.BalanceInfos[index].TotalBalance, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(balance)
        return balance, nil</span>
}

func updateChannelAIGC2DBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://api.aigc2d.com/dashboard/billing/credit_grants"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := APGC2DGPTUsageResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">channel.UpdateBalance(response.TotalAvailable)
        return response.TotalAvailable, nil</span>
}

func updateChannelOpenRouterBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://openrouter.ai/api/v1/credits"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">response := OpenRouterCreditResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">balance := response.Data.TotalCredits - response.Data.TotalUsage
        channel.UpdateBalance(balance)
        return balance, nil</span>
}

func updateChannelMoonshotBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        url := "https://api.moonshot.cn/v1/users/me/balance"
        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">type MoonshotBalanceData struct {
                AvailableBalance float64 `json:"available_balance"`
                VoucherBalance   float64 `json:"voucher_balance"`
                CashBalance      float64 `json:"cash_balance"`
        }

        type MoonshotBalanceResponse struct {
                Code   int                 `json:"code"`
                Data   MoonshotBalanceData `json:"data"`
                Scode  string              `json:"scode"`
                Status bool                `json:"status"`
        }

        response := MoonshotBalanceResponse{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if !response.Status || response.Code != 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to update moonshot balance, status: %v, code: %d, scode: %s", response.Status, response.Code, response.Scode)
        }</span>
        <span class="cov0" title="0">availableBalanceCny := response.Data.AvailableBalance
        availableBalanceUsd := decimal.NewFromFloat(availableBalanceCny).Div(decimal.NewFromFloat(operation_setting.Price)).InexactFloat64()
        channel.UpdateBalance(availableBalanceUsd)
        return availableBalanceUsd, nil</span>
}

func updateChannelBalance(channel *model.Channel) (float64, error) <span class="cov0" title="0">{
        baseURL := constant.ChannelBaseURLs[channel.Type]
        if channel.GetBaseURL() == "" </span><span class="cov0" title="0">{
                channel.BaseURL = &amp;baseURL
        }</span>
        <span class="cov0" title="0">switch channel.Type </span>{
        case constant.ChannelTypeOpenAI:<span class="cov0" title="0">
                if channel.GetBaseURL() != "" </span><span class="cov0" title="0">{
                        baseURL = channel.GetBaseURL()
                }</span>
        case constant.ChannelTypeAzure:<span class="cov0" title="0">
                return 0, errors.New("尚未实现")</span>
        case constant.ChannelTypeCustom:<span class="cov0" title="0">
                baseURL = channel.GetBaseURL()</span>
        //case common.ChannelTypeOpenAISB:
        //        return updateChannelOpenAISBBalance(channel)
        case constant.ChannelTypeAIProxy:<span class="cov0" title="0">
                return updateChannelAIProxyBalance(channel)</span>
        case constant.ChannelTypeAPI2GPT:<span class="cov0" title="0">
                return updateChannelAPI2GPTBalance(channel)</span>
        case constant.ChannelTypeAIGC2D:<span class="cov0" title="0">
                return updateChannelAIGC2DBalance(channel)</span>
        case constant.ChannelTypeSiliconFlow:<span class="cov0" title="0">
                return updateChannelSiliconFlowBalance(channel)</span>
        case constant.ChannelTypeDeepSeek:<span class="cov0" title="0">
                return updateChannelDeepSeekBalance(channel)</span>
        case constant.ChannelTypeOpenRouter:<span class="cov0" title="0">
                return updateChannelOpenRouterBalance(channel)</span>
        case constant.ChannelTypeMoonshot:<span class="cov0" title="0">
                return updateChannelMoonshotBalance(channel)</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("尚未实现")</span>
        }
        <span class="cov0" title="0">url := fmt.Sprintf("%s/v1/dashboard/billing/subscription", baseURL)

        body, err := GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">subscription := OpenAISubscriptionResponse{}
        err = json.Unmarshal(body, &amp;subscription)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">now := time.Now()
        startDate := fmt.Sprintf("%s-01", now.Format("2006-01"))
        endDate := now.Format("2006-01-02")
        if !subscription.HasPaymentMethod </span><span class="cov0" title="0">{
                startDate = now.AddDate(0, 0, -100).Format("2006-01-02")
        }</span>
        <span class="cov0" title="0">url = fmt.Sprintf("%s/v1/dashboard/billing/usage?start_date=%s&amp;end_date=%s", baseURL, startDate, endDate)
        body, err = GetResponseBody("GET", url, channel, GetAuthHeader(channel.Key))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">usage := OpenAIUsageResponse{}
        err = json.Unmarshal(body, &amp;usage)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">balance := subscription.HardLimitUSD - usage.TotalUsage/100
        channel.UpdateBalance(balance)
        return balance, nil</span>
}

func UpdateChannelBalance(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">channel, err := model.CacheGetChannel(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "多密钥渠道不支持余额查询",
                })
                return
        }</span>
        <span class="cov0" title="0">balance, err := updateChannelBalance(channel)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "balance": balance,
        })</span>
}

func updateAllChannelsBalance() error <span class="cov0" title="0">{
        channels, err := model.GetAllChannels(0, 0, true, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, channel := range channels </span><span class="cov0" title="0">{
                if channel.Status != common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                        continue</span> // skip multi-key channels
                }
                // TODO: support Azure
                //if channel.Type != common.ChannelTypeOpenAI &amp;&amp; channel.Type != common.ChannelTypeCustom {
                //        continue
                //}
                <span class="cov0" title="0">balance, err := updateChannelBalance(channel)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // err is nil &amp; balance &lt;= 0 means quota is used up
                        if balance &lt;= 0 </span><span class="cov0" title="0">{
                                service.DisableChannel(*types.NewChannelError(channel.Id, channel.Type, channel.Name, channel.ChannelInfo.IsMultiKey, "", channel.GetAutoBan()), "余额不足")
                        }</span>
                }
                <span class="cov0" title="0">time.Sleep(common.RequestInterval)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func UpdateAllChannelsBalance(c *gin.Context) <span class="cov0" title="0">{
        // TODO: make it async
        err := updateAllChannelsBalance()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func AutomaticallyUpdateChannels(frequency int) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(frequency) * time.Minute)
                common.SysLog("updating all channels")
                _ = updateAllChannelsBalance()
                common.SysLog("channels update done")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/middleware"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        relayconstant "github.com/QuantumNous/new-api/relay/constant"
        "github.com/QuantumNous/new-api/relay/helper"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/types"

        "github.com/bytedance/gopkg/util/gopool"
        "github.com/samber/lo"

        "github.com/gin-gonic/gin"
)

type testResult struct {
        context     *gin.Context
        localErr    error
        newAPIError *types.NewAPIError
}

func testChannel(channel *model.Channel, testModel string, endpointType string) testResult <span class="cov0" title="0">{
        tik := time.Now()
        var unsupportedTestChannelTypes = []int{
                constant.ChannelTypeMidjourney,
                constant.ChannelTypeMidjourneyPlus,
                constant.ChannelTypeSunoAPI,
                constant.ChannelTypeKling,
                constant.ChannelTypeJimeng,
                constant.ChannelTypeDoubaoVideo,
                constant.ChannelTypeVidu,
        }
        if lo.Contains(unsupportedTestChannelTypes, channel.Type) </span><span class="cov0" title="0">{
                channelTypeName := constant.GetChannelTypeName(channel.Type)
                return testResult{
                        localErr: fmt.Errorf("%s channel test is not supported", channelTypeName),
                }
        }</span>
        <span class="cov0" title="0">w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)

        testModel = strings.TrimSpace(testModel)
        if testModel == "" </span><span class="cov0" title="0">{
                if channel.TestModel != nil &amp;&amp; *channel.TestModel != "" </span><span class="cov0" title="0">{
                        testModel = strings.TrimSpace(*channel.TestModel)
                }</span> else<span class="cov0" title="0"> {
                        models := channel.GetModels()
                        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                testModel = strings.TrimSpace(models[0])
                        }</span>
                        <span class="cov0" title="0">if testModel == "" </span><span class="cov0" title="0">{
                                testModel = "gpt-4o-mini"
                        }</span>
                }
        }

        <span class="cov0" title="0">requestPath := "/v1/chat/completions"

        // 如果指定了端点类型，使用指定的端点类型
        if endpointType != "" </span><span class="cov0" title="0">{
                if endpointInfo, ok := common.GetDefaultEndpointInfo(constant.EndpointType(endpointType)); ok </span><span class="cov0" title="0">{
                        requestPath = endpointInfo.Path
                }</span>
        } else<span class="cov0" title="0"> {
                // 如果没有指定端点类型，使用原有的自动检测逻辑
                // 先判断是否为 Embedding 模型
                if strings.Contains(strings.ToLower(testModel), "embedding") ||
                        strings.HasPrefix(testModel, "m3e") || // m3e 系列模型
                        strings.Contains(testModel, "bge-") || // bge 系列模型
                        strings.Contains(testModel, "embed") ||
                        channel.Type == constant.ChannelTypeMokaAI </span><span class="cov0" title="0">{ // 其他 embedding 模型
                        requestPath = "/v1/embeddings" // 修改请求路径
                }</span>

                // VolcEngine 图像生成模型
                <span class="cov0" title="0">if channel.Type == constant.ChannelTypeVolcEngine &amp;&amp; strings.Contains(testModel, "seedream") </span><span class="cov0" title="0">{
                        requestPath = "/v1/images/generations"
                }</span>
        }

        <span class="cov0" title="0">c.Request = &amp;http.Request{
                Method: "POST",
                URL:    &amp;url.URL{Path: requestPath}, // 使用动态路径
                Body:   nil,
                Header: make(http.Header),
        }

        cache, err := model.GetUserCache(1)
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        localErr:    err,
                        newAPIError: nil,
                }
        }</span>
        <span class="cov0" title="0">cache.WriteContext(c)

        //c.Request.Header.Set("Authorization", "Bearer "+channel.Key)
        c.Request.Header.Set("Content-Type", "application/json")
        c.Set("channel", channel.Type)
        c.Set("base_url", channel.GetBaseURL())
        group, _ := model.GetUserGroup(1, false)
        c.Set("group", group)

        newAPIError := middleware.SetupContextForSelectedChannel(c, channel, testModel)
        if newAPIError != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    newAPIError,
                        newAPIError: newAPIError,
                }
        }</span>

        // Determine relay format based on endpoint type or request path
        <span class="cov0" title="0">var relayFormat types.RelayFormat
        if endpointType != "" </span><span class="cov0" title="0">{
                // 根据指定的端点类型设置 relayFormat
                switch constant.EndpointType(endpointType) </span>{
                case constant.EndpointTypeOpenAI:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatOpenAI</span>
                case constant.EndpointTypeOpenAIResponse:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatOpenAIResponses</span>
                case constant.EndpointTypeAnthropic:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatClaude</span>
                case constant.EndpointTypeGemini:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatGemini</span>
                case constant.EndpointTypeJinaRerank:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatRerank</span>
                case constant.EndpointTypeImageGeneration:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatOpenAIImage</span>
                case constant.EndpointTypeEmbeddings:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatEmbedding</span>
                default:<span class="cov0" title="0">
                        relayFormat = types.RelayFormatOpenAI</span>
                }
        } else<span class="cov0" title="0"> {
                // 根据请求路径自动检测
                relayFormat = types.RelayFormatOpenAI
                if c.Request.URL.Path == "/v1/embeddings" </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatEmbedding
                }</span>
                <span class="cov0" title="0">if c.Request.URL.Path == "/v1/images/generations" </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatOpenAIImage
                }</span>
                <span class="cov0" title="0">if c.Request.URL.Path == "/v1/messages" </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatClaude
                }</span>
                <span class="cov0" title="0">if strings.Contains(c.Request.URL.Path, "/v1beta/models") </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatGemini
                }</span>
                <span class="cov0" title="0">if c.Request.URL.Path == "/v1/rerank" || c.Request.URL.Path == "/rerank" </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatRerank
                }</span>
                <span class="cov0" title="0">if c.Request.URL.Path == "/v1/responses" </span><span class="cov0" title="0">{
                        relayFormat = types.RelayFormatOpenAIResponses
                }</span>
        }

        <span class="cov0" title="0">request := buildTestRequest(testModel, endpointType)

        info, err := relaycommon.GenRelayInfo(c, relayFormat, request, nil)

        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewError(err, types.ErrorCodeGenRelayInfoFailed),
                }
        }</span>

        <span class="cov0" title="0">info.InitChannelMeta(c)

        err = helper.ModelMappedHelper(c, info, request)
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewError(err, types.ErrorCodeChannelModelMappedError),
                }
        }</span>

        <span class="cov0" title="0">testModel = info.UpstreamModelName
        // 更新请求中的模型名称
        request.SetModelName(testModel)

        apiType, _ := common.ChannelType2APIType(channel.Type)
        adaptor := relay.GetAdaptor(apiType)
        if adaptor == nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    fmt.Errorf("invalid api type: %d, adaptor is nil", apiType),
                        newAPIError: types.NewError(fmt.Errorf("invalid api type: %d, adaptor is nil", apiType), types.ErrorCodeInvalidApiType),
                }
        }</span>

        //// 创建一个用于日志的 info 副本，移除 ApiKey
        //logInfo := info
        //logInfo.ApiKey = ""
        <span class="cov0" title="0">common.SysLog(fmt.Sprintf("testing channel %d with model %s , info %+v ", channel.Id, testModel, info.ToString()))

        priceData, err := helper.ModelPriceHelper(c, info, 0, request.GetTokenCountMeta())
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewError(err, types.ErrorCodeModelPriceError),
                }
        }</span>

        <span class="cov0" title="0">adaptor.Init(info)

        var convertedRequest any
        // 根据 RelayMode 选择正确的转换函数
        switch info.RelayMode </span>{
        case relayconstant.RelayModeEmbeddings:<span class="cov0" title="0">
                // Embedding 请求 - request 已经是正确的类型
                if embeddingReq, ok := request.(*dto.EmbeddingRequest); ok </span><span class="cov0" title="0">{
                        convertedRequest, err = adaptor.ConvertEmbeddingRequest(c, info, *embeddingReq)
                }</span> else<span class="cov0" title="0"> {
                        return testResult{
                                context:     c,
                                localErr:    errors.New("invalid embedding request type"),
                                newAPIError: types.NewError(errors.New("invalid embedding request type"), types.ErrorCodeConvertRequestFailed),
                        }
                }</span>
        case relayconstant.RelayModeImagesGenerations:<span class="cov0" title="0">
                // 图像生成请求 - request 已经是正确的类型
                if imageReq, ok := request.(*dto.ImageRequest); ok </span><span class="cov0" title="0">{
                        convertedRequest, err = adaptor.ConvertImageRequest(c, info, *imageReq)
                }</span> else<span class="cov0" title="0"> {
                        return testResult{
                                context:     c,
                                localErr:    errors.New("invalid image request type"),
                                newAPIError: types.NewError(errors.New("invalid image request type"), types.ErrorCodeConvertRequestFailed),
                        }
                }</span>
        case relayconstant.RelayModeRerank:<span class="cov0" title="0">
                // Rerank 请求 - request 已经是正确的类型
                if rerankReq, ok := request.(*dto.RerankRequest); ok </span><span class="cov0" title="0">{
                        convertedRequest, err = adaptor.ConvertRerankRequest(c, info.RelayMode, *rerankReq)
                }</span> else<span class="cov0" title="0"> {
                        return testResult{
                                context:     c,
                                localErr:    errors.New("invalid rerank request type"),
                                newAPIError: types.NewError(errors.New("invalid rerank request type"), types.ErrorCodeConvertRequestFailed),
                        }
                }</span>
        case relayconstant.RelayModeResponses:<span class="cov0" title="0">
                // Response 请求 - request 已经是正确的类型
                if responseReq, ok := request.(*dto.OpenAIResponsesRequest); ok </span><span class="cov0" title="0">{
                        convertedRequest, err = adaptor.ConvertOpenAIResponsesRequest(c, info, *responseReq)
                }</span> else<span class="cov0" title="0"> {
                        return testResult{
                                context:     c,
                                localErr:    errors.New("invalid response request type"),
                                newAPIError: types.NewError(errors.New("invalid response request type"), types.ErrorCodeConvertRequestFailed),
                        }
                }</span>
        default:<span class="cov0" title="0">
                // Chat/Completion 等其他请求类型
                if generalReq, ok := request.(*dto.GeneralOpenAIRequest); ok </span><span class="cov0" title="0">{
                        convertedRequest, err = adaptor.ConvertOpenAIRequest(c, info, generalReq)
                }</span> else<span class="cov0" title="0"> {
                        return testResult{
                                context:     c,
                                localErr:    errors.New("invalid general request type"),
                                newAPIError: types.NewError(errors.New("invalid general request type"), types.ErrorCodeConvertRequestFailed),
                        }
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewError(err, types.ErrorCodeConvertRequestFailed),
                }
        }</span>
        <span class="cov0" title="0">jsonData, err := json.Marshal(convertedRequest)
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewError(err, types.ErrorCodeJsonMarshalFailed),
                }
        }</span>
        <span class="cov0" title="0">requestBody := bytes.NewBuffer(jsonData)
        c.Request.Body = io.NopCloser(requestBody)
        resp, err := adaptor.DoRequest(c, info, requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewOpenAIError(err, types.ErrorCodeDoRequestFailed, http.StatusInternalServerError),
                }
        }</span>
        <span class="cov0" title="0">var httpResp *http.Response
        if resp != nil </span><span class="cov0" title="0">{
                httpResp = resp.(*http.Response)
                if httpResp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        err := service.RelayErrorHandler(c.Request.Context(), httpResp, true)
                        return testResult{
                                context:     c,
                                localErr:    err,
                                newAPIError: types.NewOpenAIError(err, types.ErrorCodeBadResponse, http.StatusInternalServerError),
                        }
                }</span>
        }
        <span class="cov0" title="0">usageA, respErr := adaptor.DoResponse(c, httpResp, info)
        if respErr != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    respErr,
                        newAPIError: respErr,
                }
        }</span>
        <span class="cov0" title="0">if usageA == nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    errors.New("usage is nil"),
                        newAPIError: types.NewOpenAIError(errors.New("usage is nil"), types.ErrorCodeBadResponseBody, http.StatusInternalServerError),
                }
        }</span>
        <span class="cov0" title="0">usage := usageA.(*dto.Usage)
        result := w.Result()
        respBody, err := io.ReadAll(result.Body)
        if err != nil </span><span class="cov0" title="0">{
                return testResult{
                        context:     c,
                        localErr:    err,
                        newAPIError: types.NewOpenAIError(err, types.ErrorCodeReadResponseBodyFailed, http.StatusInternalServerError),
                }
        }</span>
        <span class="cov0" title="0">info.PromptTokens = usage.PromptTokens

        quota := 0
        if !priceData.UsePrice </span><span class="cov0" title="0">{
                quota = usage.PromptTokens + int(math.Round(float64(usage.CompletionTokens)*priceData.CompletionRatio))
                quota = int(math.Round(float64(quota) * priceData.ModelRatio))
                if priceData.ModelRatio != 0 &amp;&amp; quota &lt;= 0 </span><span class="cov0" title="0">{
                        quota = 1
                }</span>
        } else<span class="cov0" title="0"> {
                quota = int(priceData.ModelPrice * common.QuotaPerUnit)
        }</span>
        <span class="cov0" title="0">tok := time.Now()
        milliseconds := tok.Sub(tik).Milliseconds()
        consumedTime := float64(milliseconds) / 1000.0
        other := service.GenerateTextOtherInfo(c, info, priceData.ModelRatio, priceData.GroupRatioInfo.GroupRatio, priceData.CompletionRatio,
                usage.PromptTokensDetails.CachedTokens, priceData.CacheRatio, priceData.ModelPrice, priceData.GroupRatioInfo.GroupSpecialRatio)
        model.RecordConsumeLog(c, 1, model.RecordConsumeLogParams{
                ChannelId:        channel.Id,
                PromptTokens:     usage.PromptTokens,
                CompletionTokens: usage.CompletionTokens,
                ModelName:        info.OriginModelName,
                TokenName:        "模型测试",
                Quota:            quota,
                Content:          "模型测试",
                UseTimeSeconds:   int(consumedTime),
                IsStream:         info.IsStream,
                Group:            info.UsingGroup,
                Other:            other,
        })
        common.SysLog(fmt.Sprintf("testing channel #%d, response: \n%s", channel.Id, string(respBody)))
        return testResult{
                context:     c,
                localErr:    nil,
                newAPIError: nil,
        }</span>
}

func buildTestRequest(model string, endpointType string) dto.Request <span class="cov0" title="0">{
        // 根据端点类型构建不同的测试请求
        if endpointType != "" </span><span class="cov0" title="0">{
                switch constant.EndpointType(endpointType) </span>{
                case constant.EndpointTypeEmbeddings:<span class="cov0" title="0">
                        // 返回 EmbeddingRequest
                        return &amp;dto.EmbeddingRequest{
                                Model: model,
                                Input: []any{"hello world"},
                        }</span>
                case constant.EndpointTypeImageGeneration:<span class="cov0" title="0">
                        // 返回 ImageRequest
                        return &amp;dto.ImageRequest{
                                Model:  model,
                                Prompt: "a cute cat",
                                N:      1,
                                Size:   "1024x1024",
                        }</span>
                case constant.EndpointTypeJinaRerank:<span class="cov0" title="0">
                        // 返回 RerankRequest
                        return &amp;dto.RerankRequest{
                                Model:     model,
                                Query:     "What is Deep Learning?",
                                Documents: []any{"Deep Learning is a subset of machine learning.", "Machine learning is a field of artificial intelligence."},
                                TopN:      2,
                        }</span>
                case constant.EndpointTypeOpenAIResponse:<span class="cov0" title="0">
                        // 返回 OpenAIResponsesRequest
                        return &amp;dto.OpenAIResponsesRequest{
                                Model: model,
                                Input: json.RawMessage("\"hi\""),
                        }</span>
                case constant.EndpointTypeAnthropic, constant.EndpointTypeGemini, constant.EndpointTypeOpenAI:<span class="cov0" title="0">
                        // 返回 GeneralOpenAIRequest
                        maxTokens := uint(10)
                        if constant.EndpointType(endpointType) == constant.EndpointTypeGemini </span><span class="cov0" title="0">{
                                maxTokens = 3000
                        }</span>
                        <span class="cov0" title="0">return &amp;dto.GeneralOpenAIRequest{
                                Model:  model,
                                Stream: false,
                                Messages: []dto.Message{
                                        {
                                                Role:    "user",
                                                Content: "hi",
                                        },
                                },
                                MaxTokens: maxTokens,
                        }</span>
                }
        }

        // 自动检测逻辑（保持原有行为）
        // 先判断是否为 Embedding 模型
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(model), "embedding") ||
                strings.HasPrefix(model, "m3e") ||
                strings.Contains(model, "bge-") </span><span class="cov0" title="0">{
                // 返回 EmbeddingRequest
                return &amp;dto.EmbeddingRequest{
                        Model: model,
                        Input: []any{"hello world"},
                }
        }</span>

        // Chat/Completion 请求 - 返回 GeneralOpenAIRequest
        <span class="cov0" title="0">testRequest := &amp;dto.GeneralOpenAIRequest{
                Model:  model,
                Stream: false,
                Messages: []dto.Message{
                        {
                                Role:    "user",
                                Content: "hi",
                        },
                },
        }

        if strings.HasPrefix(model, "o") </span><span class="cov0" title="0">{
                testRequest.MaxCompletionTokens = 10
        }</span> else<span class="cov0" title="0"> if strings.Contains(model, "thinking") </span><span class="cov0" title="0">{
                if !strings.Contains(model, "claude") </span><span class="cov0" title="0">{
                        testRequest.MaxTokens = 50
                }</span>
        } else<span class="cov0" title="0"> if strings.Contains(model, "gemini") </span><span class="cov0" title="0">{
                testRequest.MaxTokens = 3000
        }</span> else<span class="cov0" title="0"> {
                testRequest.MaxTokens = 10
        }</span>

        <span class="cov0" title="0">return testRequest</span>
}

func TestChannel(c *gin.Context) <span class="cov0" title="0">{
        channelId, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">channel, err := model.CacheGetChannel(channelId)
        if err != nil </span><span class="cov0" title="0">{
                channel, err = model.GetChannelById(channelId, true)
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>
        }
        //defer func() {
        //        if channel.ChannelInfo.IsMultiKey {
        //                go func() { _ = channel.SaveChannelInfo() }()
        //        }
        //}()
        <span class="cov0" title="0">testModel := c.Query("model")
        endpointType := c.Query("endpoint_type")
        tik := time.Now()
        result := testChannel(channel, testModel, endpointType)
        if result.localErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": result.localErr.Error(),
                        "time":    0.0,
                })
                return
        }</span>
        <span class="cov0" title="0">tok := time.Now()
        milliseconds := tok.Sub(tik).Milliseconds()
        go channel.UpdateResponseTime(milliseconds)
        consumedTime := float64(milliseconds) / 1000.0
        if result.newAPIError != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": result.newAPIError.Error(),
                        "time":    consumedTime,
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "time":    consumedTime,
        })</span>
}

var testAllChannelsLock sync.Mutex
var testAllChannelsRunning bool = false

func testAllChannels(notify bool) error <span class="cov0" title="0">{

        testAllChannelsLock.Lock()
        if testAllChannelsRunning </span><span class="cov0" title="0">{
                testAllChannelsLock.Unlock()
                return errors.New("测试已在运行中")
        }</span>
        <span class="cov0" title="0">testAllChannelsRunning = true
        testAllChannelsLock.Unlock()
        channels, getChannelErr := model.GetAllChannels(0, 0, true, false)
        if getChannelErr != nil </span><span class="cov0" title="0">{
                return getChannelErr
        }</span>
        <span class="cov0" title="0">var disableThreshold = int64(common.ChannelDisableThreshold * 1000)
        if disableThreshold == 0 </span><span class="cov0" title="0">{
                disableThreshold = 10000000 // a impossible value
        }</span>
        <span class="cov0" title="0">gopool.Go(func() </span><span class="cov0" title="0">{
                // 使用 defer 确保无论如何都会重置运行状态，防止死锁
                defer func() </span><span class="cov0" title="0">{
                        testAllChannelsLock.Lock()
                        testAllChannelsRunning = false
                        testAllChannelsLock.Unlock()
                }</span>()

                <span class="cov0" title="0">for _, channel := range channels </span><span class="cov0" title="0">{
                        isChannelEnabled := channel.Status == common.ChannelStatusEnabled
                        tik := time.Now()
                        result := testChannel(channel, "", "")
                        tok := time.Now()
                        milliseconds := tok.Sub(tik).Milliseconds()

                        shouldBanChannel := false
                        newAPIError := result.newAPIError
                        // request error disables the channel
                        if newAPIError != nil </span><span class="cov0" title="0">{
                                shouldBanChannel = service.ShouldDisableChannel(channel.Type, result.newAPIError)
                        }</span>

                        // 当错误检查通过，才检查响应时间
                        <span class="cov0" title="0">if common.AutomaticDisableChannelEnabled &amp;&amp; !shouldBanChannel </span><span class="cov0" title="0">{
                                if milliseconds &gt; disableThreshold </span><span class="cov0" title="0">{
                                        err := fmt.Errorf("响应时间 %.2fs 超过阈值 %.2fs", float64(milliseconds)/1000.0, float64(disableThreshold)/1000.0)
                                        newAPIError = types.NewOpenAIError(err, types.ErrorCodeChannelResponseTimeExceeded, http.StatusRequestTimeout)
                                        shouldBanChannel = true
                                }</span>
                        }

                        // disable channel
                        <span class="cov0" title="0">if isChannelEnabled &amp;&amp; shouldBanChannel &amp;&amp; channel.GetAutoBan() </span><span class="cov0" title="0">{
                                processChannelError(result.context, *types.NewChannelError(channel.Id, channel.Type, channel.Name, channel.ChannelInfo.IsMultiKey, common.GetContextKeyString(result.context, constant.ContextKeyChannelKey), channel.GetAutoBan()), newAPIError)
                        }</span>

                        // enable channel
                        <span class="cov0" title="0">if !isChannelEnabled &amp;&amp; service.ShouldEnableChannel(newAPIError, channel.Status) </span><span class="cov0" title="0">{
                                service.EnableChannel(channel.Id, common.GetContextKeyString(result.context, constant.ContextKeyChannelKey), channel.Name)
                        }</span>

                        <span class="cov0" title="0">channel.UpdateResponseTime(milliseconds)
                        time.Sleep(common.RequestInterval)</span>
                }

                <span class="cov0" title="0">if notify </span><span class="cov0" title="0">{
                        service.NotifyRootUser(dto.NotifyTypeChannelTest, "通道测试完成", "所有通道测试已完成")
                }</span>
        })
        <span class="cov0" title="0">return nil</span>
}

func TestAllChannels(c *gin.Context) <span class="cov0" title="0">{
        err := testAllChannels(true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })</span>
}

var autoTestChannelsOnce sync.Once

func AutomaticallyTestChannels() <span class="cov0" title="0">{
        // 只在Master节点定时测试渠道
        if !common.IsMasterNode </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">autoTestChannelsOnce.Do(func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        if !operation_setting.GetMonitorSetting().AutoTestChannelEnabled </span><span class="cov0" title="0">{
                                time.Sleep(1 * time.Minute)
                                continue</span>
                        }
                        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                                frequency := operation_setting.GetMonitorSetting().AutoTestChannelMinutes
                                time.Sleep(time.Duration(int(math.Round(frequency))) * time.Minute)
                                common.SysLog(fmt.Sprintf("automatically test channels with interval %f minutes", frequency))
                                common.SysLog("automatically testing all channels")
                                _ = testAllChannels(false)
                                common.SysLog("automatically channel test finished")
                                if !operation_setting.GetMonitorSetting().AutoTestChannelEnabled </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay/channel/volcengine"
        "github.com/QuantumNous/new-api/service"

        "github.com/gin-gonic/gin"
)

type OpenAIModel struct {
        ID         string `json:"id"`
        Object     string `json:"object"`
        Created    int64  `json:"created"`
        OwnedBy    string `json:"owned_by"`
        Permission []struct {
                ID                 string `json:"id"`
                Object             string `json:"object"`
                Created            int64  `json:"created"`
                AllowCreateEngine  bool   `json:"allow_create_engine"`
                AllowSampling      bool   `json:"allow_sampling"`
                AllowLogprobs      bool   `json:"allow_logprobs"`
                AllowSearchIndices bool   `json:"allow_search_indices"`
                AllowView          bool   `json:"allow_view"`
                AllowFineTuning    bool   `json:"allow_fine_tuning"`
                Organization       string `json:"organization"`
                Group              string `json:"group"`
                IsBlocking         bool   `json:"is_blocking"`
        } `json:"permission"`
        Root   string `json:"root"`
        Parent string `json:"parent"`
}

type OpenAIModelsResponse struct {
        Data    []OpenAIModel `json:"data"`
        Success bool          `json:"success"`
}

func parseStatusFilter(statusParam string) int <span class="cov0" title="0">{
        switch strings.ToLower(statusParam) </span>{
        case "enabled", "1":<span class="cov0" title="0">
                return common.ChannelStatusEnabled</span>
        case "disabled", "0":<span class="cov0" title="0">
                return 0</span>
        default:<span class="cov0" title="0">
                return -1</span>
        }
}

func clearChannelInfo(channel *model.Channel) <span class="cov0" title="0">{
        if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                channel.ChannelInfo.MultiKeyDisabledReason = nil
                channel.ChannelInfo.MultiKeyDisabledTime = nil
        }</span>
}

func GetAllChannels(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        channelData := make([]*model.Channel, 0)
        idSort, _ := strconv.ParseBool(c.Query("id_sort"))
        enableTagMode, _ := strconv.ParseBool(c.Query("tag_mode"))
        statusParam := c.Query("status")
        // statusFilter: -1 all, 1 enabled, 0 disabled (include auto &amp; manual)
        statusFilter := parseStatusFilter(statusParam)
        // type filter
        typeStr := c.Query("type")
        typeFilter := -1
        if typeStr != "" </span><span class="cov0" title="0">{
                if t, err := strconv.Atoi(typeStr); err == nil </span><span class="cov0" title="0">{
                        typeFilter = t
                }</span>
        }

        <span class="cov0" title="0">var total int64

        if enableTagMode </span><span class="cov0" title="0">{
                tags, err := model.GetPaginatedTags(pageInfo.GetStartIdx(), pageInfo.GetPageSize())
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                        if tag == nil || *tag == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">tagChannels, err := model.GetChannelsByTag(*tag, idSort, false)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">filtered := make([]*model.Channel, 0)
                        for _, ch := range tagChannels </span><span class="cov0" title="0">{
                                if statusFilter == common.ChannelStatusEnabled &amp;&amp; ch.Status != common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if statusFilter == 0 &amp;&amp; ch.Status == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if typeFilter &gt;= 0 &amp;&amp; ch.Type != typeFilter </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">filtered = append(filtered, ch)</span>
                        }
                        <span class="cov0" title="0">channelData = append(channelData, filtered...)</span>
                }
                <span class="cov0" title="0">total, _ = model.CountAllTags()</span>
        } else<span class="cov0" title="0"> {
                baseQuery := model.DB.Model(&amp;model.Channel{})
                if typeFilter &gt;= 0 </span><span class="cov0" title="0">{
                        baseQuery = baseQuery.Where("type = ?", typeFilter)
                }</span>
                <span class="cov0" title="0">if statusFilter == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                        baseQuery = baseQuery.Where("status = ?", common.ChannelStatusEnabled)
                }</span> else<span class="cov0" title="0"> if statusFilter == 0 </span><span class="cov0" title="0">{
                        baseQuery = baseQuery.Where("status != ?", common.ChannelStatusEnabled)
                }</span>

                <span class="cov0" title="0">baseQuery.Count(&amp;total)

                order := "priority desc"
                if idSort </span><span class="cov0" title="0">{
                        order = "id desc"
                }</span>

                <span class="cov0" title="0">err := baseQuery.Order(order).Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Omit("key").Find(&amp;channelData).Error
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                        return
                }</span>
        }

        <span class="cov0" title="0">for _, datum := range channelData </span><span class="cov0" title="0">{
                clearChannelInfo(datum)
        }</span>

        <span class="cov0" title="0">countQuery := model.DB.Model(&amp;model.Channel{})
        if statusFilter == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                countQuery = countQuery.Where("status = ?", common.ChannelStatusEnabled)
        }</span> else<span class="cov0" title="0"> if statusFilter == 0 </span><span class="cov0" title="0">{
                countQuery = countQuery.Where("status != ?", common.ChannelStatusEnabled)
        }</span>
        <span class="cov0" title="0">var results []struct {
                Type  int64
                Count int64
        }
        _ = countQuery.Select("type, count(*) as count").Group("type").Find(&amp;results).Error
        typeCounts := make(map[int64]int64)
        for _, r := range results </span><span class="cov0" title="0">{
                typeCounts[r.Type] = r.Count
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, gin.H{
                "items":       channelData,
                "total":       total,
                "page":        pageInfo.GetPage(),
                "page_size":   pageInfo.GetPageSize(),
                "type_counts": typeCounts,
        })
        return</span>
}

func FetchUpstreamModels(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">channel, err := model.GetChannelById(id, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">baseURL := constant.ChannelBaseURLs[channel.Type]
        if channel.GetBaseURL() != "" </span><span class="cov0" title="0">{
                baseURL = channel.GetBaseURL()
        }</span>

        <span class="cov0" title="0">var url string
        switch channel.Type </span>{
        case constant.ChannelTypeGemini:<span class="cov0" title="0">
                // curl https://example.com/v1beta/models?key=$GEMINI_API_KEY
                url = fmt.Sprintf("%s/v1beta/openai/models", baseURL)</span> // Remove key in url since we need to use AuthHeader
        case constant.ChannelTypeAli:<span class="cov0" title="0">
                url = fmt.Sprintf("%s/compatible-mode/v1/models", baseURL)</span>
        case constant.ChannelTypeZhipu_v4:<span class="cov0" title="0">
                url = fmt.Sprintf("%s/api/paas/v4/models", baseURL)</span>
        case constant.ChannelTypeVolcEngine:<span class="cov0" title="0">
                if baseURL == volcengine.DoubaoCodingPlan </span><span class="cov0" title="0">{
                        url = fmt.Sprintf("%s/v1/models", volcengine.DoubaoCodingPlanOpenAIBaseURL)
                }</span> else<span class="cov0" title="0"> {
                        url = fmt.Sprintf("%s/v1/models", baseURL)
                }</span>
        default:<span class="cov0" title="0">
                url = fmt.Sprintf("%s/v1/models", baseURL)</span>
        }

        // 获取用于请求的可用密钥（多密钥渠道优先使用启用状态的密钥）
        <span class="cov0" title="0">key, _, apiErr := channel.GetNextEnabledKey()
        if apiErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": fmt.Sprintf("获取渠道密钥失败: %s", apiErr.Error()),
                })
                return
        }</span>
        <span class="cov0" title="0">key = strings.TrimSpace(key)

        // 获取响应体 - 根据渠道类型决定是否添加 AuthHeader
        var body []byte
        switch channel.Type </span>{
        case constant.ChannelTypeAnthropic:<span class="cov0" title="0">
                body, err = GetResponseBody("GET", url, channel, GetClaudeAuthHeader(key))</span>
        default:<span class="cov0" title="0">
                body, err = GetResponseBody("GET", url, channel, GetAuthHeader(key))</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var result OpenAIModelsResponse
        if err = json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": fmt.Sprintf("解析响应失败: %s", err.Error()),
                })
                return
        }</span>

        <span class="cov0" title="0">var ids []string
        for _, model := range result.Data </span><span class="cov0" title="0">{
                id := model.ID
                if channel.Type == constant.ChannelTypeGemini </span><span class="cov0" title="0">{
                        id = strings.TrimPrefix(id, "models/")
                }</span>
                <span class="cov0" title="0">ids = append(ids, id)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    ids,
        })</span>
}

func FixChannelsAbilities(c *gin.Context) <span class="cov0" title="0">{
        success, fails, err := model.FixAbility()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "success": success,
                        "fails":   fails,
                },
        })</span>
}

func SearchChannels(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        group := c.Query("group")
        modelKeyword := c.Query("model")
        statusParam := c.Query("status")
        statusFilter := parseStatusFilter(statusParam)
        idSort, _ := strconv.ParseBool(c.Query("id_sort"))
        enableTagMode, _ := strconv.ParseBool(c.Query("tag_mode"))
        channelData := make([]*model.Channel, 0)
        if enableTagMode </span><span class="cov0" title="0">{
                tags, err := model.SearchTags(keyword, group, modelKeyword, idSort)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                        if tag != nil &amp;&amp; *tag != "" </span><span class="cov0" title="0">{
                                tagChannel, err := model.GetChannelsByTag(*tag, idSort, false)
                                if err == nil </span><span class="cov0" title="0">{
                                        channelData = append(channelData, tagChannel...)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                channels, err := model.SearchChannels(keyword, group, modelKeyword, idSort)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">channelData = channels</span>
        }

        <span class="cov0" title="0">if statusFilter == common.ChannelStatusEnabled || statusFilter == 0 </span><span class="cov0" title="0">{
                filtered := make([]*model.Channel, 0, len(channelData))
                for _, ch := range channelData </span><span class="cov0" title="0">{
                        if statusFilter == common.ChannelStatusEnabled &amp;&amp; ch.Status != common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if statusFilter == 0 &amp;&amp; ch.Status == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">filtered = append(filtered, ch)</span>
                }
                <span class="cov0" title="0">channelData = filtered</span>
        }

        // calculate type counts for search results
        <span class="cov0" title="0">typeCounts := make(map[int64]int64)
        for _, channel := range channelData </span><span class="cov0" title="0">{
                typeCounts[int64(channel.Type)]++
        }</span>

        <span class="cov0" title="0">typeParam := c.Query("type")
        typeFilter := -1
        if typeParam != "" </span><span class="cov0" title="0">{
                if tp, err := strconv.Atoi(typeParam); err == nil </span><span class="cov0" title="0">{
                        typeFilter = tp
                }</span>
        }

        <span class="cov0" title="0">if typeFilter &gt;= 0 </span><span class="cov0" title="0">{
                filtered := make([]*model.Channel, 0, len(channelData))
                for _, ch := range channelData </span><span class="cov0" title="0">{
                        if ch.Type == typeFilter </span><span class="cov0" title="0">{
                                filtered = append(filtered, ch)
                        }</span>
                }
                <span class="cov0" title="0">channelData = filtered</span>
        }

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("p", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        <span class="cov0" title="0">total := len(channelData)
        startIdx := (page - 1) * pageSize
        if startIdx &gt; total </span><span class="cov0" title="0">{
                startIdx = total
        }</span>
        <span class="cov0" title="0">endIdx := startIdx + pageSize
        if endIdx &gt; total </span><span class="cov0" title="0">{
                endIdx = total
        }</span>

        <span class="cov0" title="0">pagedData := channelData[startIdx:endIdx]

        for _, datum := range pagedData </span><span class="cov0" title="0">{
                clearChannelInfo(datum)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "items":       pagedData,
                        "total":       total,
                        "type_counts": typeCounts,
                },
        })
        return</span>
}

func GetChannel(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">channel, err := model.GetChannelById(id, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if channel != nil </span><span class="cov0" title="0">{
                clearChannelInfo(channel)
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    channel,
        })
        return</span>
}

// GetChannelKey 获取渠道密钥（需要通过安全验证中间件）
// 此函数依赖 SecureVerificationRequired 中间件，确保用户已通过安全验证
func GetChannelKey(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        channelId, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("渠道ID格式错误: %v", err))
                return
        }</span>

        // 获取渠道信息（包含密钥）
        <span class="cov0" title="0">channel, err := model.GetChannelById(channelId, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("获取渠道信息失败: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if channel == nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("渠道不存在"))
                return
        }</span>

        // 记录操作日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, fmt.Sprintf("查看渠道密钥信息 (渠道ID: %d)", channelId))

        // 返回渠道密钥
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "获取成功",
                "data": map[string]interface{}{
                        "key": channel.Key,
                },
        })</span>
}

// validateTwoFactorAuth 统一的2FA验证函数
func validateTwoFactorAuth(twoFA *model.TwoFA, code string) bool <span class="cov0" title="0">{
        // 尝试验证TOTP
        if cleanCode, err := common.ValidateNumericCode(code); err == nil </span><span class="cov0" title="0">{
                if isValid, _ := twoFA.ValidateTOTPAndUpdateUsage(cleanCode); isValid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // 尝试验证备用码
        <span class="cov0" title="0">if isValid, err := twoFA.ValidateBackupCodeAndUpdateUsage(code); err == nil &amp;&amp; isValid </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// validateChannel 通用的渠道校验函数
func validateChannel(channel *model.Channel, isAdd bool) error <span class="cov0" title="0">{
        // 校验 channel settings
        if err := channel.ValidateSettings(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("渠道额外设置[channel setting] 格式错误：%s", err.Error())
        }</span>

        // 如果是添加操作，检查 channel 和 key 是否为空
        <span class="cov0" title="0">if isAdd </span><span class="cov0" title="0">{
                if channel == nil || channel.Key == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("channel cannot be empty")
                }</span>

                // 检查模型名称长度是否超过 255
                <span class="cov0" title="0">for _, m := range channel.GetModels() </span><span class="cov0" title="0">{
                        if len(m) &gt; 255 </span><span class="cov0" title="0">{
                                return fmt.Errorf("模型名称过长: %s", m)
                        }</span>
                }
        }

        // VertexAI 特殊校验
        <span class="cov0" title="0">if channel.Type == constant.ChannelTypeVertexAi </span><span class="cov0" title="0">{
                if channel.Other == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("部署地区不能为空")
                }</span>

                <span class="cov0" title="0">regionMap, err := common.StrToMap(channel.Other)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("部署地区必须是标准的Json格式，例如{\"default\": \"us-central1\", \"region2\": \"us-east1\"}")
                }</span>

                <span class="cov0" title="0">if regionMap["default"] == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("部署地区必须包含default字段")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type AddChannelRequest struct {
        Mode                      string                `json:"mode"`
        MultiKeyMode              constant.MultiKeyMode `json:"multi_key_mode"`
        BatchAddSetKeyPrefix2Name bool                  `json:"batch_add_set_key_prefix_2_name"`
        Channel                   *model.Channel        `json:"channel"`
}

func getVertexArrayKeys(keys string) ([]string, error) <span class="cov0" title="0">{
        if keys == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var keyArray []interface{}
        err := common.Unmarshal([]byte(keys), &amp;keyArray)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("批量添加 Vertex AI 必须使用标准的JsonArray格式，例如[{key1}, {key2}...]，请检查输入: %w", err)
        }</span>
        <span class="cov0" title="0">cleanKeys := make([]string, 0, len(keyArray))
        for _, key := range keyArray </span><span class="cov0" title="0">{
                var keyStr string
                switch v := key.(type) </span>{
                case string:<span class="cov0" title="0">
                        keyStr = strings.TrimSpace(v)</span>
                default:<span class="cov0" title="0">
                        bytes, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Vertex AI key JSON 编码失败: %w", err)
                        }</span>
                        <span class="cov0" title="0">keyStr = string(bytes)</span>
                }
                <span class="cov0" title="0">if keyStr != "" </span><span class="cov0" title="0">{
                        cleanKeys = append(cleanKeys, keyStr)
                }</span>
        }
        <span class="cov0" title="0">if len(cleanKeys) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("批量添加 Vertex AI 的 keys 不能为空")
        }</span>
        <span class="cov0" title="0">return cleanKeys, nil</span>
}

func AddChannel(c *gin.Context) <span class="cov0" title="0">{
        addChannelRequest := AddChannelRequest{}
        err := c.ShouldBindJSON(&amp;addChannelRequest)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 使用统一的校验函数
        <span class="cov0" title="0">if err := validateChannel(addChannelRequest.Channel, true); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">addChannelRequest.Channel.CreatedTime = common.GetTimestamp()
        keys := make([]string, 0)
        switch addChannelRequest.Mode </span>{
        case "multi_to_single":<span class="cov0" title="0">
                addChannelRequest.Channel.ChannelInfo.IsMultiKey = true
                addChannelRequest.Channel.ChannelInfo.MultiKeyMode = addChannelRequest.MultiKeyMode
                if addChannelRequest.Channel.Type == constant.ChannelTypeVertexAi &amp;&amp; addChannelRequest.Channel.GetOtherSettings().VertexKeyType != dto.VertexKeyTypeAPIKey </span><span class="cov0" title="0">{
                        array, err := getVertexArrayKeys(addChannelRequest.Channel.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">addChannelRequest.Channel.ChannelInfo.MultiKeySize = len(array)
                        addChannelRequest.Channel.Key = strings.Join(array, "\n")</span>
                } else<span class="cov0" title="0"> {
                        cleanKeys := make([]string, 0)
                        for _, key := range strings.Split(addChannelRequest.Channel.Key, "\n") </span><span class="cov0" title="0">{
                                if key == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">key = strings.TrimSpace(key)
                                cleanKeys = append(cleanKeys, key)</span>
                        }
                        <span class="cov0" title="0">addChannelRequest.Channel.ChannelInfo.MultiKeySize = len(cleanKeys)
                        addChannelRequest.Channel.Key = strings.Join(cleanKeys, "\n")</span>
                }
                <span class="cov0" title="0">keys = []string{addChannelRequest.Channel.Key}</span>
        case "batch":<span class="cov0" title="0">
                if addChannelRequest.Channel.Type == constant.ChannelTypeVertexAi &amp;&amp; addChannelRequest.Channel.GetOtherSettings().VertexKeyType != dto.VertexKeyTypeAPIKey </span><span class="cov0" title="0">{
                        // multi json
                        keys, err = getVertexArrayKeys(addChannelRequest.Channel.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        keys = strings.Split(addChannelRequest.Channel.Key, "\n")
                }</span>
        case "single":<span class="cov0" title="0">
                keys = []string{addChannelRequest.Channel.Key}</span>
        default:<span class="cov0" title="0">
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "不支持的添加模式",
                })
                return</span>
        }

        <span class="cov0" title="0">channels := make([]model.Channel, 0, len(keys))
        for _, key := range keys </span><span class="cov0" title="0">{
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">localChannel := addChannelRequest.Channel
                localChannel.Key = key
                if addChannelRequest.BatchAddSetKeyPrefix2Name &amp;&amp; len(keys) &gt; 1 </span><span class="cov0" title="0">{
                        keyPrefix := localChannel.Key
                        if len(localChannel.Key) &gt; 8 </span><span class="cov0" title="0">{
                                keyPrefix = localChannel.Key[:8]
                        }</span>
                        <span class="cov0" title="0">localChannel.Name = fmt.Sprintf("%s %s", localChannel.Name, keyPrefix)</span>
                }
                <span class="cov0" title="0">channels = append(channels, *localChannel)</span>
        }
        <span class="cov0" title="0">err = model.BatchInsertChannels(channels)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">service.ResetProxyClientCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func DeleteChannel(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.Atoi(c.Param("id"))
        channel := model.Channel{Id: id}
        err := channel.Delete()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func DeleteDisabledChannel(c *gin.Context) <span class="cov0" title="0">{
        rows, err := model.DeleteDisabledChannel()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    rows,
        })
        return</span>
}

type ChannelTag struct {
        Tag            string  `json:"tag"`
        NewTag         *string `json:"new_tag"`
        Priority       *int64  `json:"priority"`
        Weight         *uint   `json:"weight"`
        ModelMapping   *string `json:"model_mapping"`
        Models         *string `json:"models"`
        Groups         *string `json:"groups"`
        ParamOverride  *string `json:"param_override"`
        HeaderOverride *string `json:"header_override"`
}

func DisableTagChannels(c *gin.Context) <span class="cov0" title="0">{
        channelTag := ChannelTag{}
        err := c.ShouldBindJSON(&amp;channelTag)
        if err != nil || channelTag.Tag == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">err = model.DisableChannelByTag(channelTag.Tag)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func EnableTagChannels(c *gin.Context) <span class="cov0" title="0">{
        channelTag := ChannelTag{}
        err := c.ShouldBindJSON(&amp;channelTag)
        if err != nil || channelTag.Tag == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">err = model.EnableChannelByTag(channelTag.Tag)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func EditTagChannels(c *gin.Context) <span class="cov0" title="0">{
        channelTag := ChannelTag{}
        err := c.ShouldBindJSON(&amp;channelTag)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">if channelTag.Tag == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "tag不能为空",
                })
                return
        }</span>
        <span class="cov0" title="0">if channelTag.ParamOverride != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*channelTag.ParamOverride)
                if trimmed != "" &amp;&amp; !json.Valid([]byte(trimmed)) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "参数覆盖必须是合法的 JSON 格式",
                        })
                        return
                }</span>
                <span class="cov0" title="0">channelTag.ParamOverride = common.GetPointer[string](trimmed)</span>
        }
        <span class="cov0" title="0">if channelTag.HeaderOverride != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*channelTag.HeaderOverride)
                if trimmed != "" &amp;&amp; !json.Valid([]byte(trimmed)) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "请求头覆盖必须是合法的 JSON 格式",
                        })
                        return
                }</span>
                <span class="cov0" title="0">channelTag.HeaderOverride = common.GetPointer[string](trimmed)</span>
        }
        <span class="cov0" title="0">err = model.EditChannelByTag(channelTag.Tag, channelTag.NewTag, channelTag.ModelMapping, channelTag.Models, channelTag.Groups, channelTag.Priority, channelTag.Weight, channelTag.ParamOverride, channelTag.HeaderOverride)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

type ChannelBatch struct {
        Ids []int   `json:"ids"`
        Tag *string `json:"tag"`
}

func DeleteChannelBatch(c *gin.Context) <span class="cov0" title="0">{
        channelBatch := ChannelBatch{}
        err := c.ShouldBindJSON(&amp;channelBatch)
        if err != nil || len(channelBatch.Ids) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">err = model.BatchDeleteChannels(channelBatch.Ids)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    len(channelBatch.Ids),
        })
        return</span>
}

type PatchChannel struct {
        model.Channel
        MultiKeyMode *string `json:"multi_key_mode"`
        KeyMode      *string `json:"key_mode"` // 多key模式下密钥覆盖或者追加
}

func UpdateChannel(c *gin.Context) <span class="cov0" title="0">{
        channel := PatchChannel{}
        err := c.ShouldBindJSON(&amp;channel)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 使用统一的校验函数
        <span class="cov0" title="0">if err := validateChannel(&amp;channel.Channel, false); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        // Preserve existing ChannelInfo to ensure multi-key channels keep correct state even if the client does not send ChannelInfo in the request.
        <span class="cov0" title="0">originChannel, err := model.GetChannelById(channel.Id, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        // Always copy the original ChannelInfo so that fields like IsMultiKey and MultiKeySize are retained.
        <span class="cov0" title="0">channel.ChannelInfo = originChannel.ChannelInfo

        // If the request explicitly specifies a new MultiKeyMode, apply it on top of the original info.
        if channel.MultiKeyMode != nil &amp;&amp; *channel.MultiKeyMode != "" </span><span class="cov0" title="0">{
                channel.ChannelInfo.MultiKeyMode = constant.MultiKeyMode(*channel.MultiKeyMode)
        }</span>

        // 处理多key模式下的密钥追加/覆盖逻辑
        <span class="cov0" title="0">if channel.KeyMode != nil &amp;&amp; channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                switch *channel.KeyMode </span>{
                case "append":<span class="cov0" title="0">
                        // 追加模式：将新密钥添加到现有密钥列表
                        if originChannel.Key != "" </span><span class="cov0" title="0">{
                                var newKeys []string
                                var existingKeys []string

                                // 解析现有密钥
                                if strings.HasPrefix(strings.TrimSpace(originChannel.Key), "[") </span><span class="cov0" title="0">{
                                        // JSON数组格式
                                        var arr []json.RawMessage
                                        if err := json.Unmarshal([]byte(strings.TrimSpace(originChannel.Key)), &amp;arr); err == nil </span><span class="cov0" title="0">{
                                                existingKeys = make([]string, len(arr))
                                                for i, v := range arr </span><span class="cov0" title="0">{
                                                        existingKeys[i] = string(v)
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // 换行分隔格式
                                        existingKeys = strings.Split(strings.Trim(originChannel.Key, "\n"), "\n")
                                }</span>

                                // 处理 Vertex AI 的特殊情况
                                <span class="cov0" title="0">if channel.Type == constant.ChannelTypeVertexAi &amp;&amp; channel.GetOtherSettings().VertexKeyType != dto.VertexKeyTypeAPIKey </span><span class="cov0" title="0">{
                                        // 尝试解析新密钥为JSON数组
                                        if strings.HasPrefix(strings.TrimSpace(channel.Key), "[") </span><span class="cov0" title="0">{
                                                array, err := getVertexArrayKeys(channel.Key)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        c.JSON(http.StatusOK, gin.H{
                                                                "success": false,
                                                                "message": "追加密钥解析失败: " + err.Error(),
                                                        })
                                                        return
                                                }</span>
                                                <span class="cov0" title="0">newKeys = array</span>
                                        } else<span class="cov0" title="0"> {
                                                // 单个JSON密钥
                                                newKeys = []string{channel.Key}
                                        }</span>
                                        // 合并密钥
                                        <span class="cov0" title="0">allKeys := append(existingKeys, newKeys...)
                                        channel.Key = strings.Join(allKeys, "\n")</span>
                                } else<span class="cov0" title="0"> {
                                        // 普通渠道的处理
                                        inputKeys := strings.Split(channel.Key, "\n")
                                        for _, key := range inputKeys </span><span class="cov0" title="0">{
                                                key = strings.TrimSpace(key)
                                                if key != "" </span><span class="cov0" title="0">{
                                                        newKeys = append(newKeys, key)
                                                }</span>
                                        }
                                        // 合并密钥
                                        <span class="cov0" title="0">allKeys := append(existingKeys, newKeys...)
                                        channel.Key = strings.Join(allKeys, "\n")</span>
                                }
                        }
                case "replace":<span class="cov0" title="0"></span>
                        // 覆盖模式：直接使用新密钥（默认行为，不需要特殊处理）
                }
        }
        <span class="cov0" title="0">err = channel.Update()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        service.ResetProxyClientCache()
        channel.Key = ""
        clearChannelInfo(&amp;channel.Channel)
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    channel,
        })
        return</span>
}

func FetchModels(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                BaseURL string `json:"base_url"`
                Type    int    `json:"type"`
                Key     string `json:"key"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "message": "Invalid request",
                })
                return
        }</span>

        <span class="cov0" title="0">baseURL := req.BaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = constant.ChannelBaseURLs[req.Type]
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        url := fmt.Sprintf("%s/v1/models", baseURL)

        request, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        // remove line breaks and extra spaces.
        <span class="cov0" title="0">key := strings.TrimSpace(req.Key)
        // If the key contains a line break, only take the first part.
        key = strings.Split(key, "\n")[0]
        request.Header.Set("Authorization", "Bearer "+key)

        response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        //check status code
        <span class="cov0" title="0">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "message": "Failed to fetch models",
                })
                return
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        var result struct {
                Data []struct {
                        ID string `json:"id"`
                } `json:"data"`
        }

        if err := json.NewDecoder(response.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">var models []string
        for _, model := range result.Data </span><span class="cov0" title="0">{
                models = append(models, model.ID)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    models,
        })</span>
}

func BatchSetChannelTag(c *gin.Context) <span class="cov0" title="0">{
        channelBatch := ChannelBatch{}
        err := c.ShouldBindJSON(&amp;channelBatch)
        if err != nil || len(channelBatch.Ids) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">err = model.BatchSetChannelTag(channelBatch.Ids, channelBatch.Tag)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    len(channelBatch.Ids),
        })
        return</span>
}

func GetTagModels(c *gin.Context) <span class="cov0" title="0">{
        tag := c.Query("tag")
        if tag == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "message": "tag不能为空",
                })
                return
        }</span>

        <span class="cov0" title="0">channels, err := model.GetChannelsByTag(tag, false, false) // idSort=false, selectAll=false
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">var longestModels string
        maxLength := 0

        // Find the longest models string among all channels with the given tag
        for _, channel := range channels </span><span class="cov0" title="0">{
                if channel.Models != "" </span><span class="cov0" title="0">{
                        currentModels := strings.Split(channel.Models, ",")
                        if len(currentModels) &gt; maxLength </span><span class="cov0" title="0">{
                                maxLength = len(currentModels)
                                longestModels = channel.Models
                        }</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    longestModels,
        })
        return</span>
}

// CopyChannel handles cloning an existing channel with its key.
// POST /api/channel/copy/:id
// Optional query params:
//
//        suffix         - string appended to the original name (default "_复制")
//        reset_balance  - bool, when true will reset balance &amp; used_quota to 0 (default true)
func CopyChannel(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">suffix := c.DefaultQuery("suffix", "_复制")
        resetBalance := true
        if rbStr := c.DefaultQuery("reset_balance", "true"); rbStr != "" </span><span class="cov0" title="0">{
                if v, err := strconv.ParseBool(rbStr); err == nil </span><span class="cov0" title="0">{
                        resetBalance = v
                }</span>
        }

        // fetch original channel with key
        <span class="cov0" title="0">origin, err := model.GetChannelById(id, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                return
        }</span>

        // clone channel
        <span class="cov0" title="0">clone := *origin // shallow copy is sufficient as we will overwrite primitives
        clone.Id = 0     // let DB auto-generate
        clone.CreatedTime = common.GetTimestamp()
        clone.Name = origin.Name + suffix
        clone.TestTime = 0
        clone.ResponseTime = 0
        if resetBalance </span><span class="cov0" title="0">{
                clone.Balance = 0
                clone.UsedQuota = 0
        }</span>

        // insert
        <span class="cov0" title="0">if err := model.BatchInsertChannels([]model.Channel{clone}); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">model.InitChannelCache()
        // success
        c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": gin.H{"id": clone.Id}})</span>
}

// MultiKeyManageRequest represents the request for multi-key management operations
type MultiKeyManageRequest struct {
        ChannelId int    `json:"channel_id"`
        Action    string `json:"action"`              // "disable_key", "enable_key", "delete_key", "delete_disabled_keys", "get_key_status"
        KeyIndex  *int   `json:"key_index,omitempty"` // for disable_key, enable_key, and delete_key actions
        Page      int    `json:"page,omitempty"`      // for get_key_status pagination
        PageSize  int    `json:"page_size,omitempty"` // for get_key_status pagination
        Status    *int   `json:"status,omitempty"`    // for get_key_status filtering: 1=enabled, 2=manual_disabled, 3=auto_disabled, nil=all
}

// MultiKeyStatusResponse represents the response for key status query
type MultiKeyStatusResponse struct {
        Keys       []KeyStatus `json:"keys"`
        Total      int         `json:"total"`
        Page       int         `json:"page"`
        PageSize   int         `json:"page_size"`
        TotalPages int         `json:"total_pages"`
        // Statistics
        EnabledCount        int `json:"enabled_count"`
        ManualDisabledCount int `json:"manual_disabled_count"`
        AutoDisabledCount   int `json:"auto_disabled_count"`
}

type KeyStatus struct {
        Index        int    `json:"index"`
        Status       int    `json:"status"` // 1: enabled, 2: disabled
        DisabledTime int64  `json:"disabled_time,omitempty"`
        Reason       string `json:"reason,omitempty"`
        KeyPreview   string `json:"key_preview"` // first 10 chars of key for identification
}

// ManageMultiKeys handles multi-key management operations
func ManageMultiKeys(c *gin.Context) <span class="cov0" title="0">{
        request := MultiKeyManageRequest{}
        err := c.ShouldBindJSON(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">channel, err := model.GetChannelById(request.ChannelId, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "渠道不存在",
                })
                return
        }</span>

        <span class="cov0" title="0">if !channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该渠道不是多密钥模式",
                })
                return
        }</span>

        <span class="cov0" title="0">lock := model.GetChannelPollingLock(channel.Id)
        lock.Lock()
        defer lock.Unlock()

        switch request.Action </span>{
        case "get_key_status":<span class="cov0" title="0">
                keys := channel.GetKeys()

                // Default pagination parameters
                page := request.Page
                pageSize := request.PageSize
                if page &lt;= 0 </span><span class="cov0" title="0">{
                        page = 1
                }</span>
                <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                        pageSize = 50 // Default page size
                }</span>

                // Statistics for all keys (unchanged by filtering)
                <span class="cov0" title="0">var enabledCount, manualDisabledCount, autoDisabledCount int

                // Build all key status data first
                var allKeyStatusList []KeyStatus
                for i, key := range keys </span><span class="cov0" title="0">{
                        status := 1 // default enabled
                        var disabledTime int64
                        var reason string

                        if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                                if s, exists := channel.ChannelInfo.MultiKeyStatusList[i]; exists </span><span class="cov0" title="0">{
                                        status = s
                                }</span>
                        }

                        // Count for statistics (all keys)
                        <span class="cov0" title="0">switch status </span>{
                        case 1:<span class="cov0" title="0">
                                enabledCount++</span>
                        case 2:<span class="cov0" title="0">
                                manualDisabledCount++</span>
                        case 3:<span class="cov0" title="0">
                                autoDisabledCount++</span>
                        }

                        <span class="cov0" title="0">if status != 1 </span><span class="cov0" title="0">{
                                if channel.ChannelInfo.MultiKeyDisabledTime != nil </span><span class="cov0" title="0">{
                                        disabledTime = channel.ChannelInfo.MultiKeyDisabledTime[i]
                                }</span>
                                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason != nil </span><span class="cov0" title="0">{
                                        reason = channel.ChannelInfo.MultiKeyDisabledReason[i]
                                }</span>
                        }

                        // Create key preview (first 10 chars)
                        <span class="cov0" title="0">keyPreview := key
                        if len(key) &gt; 10 </span><span class="cov0" title="0">{
                                keyPreview = key[:10] + "..."
                        }</span>

                        <span class="cov0" title="0">allKeyStatusList = append(allKeyStatusList, KeyStatus{
                                Index:        i,
                                Status:       status,
                                DisabledTime: disabledTime,
                                Reason:       reason,
                                KeyPreview:   keyPreview,
                        })</span>
                }

                // Apply status filter if specified
                <span class="cov0" title="0">var filteredKeyStatusList []KeyStatus
                if request.Status != nil </span><span class="cov0" title="0">{
                        for _, keyStatus := range allKeyStatusList </span><span class="cov0" title="0">{
                                if keyStatus.Status == *request.Status </span><span class="cov0" title="0">{
                                        filteredKeyStatusList = append(filteredKeyStatusList, keyStatus)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        filteredKeyStatusList = allKeyStatusList
                }</span>

                // Calculate pagination based on filtered results
                <span class="cov0" title="0">filteredTotal := len(filteredKeyStatusList)
                totalPages := (filteredTotal + pageSize - 1) / pageSize
                if totalPages == 0 </span><span class="cov0" title="0">{
                        totalPages = 1
                }</span>
                <span class="cov0" title="0">if page &gt; totalPages </span><span class="cov0" title="0">{
                        page = totalPages
                }</span>

                // Calculate range for current page
                <span class="cov0" title="0">start := (page - 1) * pageSize
                end := start + pageSize
                if end &gt; filteredTotal </span><span class="cov0" title="0">{
                        end = filteredTotal
                }</span>

                // Get the page data
                <span class="cov0" title="0">var pageKeyStatusList []KeyStatus
                if start &lt; filteredTotal </span><span class="cov0" title="0">{
                        pageKeyStatusList = filteredKeyStatusList[start:end]
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                        "data": MultiKeyStatusResponse{
                                Keys:                pageKeyStatusList,
                                Total:               filteredTotal, // Total of filtered results
                                Page:                page,
                                PageSize:            pageSize,
                                TotalPages:          totalPages,
                                EnabledCount:        enabledCount,        // Overall statistics
                                ManualDisabledCount: manualDisabledCount, // Overall statistics
                                AutoDisabledCount:   autoDisabledCount,   // Overall statistics
                        },
                })
                return</span>

        case "disable_key":<span class="cov0" title="0">
                if request.KeyIndex == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "未指定要禁用的密钥索引",
                        })
                        return
                }</span>

                <span class="cov0" title="0">keyIndex := *request.KeyIndex
                if keyIndex &lt; 0 || keyIndex &gt;= channel.ChannelInfo.MultiKeySize </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "密钥索引超出范围",
                        })
                        return
                }</span>

                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyStatusList == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyStatusList = make(map[int]int)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledTime == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyDisabledTime = make(map[int]int64)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyDisabledReason = make(map[int]string)
                }</span>

                <span class="cov0" title="0">channel.ChannelInfo.MultiKeyStatusList[keyIndex] = 2 // disabled

                err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "密钥已禁用",
                })
                return</span>

        case "enable_key":<span class="cov0" title="0">
                if request.KeyIndex == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "未指定要启用的密钥索引",
                        })
                        return
                }</span>

                <span class="cov0" title="0">keyIndex := *request.KeyIndex
                if keyIndex &lt; 0 || keyIndex &gt;= channel.ChannelInfo.MultiKeySize </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "密钥索引超出范围",
                        })
                        return
                }</span>

                // 从状态列表中删除该密钥的记录，使其回到默认启用状态
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                        delete(channel.ChannelInfo.MultiKeyStatusList, keyIndex)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledTime != nil </span><span class="cov0" title="0">{
                        delete(channel.ChannelInfo.MultiKeyDisabledTime, keyIndex)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason != nil </span><span class="cov0" title="0">{
                        delete(channel.ChannelInfo.MultiKeyDisabledReason, keyIndex)
                }</span>

                <span class="cov0" title="0">err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "密钥已启用",
                })
                return</span>

        case "enable_all_keys":<span class="cov0" title="0">
                // 清空所有禁用状态，使所有密钥回到默认启用状态
                var enabledCount int
                if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                        enabledCount = len(channel.ChannelInfo.MultiKeyStatusList)
                }</span>

                <span class="cov0" title="0">channel.ChannelInfo.MultiKeyStatusList = make(map[int]int)
                channel.ChannelInfo.MultiKeyDisabledTime = make(map[int]int64)
                channel.ChannelInfo.MultiKeyDisabledReason = make(map[int]string)

                err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": fmt.Sprintf("已启用 %d 个密钥", enabledCount),
                })
                return</span>

        case "disable_all_keys":<span class="cov0" title="0">
                // 禁用所有启用的密钥
                if channel.ChannelInfo.MultiKeyStatusList == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyStatusList = make(map[int]int)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledTime == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyDisabledTime = make(map[int]int64)
                }</span>
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyDisabledReason = make(map[int]string)
                }</span>

                <span class="cov0" title="0">var disabledCount int
                for i := 0; i &lt; channel.ChannelInfo.MultiKeySize; i++ </span><span class="cov0" title="0">{
                        status := 1 // default enabled
                        if s, exists := channel.ChannelInfo.MultiKeyStatusList[i]; exists </span><span class="cov0" title="0">{
                                status = s
                        }</span>

                        // 只禁用当前启用的密钥
                        <span class="cov0" title="0">if status == 1 </span><span class="cov0" title="0">{
                                channel.ChannelInfo.MultiKeyStatusList[i] = 2 // disabled
                                disabledCount++
                        }</span>
                }

                <span class="cov0" title="0">if disabledCount == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "没有可禁用的密钥",
                        })
                        return
                }</span>

                <span class="cov0" title="0">err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": fmt.Sprintf("已禁用 %d 个密钥", disabledCount),
                })
                return</span>

        case "delete_key":<span class="cov0" title="0">
                if request.KeyIndex == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "未指定要删除的密钥索引",
                        })
                        return
                }</span>

                <span class="cov0" title="0">keyIndex := *request.KeyIndex
                if keyIndex &lt; 0 || keyIndex &gt;= channel.ChannelInfo.MultiKeySize </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "密钥索引超出范围",
                        })
                        return
                }</span>

                <span class="cov0" title="0">keys := channel.GetKeys()
                var remainingKeys []string
                var newStatusList = make(map[int]int)
                var newDisabledTime = make(map[int]int64)
                var newDisabledReason = make(map[int]string)

                newIndex := 0
                for i, key := range keys </span><span class="cov0" title="0">{
                        // 跳过要删除的密钥
                        if i == keyIndex </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">remainingKeys = append(remainingKeys, key)

                        // 保留其他密钥的状态信息，重新索引
                        if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                                if status, exists := channel.ChannelInfo.MultiKeyStatusList[i]; exists &amp;&amp; status != 1 </span><span class="cov0" title="0">{
                                        newStatusList[newIndex] = status
                                }</span>
                        }
                        <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledTime != nil </span><span class="cov0" title="0">{
                                if t, exists := channel.ChannelInfo.MultiKeyDisabledTime[i]; exists </span><span class="cov0" title="0">{
                                        newDisabledTime[newIndex] = t
                                }</span>
                        }
                        <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason != nil </span><span class="cov0" title="0">{
                                if r, exists := channel.ChannelInfo.MultiKeyDisabledReason[i]; exists </span><span class="cov0" title="0">{
                                        newDisabledReason[newIndex] = r
                                }</span>
                        }
                        <span class="cov0" title="0">newIndex++</span>
                }

                <span class="cov0" title="0">if len(remainingKeys) == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "不能删除最后一个密钥",
                        })
                        return
                }</span>

                // Update channel with remaining keys
                <span class="cov0" title="0">channel.Key = strings.Join(remainingKeys, "\n")
                channel.ChannelInfo.MultiKeySize = len(remainingKeys)
                channel.ChannelInfo.MultiKeyStatusList = newStatusList
                channel.ChannelInfo.MultiKeyDisabledTime = newDisabledTime
                channel.ChannelInfo.MultiKeyDisabledReason = newDisabledReason

                err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "密钥已删除",
                })
                return</span>

        case "delete_disabled_keys":<span class="cov0" title="0">
                keys := channel.GetKeys()
                var remainingKeys []string
                var deletedCount int
                var newStatusList = make(map[int]int)
                var newDisabledTime = make(map[int]int64)
                var newDisabledReason = make(map[int]string)

                newIndex := 0
                for i, key := range keys </span><span class="cov0" title="0">{
                        status := 1 // default enabled
                        if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                                if s, exists := channel.ChannelInfo.MultiKeyStatusList[i]; exists </span><span class="cov0" title="0">{
                                        status = s
                                }</span>
                        }

                        // 只删除自动禁用（status == 3）的密钥，保留启用（status == 1）和手动禁用（status == 2）的密钥
                        <span class="cov0" title="0">if status == 3 </span><span class="cov0" title="0">{
                                deletedCount++
                        }</span> else<span class="cov0" title="0"> {
                                remainingKeys = append(remainingKeys, key)
                                // 保留非自动禁用密钥的状态信息，重新索引
                                if status != 1 </span><span class="cov0" title="0">{
                                        newStatusList[newIndex] = status
                                        if channel.ChannelInfo.MultiKeyDisabledTime != nil </span><span class="cov0" title="0">{
                                                if t, exists := channel.ChannelInfo.MultiKeyDisabledTime[i]; exists </span><span class="cov0" title="0">{
                                                        newDisabledTime[newIndex] = t
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledReason != nil </span><span class="cov0" title="0">{
                                                if r, exists := channel.ChannelInfo.MultiKeyDisabledReason[i]; exists </span><span class="cov0" title="0">{
                                                        newDisabledReason[newIndex] = r
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">newIndex++</span>
                        }
                }

                <span class="cov0" title="0">if deletedCount == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "没有需要删除的自动禁用密钥",
                        })
                        return
                }</span>

                // Update channel with remaining keys
                <span class="cov0" title="0">channel.Key = strings.Join(remainingKeys, "\n")
                channel.ChannelInfo.MultiKeySize = len(remainingKeys)
                channel.ChannelInfo.MultiKeyStatusList = newStatusList
                channel.ChannelInfo.MultiKeyDisabledTime = newDisabledTime
                channel.ChannelInfo.MultiKeyDisabledReason = newDisabledReason

                err = channel.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                <span class="cov0" title="0">model.InitChannelCache()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": fmt.Sprintf("已删除 %d 个自动禁用的密钥", deletedCount),
                        "data":    deletedCount,
                })
                return</span>

        default:<span class="cov0" title="0">
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "不支持的操作",
                })
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// 用于迁移检测的旧键，该文件下个版本会删除

package controller

import (
        "encoding/json"
        "net/http"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// MigrateConsoleSetting 迁移旧的控制台相关配置到 console_setting.*
func MigrateConsoleSetting(c *gin.Context) <span class="cov0" title="0">{
        // 读取全部 option
        opts, err := model.AllOption()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"success": false, "message": err.Error()})
                return
        }</span>
        // 建立 map
        <span class="cov0" title="0">valMap := map[string]string{}
        for _, o := range opts </span><span class="cov0" title="0">{
                valMap[o.Key] = o.Value
        }</span>

        // 处理 APIInfo
        <span class="cov0" title="0">if v := valMap["ApiInfo"]; v != "" </span><span class="cov0" title="0">{
                var arr []map[string]interface{}
                if err := json.Unmarshal([]byte(v), &amp;arr); err == nil </span><span class="cov0" title="0">{
                        if len(arr) &gt; 50 </span><span class="cov0" title="0">{
                                arr = arr[:50]
                        }</span>
                        <span class="cov0" title="0">bytes, _ := json.Marshal(arr)
                        model.UpdateOption("console_setting.api_info", string(bytes))</span>
                }
                <span class="cov0" title="0">model.UpdateOption("ApiInfo", "")</span>
        }
        // Announcements 直接搬
        <span class="cov0" title="0">if v := valMap["Announcements"]; v != "" </span><span class="cov0" title="0">{
                model.UpdateOption("console_setting.announcements", v)
                model.UpdateOption("Announcements", "")
        }</span>
        // FAQ 转换
        <span class="cov0" title="0">if v := valMap["FAQ"]; v != "" </span><span class="cov0" title="0">{
                var arr []map[string]interface{}
                if err := json.Unmarshal([]byte(v), &amp;arr); err == nil </span><span class="cov0" title="0">{
                        out := []map[string]interface{}{}
                        for _, item := range arr </span><span class="cov0" title="0">{
                                q, _ := item["question"].(string)
                                if q == "" </span><span class="cov0" title="0">{
                                        q, _ = item["title"].(string)
                                }</span>
                                <span class="cov0" title="0">a, _ := item["answer"].(string)
                                if a == "" </span><span class="cov0" title="0">{
                                        a, _ = item["content"].(string)
                                }</span>
                                <span class="cov0" title="0">if q != "" &amp;&amp; a != "" </span><span class="cov0" title="0">{
                                        out = append(out, map[string]interface{}{"question": q, "answer": a})
                                }</span>
                        }
                        <span class="cov0" title="0">if len(out) &gt; 50 </span><span class="cov0" title="0">{
                                out = out[:50]
                        }</span>
                        <span class="cov0" title="0">bytes, _ := json.Marshal(out)
                        model.UpdateOption("console_setting.faq", string(bytes))</span>
                }
                <span class="cov0" title="0">model.UpdateOption("FAQ", "")</span>
        }
        // Uptime Kuma 迁移到新的 groups 结构（console_setting.uptime_kuma_groups）
        <span class="cov0" title="0">url := valMap["UptimeKumaUrl"]
        slug := valMap["UptimeKumaSlug"]
        if url != "" &amp;&amp; slug != "" </span><span class="cov0" title="0">{
                // 仅当同时存在 URL 与 Slug 时才进行迁移
                groups := []map[string]interface{}{
                        {
                                "id":           1,
                                "categoryName": "old",
                                "url":          url,
                                "slug":         slug,
                                "description":  "",
                        },
                }
                bytes, _ := json.Marshal(groups)
                model.UpdateOption("console_setting.uptime_kuma_groups", string(bytes))
        }</span>
        // 清空旧键内容
        <span class="cov0" title="0">if url != "" </span><span class="cov0" title="0">{
                model.UpdateOption("UptimeKumaUrl", "")
        }</span>
        <span class="cov0" title="0">if slug != "" </span><span class="cov0" title="0">{
                model.UpdateOption("UptimeKumaSlug", "")
        }</span>

        // 删除旧键记录
        <span class="cov0" title="0">oldKeys := []string{"ApiInfo", "Announcements", "FAQ", "UptimeKumaUrl", "UptimeKumaSlug"}
        model.DB.Where("key IN ?", oldKeys).Delete(&amp;model.Option{})

        // 重新加载 OptionMap
        model.InitOptionMap()
        common.SysLog("console setting migrated")
        c.JSON(http.StatusOK, gin.H{"success": true, "message": "migrated"})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type DiscordResponse struct {
        AccessToken  string `json:"access_token"`
        IDToken      string `json:"id_token"`
        RefreshToken string `json:"refresh_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int    `json:"expires_in"`
        Scope        string `json:"scope"`
}

type DiscordUser struct {
        UID  string `json:"id"`
        ID   string `json:"username"`
        Name string `json:"global_name"`
}

func getDiscordUserInfoByCode(code string) (*DiscordUser, error) <span class="cov0" title="0">{
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("无效的参数")
        }</span>

        <span class="cov0" title="0">values := url.Values{}
        values.Set("client_id", system_setting.GetDiscordSettings().ClientId)
        values.Set("client_secret", system_setting.GetDiscordSettings().ClientSecret)
        values.Set("code", code)
        values.Set("grant_type", "authorization_code")
        values.Set("redirect_uri", fmt.Sprintf("%s/oauth/discord", system_setting.ServerAddress))
        formData := values.Encode()
        req, err := http.NewRequest("POST", "https://discord.com/api/v10/oauth2/token", strings.NewReader(formData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("Accept", "application/json")
        client := http.Client{
                Timeout: 5 * time.Second,
        }
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 Discord 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        var discordResponse DiscordResponse
        err = json.NewDecoder(res.Body).Decode(&amp;discordResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if discordResponse.AccessToken == "" </span><span class="cov0" title="0">{
                common.SysError("Discord 获取 Token 失败，请检查设置！")
                return nil, errors.New("Discord 获取 Token 失败，请检查设置！")
        }</span>

        <span class="cov0" title="0">req, err = http.NewRequest("GET", "https://discord.com/api/v10/users/@me", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+discordResponse.AccessToken)
        res2, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 Discord 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res2.Body.Close()
        if res2.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                common.SysError("Discord 获取用户信息失败！请检查设置！")
                return nil, errors.New("Discord 获取用户信息失败！请检查设置！")
        }</span>

        <span class="cov0" title="0">var discordUser DiscordUser
        err = json.NewDecoder(res2.Body).Decode(&amp;discordUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if discordUser.UID == "" || discordUser.ID == "" </span><span class="cov0" title="0">{
                common.SysError("Discord 获取用户信息为空！请检查设置！")
                return nil, errors.New("Discord 获取用户信息为空！请检查设置！")
        }</span>
        <span class="cov0" title="0">return &amp;discordUser, nil</span>
}

func DiscordOAuth(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        state := c.Query("state")
        if state == "" || session.Get("oauth_state") == nil || state != session.Get("oauth_state").(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "message": "state is empty or not same",
                })
                return
        }</span>
        <span class="cov0" title="0">username := session.Get("username")
        if username != nil </span><span class="cov0" title="0">{
                DiscordBind(c)
                return
        }</span>
                <span class="cov0" title="0">if !system_setting.GetDiscordSettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 Discord 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        discordUser, err := getDiscordUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                DiscordId: discordUser.UID,
        }
        if model.IsDiscordIdAlreadyTaken(user.DiscordId) </span><span class="cov0" title="0">{
                err := user.FillUserByDiscordId()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if common.RegisterEnabled </span><span class="cov0" title="0">{
                        if discordUser.ID != "" </span><span class="cov0" title="0">{
                                user.Username = discordUser.ID
                        }</span> else<span class="cov0" title="0"> {
                                user.Username = "discord_" + strconv.Itoa(model.GetMaxUserId()+1)
                        }</span>
                        <span class="cov0" title="0">if discordUser.Name != "" </span><span class="cov0" title="0">{
                                user.DisplayName = discordUser.Name
                        }</span> else<span class="cov0" title="0"> {
                                user.DisplayName = "Discord User"
                        }</span>
                        <span class="cov0" title="0">err := user.Insert(0)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员关闭了新用户注册",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "用户已被封禁",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

func DiscordBind(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetDiscordSettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 Discord 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        discordUser, err := getDiscordUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                DiscordId: discordUser.UID,
        }
        if model.IsDiscordIdAlreadyTaken(user.DiscordId) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该 Discord 账户已被绑定",
                })
                return
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        user.Id = id.(int)
        err = user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user.DiscordId = discordUser.UID
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "bind",
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type GitHubOAuthResponse struct {
        AccessToken string `json:"access_token"`
        Scope       string `json:"scope"`
        TokenType   string `json:"token_type"`
}

type GitHubUser struct {
        Login string `json:"login"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

func getGitHubUserInfoByCode(code string) (*GitHubUser, error) <span class="cov0" title="0">{
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("无效的参数")
        }</span>
        <span class="cov0" title="0">values := map[string]string{"client_id": common.GitHubClientId, "client_secret": common.GitHubClientSecret, "code": code}
        jsonData, err := json.Marshal(values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest("POST", "https://github.com/login/oauth/access_token", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")
        client := http.Client{
                Timeout: 20 * time.Second,
        }
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 GitHub 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        var oAuthResponse GitHubOAuthResponse
        err = json.NewDecoder(res.Body).Decode(&amp;oAuthResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err = http.NewRequest("GET", "https://api.github.com/user", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", oAuthResponse.AccessToken))
        res2, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 GitHub 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res2.Body.Close()
        var githubUser GitHubUser
        err = json.NewDecoder(res2.Body).Decode(&amp;githubUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if githubUser.Login == "" </span><span class="cov0" title="0">{
                return nil, errors.New("返回值非法，用户字段为空，请稍后重试！")
        }</span>
        <span class="cov0" title="0">return &amp;githubUser, nil</span>
}

func GitHubOAuth(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        state := c.Query("state")
        if state == "" || session.Get("oauth_state") == nil || state != session.Get("oauth_state").(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "message": "state is empty or not same",
                })
                return
        }</span>
        <span class="cov0" title="0">username := session.Get("username")
        if username != nil </span><span class="cov0" title="0">{
                GitHubBind(c)
                return
        }</span>

        <span class="cov0" title="0">if !common.GitHubOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 GitHub 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        githubUser, err := getGitHubUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                GitHubId: githubUser.Login,
        }
        // IsGitHubIdAlreadyTaken is unscoped
        if model.IsGitHubIdAlreadyTaken(user.GitHubId) </span><span class="cov0" title="0">{
                // FillUserByGitHubId is scoped
                err := user.FillUserByGitHubId()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
                // if user.Id == 0 , user has been deleted
                <span class="cov0" title="0">if user.Id == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "用户已注销",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if common.RegisterEnabled </span><span class="cov0" title="0">{
                        user.Username = "github_" + strconv.Itoa(model.GetMaxUserId()+1)
                        if githubUser.Name != "" </span><span class="cov0" title="0">{
                                user.DisplayName = githubUser.Name
                        }</span> else<span class="cov0" title="0"> {
                                user.DisplayName = "GitHub User"
                        }</span>
                        <span class="cov0" title="0">user.Email = githubUser.Email
                        user.Role = common.RoleCommonUser
                        user.Status = common.UserStatusEnabled
                        affCode := session.Get("aff")
                        inviterId := 0
                        if affCode != nil </span><span class="cov0" title="0">{
                                inviterId, _ = model.GetUserIdByAffCode(affCode.(string))
                        }</span>

                        <span class="cov0" title="0">if err := user.Insert(inviterId); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员关闭了新用户注册",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "用户已被封禁",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

func GitHubBind(c *gin.Context) <span class="cov0" title="0">{
        if !common.GitHubOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 GitHub 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        githubUser, err := getGitHubUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                GitHubId: githubUser.Login,
        }
        if model.IsGitHubIdAlreadyTaken(user.GitHubId) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该 GitHub 账户已被绑定",
                })
                return
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        // id := c.GetInt("id")  // critical bug!
        user.Id = id.(int)
        err = user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user.GitHubId = githubUser.Login
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "bind",
        })
        return</span>
}

func GenerateOAuthCode(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        state := common.GetRandomString(12)
        affCode := c.Query("aff")
        if affCode != "" </span><span class="cov0" title="0">{
                session.Set("aff", affCode)
        }</span>
        <span class="cov0" title="0">session.Set("oauth_state", state)
        err := session.Save()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    state,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "net/http"

        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"

        "github.com/gin-gonic/gin"
)

func GetGroups(c *gin.Context) <span class="cov0" title="0">{
        groupNames := make([]string, 0)
        for groupName := range ratio_setting.GetGroupRatioCopy() </span><span class="cov0" title="0">{
                groupNames = append(groupNames, groupName)
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    groupNames,
        })</span>
}

func GetUserGroups(c *gin.Context) <span class="cov0" title="0">{
        usableGroups := make(map[string]map[string]interface{})
        userGroup := ""
        userId := c.GetInt("id")
        userGroup, _ = model.GetUserGroup(userId, false)
        userUsableGroups := service.GetUserUsableGroups(userGroup)
        for groupName, _ := range ratio_setting.GetGroupRatioCopy() </span><span class="cov0" title="0">{
                // UserUsableGroups contains the groups that the user can use
                if desc, ok := userUsableGroups[groupName]; ok </span><span class="cov0" title="0">{
                        usableGroups[groupName] = map[string]interface{}{
                                "ratio": service.GetUserGroupRatio(userGroup, groupName),
                                "desc":  desc,
                        }
                }</span>
        }
        <span class="cov0" title="0">if _, ok := userUsableGroups["auto"]; ok </span><span class="cov0" title="0">{
                usableGroups["auto"] = map[string]interface{}{
                        "ratio": "自动",
                        "desc":  setting.GetUsableGroupDescription("auto"),
                }
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    usableGroups,
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
)

func GetImage(c *gin.Context) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type LinuxdoUser struct {
        Id         int    `json:"id"`
        Username   string `json:"username"`
        Name       string `json:"name"`
        Active     bool   `json:"active"`
        TrustLevel int    `json:"trust_level"`
        Silenced   bool   `json:"silenced"`
}

func LinuxDoBind(c *gin.Context) <span class="cov0" title="0">{
        if !common.LinuxDOOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 Linux DO 登录以及注册",
                })
                return
        }</span>

        <span class="cov0" title="0">code := c.Query("code")
        linuxdoUser, err := getLinuxdoUserInfoByCode(code, c)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">user := model.User{
                LinuxDOId: strconv.Itoa(linuxdoUser.Id),
        }

        if model.IsLinuxDOIdAlreadyTaken(user.LinuxDOId) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该 Linux DO 账户已被绑定",
                })
                return
        }</span>

        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        user.Id = id.(int)

        err = user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">user.LinuxDOId = strconv.Itoa(linuxdoUser.Id)
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "bind",
        })</span>
}

func getLinuxdoUserInfoByCode(code string, c *gin.Context) (*LinuxdoUser, error) <span class="cov0" title="0">{
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("invalid code")
        }</span>

        // Get access token using Basic auth
        <span class="cov0" title="0">tokenEndpoint := common.GetEnvOrDefaultString("LINUX_DO_TOKEN_ENDPOINT", "https://connect.linux.do/oauth2/token")
        credentials := common.LinuxDOClientId + ":" + common.LinuxDOClientSecret
        basicAuth := "Basic " + base64.StdEncoding.EncodeToString([]byte(credentials))

        // Get redirect URI from request
        scheme := "http"
        if c.Request.TLS != nil </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>
        <span class="cov0" title="0">redirectURI := fmt.Sprintf("%s://%s/api/oauth/linuxdo", scheme, c.Request.Host)

        data := url.Values{}
        data.Set("grant_type", "authorization_code")
        data.Set("code", code)
        data.Set("redirect_uri", redirectURI)

        req, err := http.NewRequest("POST", tokenEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", basicAuth)
        req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("Accept", "application/json")

        client := http.Client{Timeout: 5 * time.Second}
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to connect to Linux DO server")
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        var tokenRes struct {
                AccessToken string `json:"access_token"`
                Message     string `json:"message"`
        }
        if err := json.NewDecoder(res.Body).Decode(&amp;tokenRes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if tokenRes.AccessToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access token: %s", tokenRes.Message)
        }</span>

        // Get user info
        <span class="cov0" title="0">userEndpoint := common.GetEnvOrDefaultString("LINUX_DO_USER_ENDPOINT", "https://connect.linux.do/api/user")
        req, err = http.NewRequest("GET", userEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+tokenRes.AccessToken)
        req.Header.Set("Accept", "application/json")

        res2, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get user info from Linux DO")
        }</span>
        <span class="cov0" title="0">defer res2.Body.Close()

        var linuxdoUser LinuxdoUser
        if err := json.NewDecoder(res2.Body).Decode(&amp;linuxdoUser); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if linuxdoUser.Id == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid user info returned")
        }</span>

        <span class="cov0" title="0">return &amp;linuxdoUser, nil</span>
}

func LinuxdoOAuth(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)

        errorCode := c.Query("error")
        if errorCode != "" </span><span class="cov0" title="0">{
                errorDescription := c.Query("error_description")
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": errorDescription,
                })
                return
        }</span>

        <span class="cov0" title="0">state := c.Query("state")
        if state == "" || session.Get("oauth_state") == nil || state != session.Get("oauth_state").(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "message": "state is empty or not same",
                })
                return
        }</span>

        <span class="cov0" title="0">username := session.Get("username")
        if username != nil </span><span class="cov0" title="0">{
                LinuxDoBind(c)
                return
        }</span>

        <span class="cov0" title="0">if !common.LinuxDOOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 Linux DO 登录以及注册",
                })
                return
        }</span>

        <span class="cov0" title="0">code := c.Query("code")
        linuxdoUser, err := getLinuxdoUserInfoByCode(code, c)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">user := model.User{
                LinuxDOId: strconv.Itoa(linuxdoUser.Id),
        }

        // Check if user exists
        if model.IsLinuxDOIdAlreadyTaken(user.LinuxDOId) </span><span class="cov0" title="0">{
                err := user.FillUserByLinuxDOId()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if user.Id == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "用户已注销",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if common.RegisterEnabled </span><span class="cov0" title="0">{
                        if linuxdoUser.TrustLevel &gt;= common.LinuxDOMinimumTrustLevel </span><span class="cov0" title="0">{
                                user.Username = "linuxdo_" + strconv.Itoa(model.GetMaxUserId()+1)
                                user.DisplayName = linuxdoUser.Name
                                user.Role = common.RoleCommonUser
                                user.Status = common.UserStatusEnabled

                                affCode := session.Get("aff")
                                inviterId := 0
                                if affCode != nil </span><span class="cov0" title="0">{
                                        inviterId, _ = model.GetUserIdByAffCode(affCode.(string))
                                }</span>

                                <span class="cov0" title="0">if err := user.Insert(inviterId); err != nil </span><span class="cov0" title="0">{
                                        c.JSON(http.StatusOK, gin.H{
                                                "success": false,
                                                "message": err.Error(),
                                        })
                                        return
                                }</span>
                        } else<span class="cov0" title="0"> {
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": "Linux DO 信任等级未达到管理员设置的最低信任等级",
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员关闭了新用户注册",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "用户已被封禁",
                        "success": false,
                })
                return
        }</span>

        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

func GetAllLogs(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        logType, _ := strconv.Atoi(c.Query("type"))
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        username := c.Query("username")
        tokenName := c.Query("token_name")
        modelName := c.Query("model_name")
        channel, _ := strconv.Atoi(c.Query("channel"))
        group := c.Query("group")
        logs, total, err := model.GetAllLogs(logType, startTimestamp, endTimestamp, modelName, username, tokenName, pageInfo.GetStartIdx(), pageInfo.GetPageSize(), channel, group)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(logs)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func GetUserLogs(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        userId := c.GetInt("id")
        logType, _ := strconv.Atoi(c.Query("type"))
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        tokenName := c.Query("token_name")
        modelName := c.Query("model_name")
        group := c.Query("group")
        logs, total, err := model.GetUserLogs(userId, logType, startTimestamp, endTimestamp, modelName, tokenName, pageInfo.GetStartIdx(), pageInfo.GetPageSize(), group)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(logs)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func SearchAllLogs(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        logs, err := model.SearchAllLogs(keyword)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    logs,
        })
        return</span>
}

func SearchUserLogs(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        userId := c.GetInt("id")
        logs, err := model.SearchUserLogs(userId, keyword)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    logs,
        })
        return</span>
}

func GetLogByKey(c *gin.Context) <span class="cov0" title="0">{
        key := c.Query("key")
        logs, err := model.GetLogByKey(key)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{
                "success": true,
                "message": "",
                "data":    logs,
        })</span>
}

func GetLogsStat(c *gin.Context) <span class="cov0" title="0">{
        logType, _ := strconv.Atoi(c.Query("type"))
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        tokenName := c.Query("token_name")
        username := c.Query("username")
        modelName := c.Query("model_name")
        channel, _ := strconv.Atoi(c.Query("channel"))
        group := c.Query("group")
        stat := model.SumUsedQuota(logType, startTimestamp, endTimestamp, modelName, username, tokenName, channel, group)
        //tokenNum := model.SumUsedToken(logType, startTimestamp, endTimestamp, modelName, username, "")
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "quota": stat.Quota,
                        "rpm":   stat.Rpm,
                        "tpm":   stat.Tpm,
                },
        })
        return
}</span>

func GetLogsSelfStat(c *gin.Context) <span class="cov0" title="0">{
        username := c.GetString("username")
        logType, _ := strconv.Atoi(c.Query("type"))
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        tokenName := c.Query("token_name")
        modelName := c.Query("model_name")
        channel, _ := strconv.Atoi(c.Query("channel"))
        group := c.Query("group")
        quotaNum := model.SumUsedQuota(logType, startTimestamp, endTimestamp, modelName, username, tokenName, channel, group)
        //tokenNum := model.SumUsedToken(logType, startTimestamp, endTimestamp, modelName, username, tokenName)
        c.JSON(200, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "quota": quotaNum.Quota,
                        "rpm":   quotaNum.Rpm,
                        "tpm":   quotaNum.Tpm,
                        //"token": tokenNum,
                },
        })
        return
}</span>

func DeleteHistoryLogs(c *gin.Context) <span class="cov0" title="0">{
        targetTimestamp, _ := strconv.ParseInt(c.Query("target_timestamp"), 10, 64)
        if targetTimestamp == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "target timestamp is required",
                })
                return
        }</span>
        <span class="cov0" title="0">count, err := model.DeleteOldLog(c.Request.Context(), targetTimestamp, 100)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    count,
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controller

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-gonic/gin"
)

func UpdateMidjourneyTaskBulk() <span class="cov0" title="0">{
        //imageModel := "midjourney"
        ctx := context.TODO()
        for </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(15) * time.Second)

                tasks := model.GetAllUnFinishTasks()
                if len(tasks) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">logger.LogInfo(ctx, fmt.Sprintf("检测到未完成的任务数有: %v", len(tasks)))
                taskChannelM := make(map[int][]string)
                taskM := make(map[string]*model.Midjourney)
                nullTaskIds := make([]int, 0)
                for _, task := range tasks </span><span class="cov0" title="0">{
                        if task.MjId == "" </span><span class="cov0" title="0">{
                                // 统计失败的未完成任务
                                nullTaskIds = append(nullTaskIds, task.Id)
                                continue</span>
                        }
                        <span class="cov0" title="0">taskM[task.MjId] = task
                        taskChannelM[task.ChannelId] = append(taskChannelM[task.ChannelId], task.MjId)</span>
                }
                <span class="cov0" title="0">if len(nullTaskIds) &gt; 0 </span><span class="cov0" title="0">{
                        err := model.MjBulkUpdateByTaskIds(nullTaskIds, map[string]any{
                                "status":   "FAILURE",
                                "progress": "100%",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Fix null mj_id task error: %v", err))
                        }</span> else<span class="cov0" title="0"> {
                                logger.LogInfo(ctx, fmt.Sprintf("Fix null mj_id task success: %v", nullTaskIds))
                        }</span>
                }
                <span class="cov0" title="0">if len(taskChannelM) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for channelId, taskIds := range taskChannelM </span><span class="cov0" title="0">{
                        logger.LogInfo(ctx, fmt.Sprintf("渠道 #%d 未完成的任务有: %d", channelId, len(taskIds)))
                        if len(taskIds) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">midjourneyChannel, err := model.CacheGetChannel(channelId)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("CacheGetChannel: %v", err))
                                err := model.MjBulkUpdate(taskIds, map[string]any{
                                        "fail_reason": fmt.Sprintf("获取渠道信息失败，请联系管理员，渠道ID：%d", channelId),
                                        "status":      "FAILURE",
                                        "progress":    "100%",
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.LogInfo(ctx, fmt.Sprintf("UpdateMidjourneyTask error: %v", err))
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">requestUrl := fmt.Sprintf("%s/mj/task/list-by-condition", *midjourneyChannel.BaseURL)

                        body, _ := json.Marshal(map[string]any{
                                "ids": taskIds,
                        })
                        req, err := http.NewRequest("POST", requestUrl, bytes.NewBuffer(body))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Get Task error: %v", err))
                                continue</span>
                        }
                        // 设置超时时间
                        <span class="cov0" title="0">timeout := time.Second * 15
                        ctx, cancel := context.WithTimeout(context.Background(), timeout)
                        // 使用带有超时的 context 创建新的请求
                        req = req.WithContext(ctx)
                        req.Header.Set("Content-Type", "application/json")
                        req.Header.Set("mj-api-secret", midjourneyChannel.Key)
                        resp, err := service.GetHttpClient().Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Get Task Do req error: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Get Task status code: %d", resp.StatusCode))
                                continue</span>
                        }
                        <span class="cov0" title="0">responseBody, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Get Task parse body error: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">var responseItems []dto.MidjourneyDto
                        err = json.Unmarshal(responseBody, &amp;responseItems)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, fmt.Sprintf("Get Task parse body error2: %v, body: %s", err, string(responseBody)))
                                continue</span>
                        }
                        <span class="cov0" title="0">resp.Body.Close()
                        req.Body.Close()
                        cancel()

                        for _, responseItem := range responseItems </span><span class="cov0" title="0">{
                                task := taskM[responseItem.MjId]

                                useTime := (time.Now().UnixNano() / int64(time.Millisecond)) - task.SubmitTime
                                // 如果时间超过一小时，且进度不是100%，则认为任务失败
                                if useTime &gt; 3600000 &amp;&amp; task.Progress != "100%" </span><span class="cov0" title="0">{
                                        responseItem.FailReason = "上游任务超时（超过1小时）"
                                        responseItem.Status = "FAILURE"
                                }</span>
                                <span class="cov0" title="0">if !checkMjTaskNeedUpdate(task, responseItem) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">task.Code = 1
                                task.Progress = responseItem.Progress
                                task.PromptEn = responseItem.PromptEn
                                task.State = responseItem.State
                                task.SubmitTime = responseItem.SubmitTime
                                task.StartTime = responseItem.StartTime
                                task.FinishTime = responseItem.FinishTime
                                task.ImageUrl = responseItem.ImageUrl
                                task.Status = responseItem.Status
                                task.FailReason = responseItem.FailReason
                                if responseItem.Properties != nil </span><span class="cov0" title="0">{
                                        propertiesStr, _ := json.Marshal(responseItem.Properties)
                                        task.Properties = string(propertiesStr)
                                }</span>
                                <span class="cov0" title="0">if responseItem.Buttons != nil </span><span class="cov0" title="0">{
                                        buttonStr, _ := json.Marshal(responseItem.Buttons)
                                        task.Buttons = string(buttonStr)
                                }</span>
                                // 映射 VideoUrl
                                <span class="cov0" title="0">task.VideoUrl = responseItem.VideoUrl

                                // 映射 VideoUrls - 将数组序列化为 JSON 字符串
                                if responseItem.VideoUrls != nil &amp;&amp; len(responseItem.VideoUrls) &gt; 0 </span><span class="cov0" title="0">{
                                        videoUrlsStr, err := json.Marshal(responseItem.VideoUrls)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.LogError(ctx, fmt.Sprintf("序列化 VideoUrls 失败: %v", err))
                                                task.VideoUrls = "[]" // 失败时设置为空数组
                                        }</span> else<span class="cov0" title="0"> {
                                                task.VideoUrls = string(videoUrlsStr)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        task.VideoUrls = "" // 空值时清空字段
                                }</span>

                                <span class="cov0" title="0">shouldReturnQuota := false
                                if (task.Progress != "100%" &amp;&amp; responseItem.FailReason != "") || (task.Progress == "100%" &amp;&amp; task.Status == "FAILURE") </span><span class="cov0" title="0">{
                                        logger.LogInfo(ctx, task.MjId+" 构建失败，"+task.FailReason)
                                        task.Progress = "100%"
                                        if task.Quota != 0 </span><span class="cov0" title="0">{
                                                shouldReturnQuota = true
                                        }</span>
                                }
                                <span class="cov0" title="0">err = task.Update()
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.LogError(ctx, "UpdateMidjourneyTask task error: "+err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        if shouldReturnQuota </span><span class="cov0" title="0">{
                                                err = model.IncreaseUserQuota(task.UserId, task.Quota, false)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        logger.LogError(ctx, "fail to increase user quota: "+err.Error())
                                                }</span>
                                                <span class="cov0" title="0">logContent := fmt.Sprintf("构图失败 %s，补偿 %s", task.MjId, logger.LogQuota(task.Quota))
                                                model.RecordLog(task.UserId, model.LogTypeSystem, logContent)</span>
                                        }
                                }
                        }
                }
        }
}

func checkMjTaskNeedUpdate(oldTask *model.Midjourney, newTask dto.MidjourneyDto) bool <span class="cov0" title="0">{
        if oldTask.Code != 1 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.Progress != newTask.Progress </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.PromptEn != newTask.PromptEn </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.State != newTask.State </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.SubmitTime != newTask.SubmitTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.StartTime != newTask.StartTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FinishTime != newTask.FinishTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.ImageUrl != newTask.ImageUrl </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.Status != newTask.Status </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FailReason != newTask.FailReason </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FinishTime != newTask.FinishTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.Progress != "100%" &amp;&amp; newTask.FailReason != "" </span><span class="cov0" title="0">{
                return true
        }</span>
        // 检查 VideoUrl 是否需要更新
        <span class="cov0" title="0">if oldTask.VideoUrl != newTask.VideoUrl </span><span class="cov0" title="0">{
                return true
        }</span>
        // 检查 VideoUrls 是否需要更新
        <span class="cov0" title="0">if newTask.VideoUrls != nil &amp;&amp; len(newTask.VideoUrls) &gt; 0 </span><span class="cov0" title="0">{
                newVideoUrlsStr, _ := json.Marshal(newTask.VideoUrls)
                if oldTask.VideoUrls != string(newVideoUrlsStr) </span><span class="cov0" title="0">{
                        return true
                }</span>
        } else<span class="cov0" title="0"> if oldTask.VideoUrls != "" </span><span class="cov0" title="0">{
                // 如果新数据没有 VideoUrls 但旧数据有，需要更新（清空）
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func GetAllMidjourney(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)

        // 解析其他查询参数
        queryParams := model.TaskQueryParams{
                ChannelID:      c.Query("channel_id"),
                MjID:           c.Query("mj_id"),
                StartTimestamp: c.Query("start_timestamp"),
                EndTimestamp:   c.Query("end_timestamp"),
        }

        items := model.GetAllTasks(pageInfo.GetStartIdx(), pageInfo.GetPageSize(), queryParams)
        total := model.CountAllTasks(queryParams)

        if setting.MjForwardUrlEnabled </span><span class="cov0" title="0">{
                for i, midjourney := range items </span><span class="cov0" title="0">{
                        midjourney.ImageUrl = system_setting.ServerAddress + "/mj/image/" + midjourney.MjId
                        items[i] = midjourney
                }</span>
        }
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(items)
        common.ApiSuccess(c, pageInfo)</span>
}

func GetUserMidjourney(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)

        userId := c.GetInt("id")

        queryParams := model.TaskQueryParams{
                MjID:           c.Query("mj_id"),
                StartTimestamp: c.Query("start_timestamp"),
                EndTimestamp:   c.Query("end_timestamp"),
        }

        items := model.GetAllUserTask(userId, pageInfo.GetStartIdx(), pageInfo.GetPageSize(), queryParams)
        total := model.CountAllUserTask(userId, queryParams)

        if setting.MjForwardUrlEnabled </span><span class="cov0" title="0">{
                for i, midjourney := range items </span><span class="cov0" title="0">{
                        midjourney.ImageUrl = system_setting.ServerAddress + "/mj/image/" + midjourney.MjId
                        items[i] = midjourney
                }</span>
        }
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(items)
        common.ApiSuccess(c, pageInfo)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package controller

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/middleware"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/console_setting"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-gonic/gin"
)

func TestStatus(c *gin.Context) <span class="cov0" title="0">{
        err := model.PingDB()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "success": false,
                        "message": "数据库连接失败",
                })
                return
        }</span>
        // 获取HTTP统计信息
        <span class="cov0" title="0">httpStats := middleware.GetStats()
        c.JSON(http.StatusOK, gin.H{
                "success":    true,
                "message":    "Server is running",
                "http_stats": httpStats,
        })
        return</span>
}

func GetStatus(c *gin.Context) <span class="cov0" title="0">{

        cs := console_setting.GetConsoleSetting()
        common.OptionMapRWMutex.RLock()
        defer common.OptionMapRWMutex.RUnlock()

        passkeySetting := system_setting.GetPasskeySettings()
        legalSetting := system_setting.GetLegalSettings()

        data := gin.H{
                "version":                     common.Version,
                "start_time":                  common.StartTime,
                "email_verification":          common.EmailVerificationEnabled,
                "github_oauth":                common.GitHubOAuthEnabled,
                "github_client_id":            common.GitHubClientId,
                "discord_oauth":               system_setting.GetDiscordSettings().Enabled,
                "discord_client_id":           system_setting.GetDiscordSettings().ClientId,
                "linuxdo_oauth":               common.LinuxDOOAuthEnabled,
                "linuxdo_client_id":           common.LinuxDOClientId,
                "linuxdo_minimum_trust_level": common.LinuxDOMinimumTrustLevel,
                "telegram_oauth":              common.TelegramOAuthEnabled,
                "telegram_bot_name":           common.TelegramBotName,
                "system_name":                 common.SystemName,
                "logo":                        common.Logo,
                "footer_html":                 common.Footer,
                "wechat_qrcode":               common.WeChatAccountQRCodeImageURL,
                "wechat_login":                common.WeChatAuthEnabled,
                "server_address":              system_setting.ServerAddress,
                "turnstile_check":             common.TurnstileCheckEnabled,
                "turnstile_site_key":          common.TurnstileSiteKey,
                "top_up_link":                 common.TopUpLink,
                "docs_link":                   operation_setting.GetGeneralSetting().DocsLink,
                "quota_per_unit":              common.QuotaPerUnit,
                // 兼容旧前端：保留 display_in_currency，同时提供新的 quota_display_type
                "display_in_currency":           operation_setting.IsCurrencyDisplay(),
                "quota_display_type":            operation_setting.GetQuotaDisplayType(),
                "custom_currency_symbol":        operation_setting.GetGeneralSetting().CustomCurrencySymbol,
                "custom_currency_exchange_rate": operation_setting.GetGeneralSetting().CustomCurrencyExchangeRate,
                "enable_batch_update":           common.BatchUpdateEnabled,
                "enable_drawing":                common.DrawingEnabled,
                "enable_task":                   common.TaskEnabled,
                "enable_data_export":            common.DataExportEnabled,
                "data_export_default_time":      common.DataExportDefaultTime,
                "default_collapse_sidebar":      common.DefaultCollapseSidebar,
                "mj_notify_enabled":             setting.MjNotifyEnabled,
                "chats":                         setting.Chats,
                "demo_site_enabled":             operation_setting.DemoSiteEnabled,
                "self_use_mode_enabled":         operation_setting.SelfUseModeEnabled,
                "default_use_auto_group":        setting.DefaultUseAutoGroup,

                "usd_exchange_rate": operation_setting.USDExchangeRate,
                "price":             operation_setting.Price,
                "stripe_unit_price": setting.StripeUnitPrice,

                // 面板启用开关
                "api_info_enabled":      cs.ApiInfoEnabled,
                "uptime_kuma_enabled":   cs.UptimeKumaEnabled,
                "announcements_enabled": cs.AnnouncementsEnabled,
                "faq_enabled":           cs.FAQEnabled,

                // 模块管理配置
                "HeaderNavModules":    common.OptionMap["HeaderNavModules"],
                "SidebarModulesAdmin": common.OptionMap["SidebarModulesAdmin"],

                "oidc_enabled":                system_setting.GetOIDCSettings().Enabled,
                "oidc_client_id":              system_setting.GetOIDCSettings().ClientId,
                "oidc_authorization_endpoint": system_setting.GetOIDCSettings().AuthorizationEndpoint,
                "passkey_login":               passkeySetting.Enabled,
                "passkey_display_name":        passkeySetting.RPDisplayName,
                "passkey_rp_id":               passkeySetting.RPID,
                "passkey_origins":             passkeySetting.Origins,
                "passkey_allow_insecure":      passkeySetting.AllowInsecureOrigin,
                "passkey_user_verification":   passkeySetting.UserVerification,
                "passkey_attachment":          passkeySetting.AttachmentPreference,
                "setup":                       constant.Setup,
                "user_agreement_enabled":      legalSetting.UserAgreement != "",
                "privacy_policy_enabled":      legalSetting.PrivacyPolicy != "",
        }

        // 根据启用状态注入可选内容
        if cs.ApiInfoEnabled </span><span class="cov0" title="0">{
                data["api_info"] = console_setting.GetApiInfo()
        }</span>
        <span class="cov0" title="0">if cs.AnnouncementsEnabled </span><span class="cov0" title="0">{
                data["announcements"] = console_setting.GetAnnouncements()
        }</span>
        <span class="cov0" title="0">if cs.FAQEnabled </span><span class="cov0" title="0">{
                data["faq"] = console_setting.GetFAQ()
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    data,
        })
        return</span>
}

func GetNotice(c *gin.Context) <span class="cov0" title="0">{
        common.OptionMapRWMutex.RLock()
        defer common.OptionMapRWMutex.RUnlock()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    common.OptionMap["Notice"],
        })
        return
}</span>

func GetAbout(c *gin.Context) <span class="cov0" title="0">{
        common.OptionMapRWMutex.RLock()
        defer common.OptionMapRWMutex.RUnlock()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    common.OptionMap["About"],
        })
        return
}</span>

func GetUserAgreement(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    system_setting.GetLegalSettings().UserAgreement,
        })
        return
}</span>

func GetPrivacyPolicy(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    system_setting.GetLegalSettings().PrivacyPolicy,
        })
        return
}</span>

func GetMidjourney(c *gin.Context) <span class="cov0" title="0">{
        common.OptionMapRWMutex.RLock()
        defer common.OptionMapRWMutex.RUnlock()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    common.OptionMap["Midjourney"],
        })
        return
}</span>

func GetHomePageContent(c *gin.Context) <span class="cov0" title="0">{
        common.OptionMapRWMutex.RLock()
        defer common.OptionMapRWMutex.RUnlock()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    common.OptionMap["HomePageContent"],
        })
        return
}</span>

func SendEmailVerification(c *gin.Context) <span class="cov0" title="0">{
        email := c.Query("email")
        if err := common.Validate.Var(email, "required,email"); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">parts := strings.Split(email, "@")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的邮箱地址",
                })
                return
        }</span>
        <span class="cov0" title="0">localPart := parts[0]
        domainPart := parts[1]
        if common.EmailDomainRestrictionEnabled </span><span class="cov0" title="0">{
                allowed := false
                for _, domain := range common.EmailDomainWhitelist </span><span class="cov0" title="0">{
                        if domainPart == domain </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "The administrator has enabled the email domain name whitelist, and your email address is not allowed due to special symbols or it's not in the whitelist.",
                        })
                        return
                }</span>
        }
        <span class="cov0" title="0">if common.EmailAliasRestrictionEnabled </span><span class="cov0" title="0">{
                containsSpecialSymbols := strings.Contains(localPart, "+") || strings.Contains(localPart, ".")
                if containsSpecialSymbols </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员已启用邮箱地址别名限制，您的邮箱地址由于包含特殊符号而被拒绝。",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if model.IsEmailAlreadyTaken(email) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "邮箱地址已被占用",
                })
                return
        }</span>
        <span class="cov0" title="0">code := common.GenerateVerificationCode(6)
        common.RegisterVerificationCodeWithKey(email, code, common.EmailVerificationPurpose)
        subject := fmt.Sprintf("%s邮箱验证邮件", common.SystemName)
        content := fmt.Sprintf("&lt;p&gt;您好，你正在进行%s邮箱验证。&lt;/p&gt;"+
                "&lt;p&gt;您的验证码为: &lt;strong&gt;%s&lt;/strong&gt;&lt;/p&gt;"+
                "&lt;p&gt;验证码 %d 分钟内有效，如果不是本人操作，请忽略。&lt;/p&gt;", common.SystemName, code, common.VerificationValidMinutes)
        err := common.SendEmail(subject, email, content)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func SendPasswordResetEmail(c *gin.Context) <span class="cov0" title="0">{
        email := c.Query("email")
        if err := common.Validate.Var(email, "required,email"); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">if !model.IsEmailAlreadyTaken(email) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该邮箱地址未注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := common.GenerateVerificationCode(0)
        common.RegisterVerificationCodeWithKey(email, code, common.PasswordResetPurpose)
        link := fmt.Sprintf("%s/user/reset?email=%s&amp;token=%s", system_setting.ServerAddress, email, code)
        subject := fmt.Sprintf("%s密码重置", common.SystemName)
        content := fmt.Sprintf("&lt;p&gt;您好，你正在进行%s密码重置。&lt;/p&gt;"+
                "&lt;p&gt;点击 &lt;a href='%s'&gt;此处&lt;/a&gt; 进行密码重置。&lt;/p&gt;"+
                "&lt;p&gt;如果链接无法点击，请尝试点击下面的链接或将其复制到浏览器中打开：&lt;br&gt; %s &lt;/p&gt;"+
                "&lt;p&gt;重置链接 %d 分钟内有效，如果不是本人操作，请忽略。&lt;/p&gt;", common.SystemName, link, link, common.VerificationValidMinutes)
        err := common.SendEmail(subject, email, content)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

type PasswordResetRequest struct {
        Email string `json:"email"`
        Token string `json:"token"`
}

func ResetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req PasswordResetRequest
        err := json.NewDecoder(c.Request.Body).Decode(&amp;req)
        if req.Email == "" || req.Token == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">if !common.VerifyCodeWithKey(req.Email, req.Token, common.PasswordResetPurpose) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "重置链接非法或已过期",
                })
                return
        }</span>
        <span class="cov0" title="0">password := common.GenerateVerificationCode(12)
        err = model.ResetUserPasswordByEmail(req.Email, password)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.DeleteKey(req.Email, common.PasswordResetPurpose)
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    password,
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controller

import (
        "net/http"

        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// GetMissingModels returns the list of model names that are referenced by channels
// but do not have corresponding records in the models meta table.
// This helps administrators quickly discover models that need configuration.
func GetMissingModels(c *gin.Context) <span class="cov0" title="0">{
        missing, err := model.GetMissingModels()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    missing,
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"
        "github.com/QuantumNous/new-api/relay/channel/ai360"
        "github.com/QuantumNous/new-api/relay/channel/lingyiwanwu"
        "github.com/QuantumNous/new-api/relay/channel/minimax"
        "github.com/QuantumNous/new-api/relay/channel/moonshot"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/gin-gonic/gin"
        "github.com/samber/lo"
)

// https://platform.openai.com/docs/api-reference/models/list

var openAIModels []dto.OpenAIModels
var openAIModelsMap map[string]dto.OpenAIModels
var channelId2Models map[int][]string

func init() <span class="cov8" title="1">{
        // https://platform.openai.com/docs/models/model-endpoint-compatibility
        for i := 0; i &lt; constant.APITypeDummy; i++ </span><span class="cov8" title="1">{
                if i == constant.APITypeAIProxyLibrary </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">adaptor := relay.GetAdaptor(i)
                channelName := adaptor.GetChannelName()
                modelNames := adaptor.GetModelList()
                for _, modelName := range modelNames </span><span class="cov8" title="1">{
                        openAIModels = append(openAIModels, dto.OpenAIModels{
                                Id:      modelName,
                                Object:  "model",
                                Created: 1626777600,
                                OwnedBy: channelName,
                        })
                }</span>
        }
        <span class="cov8" title="1">for _, modelName := range ai360.ModelList </span><span class="cov8" title="1">{
                openAIModels = append(openAIModels, dto.OpenAIModels{
                        Id:      modelName,
                        Object:  "model",
                        Created: 1626777600,
                        OwnedBy: ai360.ChannelName,
                })
        }</span>
        <span class="cov8" title="1">for _, modelName := range moonshot.ModelList </span><span class="cov8" title="1">{
                openAIModels = append(openAIModels, dto.OpenAIModels{
                        Id:      modelName,
                        Object:  "model",
                        Created: 1626777600,
                        OwnedBy: moonshot.ChannelName,
                })
        }</span>
        <span class="cov8" title="1">for _, modelName := range lingyiwanwu.ModelList </span><span class="cov8" title="1">{
                openAIModels = append(openAIModels, dto.OpenAIModels{
                        Id:      modelName,
                        Object:  "model",
                        Created: 1626777600,
                        OwnedBy: lingyiwanwu.ChannelName,
                })
        }</span>
        <span class="cov8" title="1">for _, modelName := range minimax.ModelList </span><span class="cov8" title="1">{
                openAIModels = append(openAIModels, dto.OpenAIModels{
                        Id:      modelName,
                        Object:  "model",
                        Created: 1626777600,
                        OwnedBy: minimax.ChannelName,
                })
        }</span>
        <span class="cov8" title="1">for modelName, _ := range constant.MidjourneyModel2Action </span><span class="cov8" title="1">{
                openAIModels = append(openAIModels, dto.OpenAIModels{
                        Id:      modelName,
                        Object:  "model",
                        Created: 1626777600,
                        OwnedBy: "midjourney",
                })
        }</span>
        <span class="cov8" title="1">openAIModelsMap = make(map[string]dto.OpenAIModels)
        for _, aiModel := range openAIModels </span><span class="cov8" title="1">{
                openAIModelsMap[aiModel.Id] = aiModel
        }</span>
        <span class="cov8" title="1">channelId2Models = make(map[int][]string)
        for i := 1; i &lt;= constant.ChannelTypeDummy; i++ </span><span class="cov8" title="1">{
                apiType, success := common.ChannelType2APIType(i)
                if !success || apiType == constant.APITypeAIProxyLibrary </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">meta := &amp;relaycommon.RelayInfo{ChannelMeta: &amp;relaycommon.ChannelMeta{
                        ChannelType: i,
                }}
                adaptor := relay.GetAdaptor(apiType)
                adaptor.Init(meta)
                channelId2Models[i] = adaptor.GetModelList()</span>
        }
        <span class="cov8" title="1">openAIModels = lo.UniqBy(openAIModels, func(m dto.OpenAIModels) string </span><span class="cov8" title="1">{
                return m.Id
        }</span>)
}

func ListModels(c *gin.Context, modelType int) <span class="cov0" title="0">{
        userOpenAiModels := make([]dto.OpenAIModels, 0)

        acceptUnsetRatioModel := operation_setting.SelfUseModeEnabled
        if !acceptUnsetRatioModel </span><span class="cov0" title="0">{
                userId := c.GetInt("id")
                if userId &gt; 0 </span><span class="cov0" title="0">{
                        userSettings, _ := model.GetUserSetting(userId, false)
                        if userSettings.AcceptUnsetRatioModel </span><span class="cov0" title="0">{
                                acceptUnsetRatioModel = true
                        }</span>
                }
        }

        <span class="cov0" title="0">modelLimitEnable := common.GetContextKeyBool(c, constant.ContextKeyTokenModelLimitEnabled)
        if modelLimitEnable </span><span class="cov0" title="0">{
                s, ok := common.GetContextKey(c, constant.ContextKeyTokenModelLimit)
                var tokenModelLimit map[string]bool
                if ok </span><span class="cov0" title="0">{
                        tokenModelLimit = s.(map[string]bool)
                }</span> else<span class="cov0" title="0"> {
                        tokenModelLimit = map[string]bool{}
                }</span>
                <span class="cov0" title="0">for allowModel, _ := range tokenModelLimit </span><span class="cov0" title="0">{
                        if !acceptUnsetRatioModel </span><span class="cov0" title="0">{
                                _, _, exist := ratio_setting.GetModelRatioOrPrice(allowModel)
                                if !exist </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if oaiModel, ok := openAIModelsMap[allowModel]; ok </span><span class="cov0" title="0">{
                                oaiModel.SupportedEndpointTypes = model.GetModelSupportEndpointTypes(allowModel)
                                userOpenAiModels = append(userOpenAiModels, oaiModel)
                        }</span> else<span class="cov0" title="0"> {
                                userOpenAiModels = append(userOpenAiModels, dto.OpenAIModels{
                                        Id:                     allowModel,
                                        Object:                 "model",
                                        Created:                1626777600,
                                        OwnedBy:                "custom",
                                        SupportedEndpointTypes: model.GetModelSupportEndpointTypes(allowModel),
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                userId := c.GetInt("id")
                userGroup, err := model.GetUserGroup(userId, false)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "get user group failed",
                        })
                        return
                }</span>
                <span class="cov0" title="0">group := userGroup
                tokenGroup := common.GetContextKeyString(c, constant.ContextKeyTokenGroup)
                if tokenGroup != "" </span><span class="cov0" title="0">{
                        group = tokenGroup
                }</span>
                <span class="cov0" title="0">var models []string
                if tokenGroup == "auto" </span><span class="cov0" title="0">{
                        for _, autoGroup := range service.GetUserAutoGroup(userGroup) </span><span class="cov0" title="0">{
                                groupModels := model.GetGroupEnabledModels(autoGroup)
                                for _, g := range groupModels </span><span class="cov0" title="0">{
                                        if !common.StringsContains(models, g) </span><span class="cov0" title="0">{
                                                models = append(models, g)
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        models = model.GetGroupEnabledModels(group)
                }</span>
                <span class="cov0" title="0">for _, modelName := range models </span><span class="cov0" title="0">{
                        if !acceptUnsetRatioModel </span><span class="cov0" title="0">{
                                _, _, exist := ratio_setting.GetModelRatioOrPrice(modelName)
                                if !exist </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if oaiModel, ok := openAIModelsMap[modelName]; ok </span><span class="cov0" title="0">{
                                oaiModel.SupportedEndpointTypes = model.GetModelSupportEndpointTypes(modelName)
                                userOpenAiModels = append(userOpenAiModels, oaiModel)
                        }</span> else<span class="cov0" title="0"> {
                                userOpenAiModels = append(userOpenAiModels, dto.OpenAIModels{
                                        Id:                     modelName,
                                        Object:                 "model",
                                        Created:                1626777600,
                                        OwnedBy:                "custom",
                                        SupportedEndpointTypes: model.GetModelSupportEndpointTypes(modelName),
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">switch modelType </span>{
        case constant.ChannelTypeAnthropic:<span class="cov0" title="0">
                useranthropicModels := make([]dto.AnthropicModel, len(userOpenAiModels))
                for i, model := range userOpenAiModels </span><span class="cov0" title="0">{
                        useranthropicModels[i] = dto.AnthropicModel{
                                ID:          model.Id,
                                CreatedAt:   time.Unix(int64(model.Created), 0).UTC().Format(time.RFC3339),
                                DisplayName: model.Id,
                                Type:        "model",
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(200, gin.H{
                        "data":     useranthropicModels,
                        "first_id": useranthropicModels[0].ID,
                        "has_more": false,
                        "last_id":  useranthropicModels[len(useranthropicModels)-1].ID,
                })</span>
        case constant.ChannelTypeGemini:<span class="cov0" title="0">
                userGeminiModels := make([]dto.GeminiModel, len(userOpenAiModels))
                for i, model := range userOpenAiModels </span><span class="cov0" title="0">{
                        userGeminiModels[i] = dto.GeminiModel{
                                Name:        model.Id,
                                DisplayName: model.Id,
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(200, gin.H{
                        "models":        userGeminiModels,
                        "nextPageToken": nil,
                })</span>
        default:<span class="cov0" title="0">
                c.JSON(200, gin.H{
                        "success": true,
                        "data":    userOpenAiModels,
                        "object":  "list",
                })</span>
        }
}

func ChannelListModels(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{
                "success": true,
                "data":    openAIModels,
        })
}</span>

func DashboardListModels(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{
                "success": true,
                "data":    channelId2Models,
        })
}</span>

func EnabledListModels(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{
                "success": true,
                "data":    model.GetEnabledModels(),
        })
}</span>

func RetrieveModel(c *gin.Context, modelType int) <span class="cov0" title="0">{
        modelId := c.Param("model")
        if aiModel, ok := openAIModelsMap[modelId]; ok </span><span class="cov0" title="0">{
                switch modelType </span>{
                case constant.ChannelTypeAnthropic:<span class="cov0" title="0">
                        c.JSON(200, dto.AnthropicModel{
                                ID:          aiModel.Id,
                                CreatedAt:   time.Unix(int64(aiModel.Created), 0).UTC().Format(time.RFC3339),
                                DisplayName: aiModel.Id,
                                Type:        "model",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(200, aiModel)</span>
                }
        } else<span class="cov0" title="0"> {
                openAIError := dto.OpenAIError{
                        Message: fmt.Sprintf("The model '%s' does not exist", modelId),
                        Type:    "invalid_request_error",
                        Param:   "model",
                        Code:    "model_not_found",
                }
                c.JSON(200, gin.H{
                        "error": openAIError,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package controller

import (
        "encoding/json"
        "sort"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// GetAllModelsMeta 获取模型列表（分页）
func GetAllModelsMeta(c *gin.Context) <span class="cov0" title="0">{

        pageInfo := common.GetPageQuery(c)
        modelsMeta, err := model.GetAllModels(pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        // 批量填充附加字段，提升列表接口性能
        <span class="cov0" title="0">enrichModels(modelsMeta)
        var total int64
        model.DB.Model(&amp;model.Model{}).Count(&amp;total)

        // 统计供应商计数（全部数据，不受分页影响）
        vendorCounts, _ := model.GetVendorModelCounts()

        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(modelsMeta)
        common.ApiSuccess(c, gin.H{
                "items":         modelsMeta,
                "total":         total,
                "page":          pageInfo.GetPage(),
                "page_size":     pageInfo.GetPageSize(),
                "vendor_counts": vendorCounts,
        })</span>
}

// SearchModelsMeta 搜索模型列表
func SearchModelsMeta(c *gin.Context) <span class="cov0" title="0">{

        keyword := c.Query("keyword")
        vendor := c.Query("vendor")
        pageInfo := common.GetPageQuery(c)

        modelsMeta, total, err := model.SearchModels(keyword, vendor, pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        // 批量填充附加字段，提升列表接口性能
        <span class="cov0" title="0">enrichModels(modelsMeta)
        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(modelsMeta)
        common.ApiSuccess(c, pageInfo)</span>
}

// GetModelMeta 根据 ID 获取单条模型信息
func GetModelMeta(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">var m model.Model
        if err := model.DB.First(&amp;m, id).Error; err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">enrichModels([]*model.Model{&amp;m})
        common.ApiSuccess(c, &amp;m)</span>
}

// CreateModelMeta 新建模型
func CreateModelMeta(c *gin.Context) <span class="cov0" title="0">{
        var m model.Model
        if err := c.ShouldBindJSON(&amp;m); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if m.ModelName == "" </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "模型名称不能为空")
                return
        }</span>
        // 名称冲突检查
        <span class="cov0" title="0">if dup, err := model.IsModelNameDuplicated(0, m.ModelName); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "模型名称已存在")
                return
        }</span>

        <span class="cov0" title="0">if err := m.Insert(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.RefreshPricing()
        common.ApiSuccess(c, &amp;m)</span>
}

// UpdateModelMeta 更新模型
func UpdateModelMeta(c *gin.Context) <span class="cov0" title="0">{
        statusOnly := c.Query("status_only") == "true"

        var m model.Model
        if err := c.ShouldBindJSON(&amp;m); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if m.Id == 0 </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "缺少模型 ID")
                return
        }</span>

        <span class="cov0" title="0">if statusOnly </span><span class="cov0" title="0">{
                // 只更新状态，防止误清空其他字段
                if err := model.DB.Model(&amp;model.Model{}).Where("id = ?", m.Id).Update("status", m.Status).Error; err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // 名称冲突检查
                if dup, err := model.IsModelNameDuplicated(m.Id, m.ModelName); err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                        common.ApiErrorMsg(c, "模型名称已存在")
                        return
                }</span>

                <span class="cov0" title="0">if err := m.Update(); err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>
        }
        <span class="cov0" title="0">model.RefreshPricing()
        common.ApiSuccess(c, &amp;m)</span>
}

// DeleteModelMeta 删除模型
func DeleteModelMeta(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if err := model.DB.Delete(&amp;model.Model{}, id).Error; err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">model.RefreshPricing()
        common.ApiSuccess(c, nil)</span>
}

// enrichModels 批量填充附加信息：端点、渠道、分组、计费类型，避免 N+1 查询
func enrichModels(models []*model.Model) <span class="cov0" title="0">{
        if len(models) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 1) 拆分精确与规则匹配
        <span class="cov0" title="0">exactNames := make([]string, 0)
        exactIdx := make(map[string][]int) // modelName -&gt; indices in models
        ruleIndices := make([]int, 0)
        for i, m := range models </span><span class="cov0" title="0">{
                if m == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if m.NameRule == model.NameRuleExact </span><span class="cov0" title="0">{
                        exactNames = append(exactNames, m.ModelName)
                        exactIdx[m.ModelName] = append(exactIdx[m.ModelName], i)
                }</span> else<span class="cov0" title="0"> {
                        ruleIndices = append(ruleIndices, i)
                }</span>
        }

        // 2) 批量查询精确模型的绑定渠道
        <span class="cov0" title="0">channelsByModel, _ := model.GetBoundChannelsByModelsMap(exactNames)

        // 3) 精确模型：端点从缓存、渠道批量映射、分组/计费类型从缓存
        for name, indices := range exactIdx </span><span class="cov0" title="0">{
                chs := channelsByModel[name]
                for _, idx := range indices </span><span class="cov0" title="0">{
                        mm := models[idx]
                        if mm.Endpoints == "" </span><span class="cov0" title="0">{
                                eps := model.GetModelSupportEndpointTypes(mm.ModelName)
                                if b, err := json.Marshal(eps); err == nil </span><span class="cov0" title="0">{
                                        mm.Endpoints = string(b)
                                }</span>
                        }
                        <span class="cov0" title="0">mm.BoundChannels = chs
                        mm.EnableGroups = model.GetModelEnableGroups(mm.ModelName)
                        mm.QuotaTypes = model.GetModelQuotaTypes(mm.ModelName)</span>
                }
        }

        <span class="cov0" title="0">if len(ruleIndices) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 4) 一次性读取定价缓存，内存匹配所有规则模型
        <span class="cov0" title="0">pricings := model.GetPricing()

        // 为全部规则模型收集匹配名集合、端点并集、分组并集、配额集合
        matchedNamesByIdx := make(map[int][]string)
        endpointSetByIdx := make(map[int]map[constant.EndpointType]struct{})
        groupSetByIdx := make(map[int]map[string]struct{})
        quotaSetByIdx := make(map[int]map[int]struct{})

        for _, p := range pricings </span><span class="cov0" title="0">{
                for _, idx := range ruleIndices </span><span class="cov0" title="0">{
                        mm := models[idx]
                        var matched bool
                        switch mm.NameRule </span>{
                        case model.NameRulePrefix:<span class="cov0" title="0">
                                matched = strings.HasPrefix(p.ModelName, mm.ModelName)</span>
                        case model.NameRuleSuffix:<span class="cov0" title="0">
                                matched = strings.HasSuffix(p.ModelName, mm.ModelName)</span>
                        case model.NameRuleContains:<span class="cov0" title="0">
                                matched = strings.Contains(p.ModelName, mm.ModelName)</span>
                        }
                        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">matchedNamesByIdx[idx] = append(matchedNamesByIdx[idx], p.ModelName)

                        es := endpointSetByIdx[idx]
                        if es == nil </span><span class="cov0" title="0">{
                                es = make(map[constant.EndpointType]struct{})
                                endpointSetByIdx[idx] = es
                        }</span>
                        <span class="cov0" title="0">for _, et := range p.SupportedEndpointTypes </span><span class="cov0" title="0">{
                                es[et] = struct{}{}
                        }</span>

                        <span class="cov0" title="0">gs := groupSetByIdx[idx]
                        if gs == nil </span><span class="cov0" title="0">{
                                gs = make(map[string]struct{})
                                groupSetByIdx[idx] = gs
                        }</span>
                        <span class="cov0" title="0">for _, g := range p.EnableGroup </span><span class="cov0" title="0">{
                                gs[g] = struct{}{}
                        }</span>

                        <span class="cov0" title="0">qs := quotaSetByIdx[idx]
                        if qs == nil </span><span class="cov0" title="0">{
                                qs = make(map[int]struct{})
                                quotaSetByIdx[idx] = qs
                        }</span>
                        <span class="cov0" title="0">qs[p.QuotaType] = struct{}{}</span>
                }
        }

        // 5) 汇总所有匹配到的模型名称，批量查询一次渠道
        <span class="cov0" title="0">allMatchedSet := make(map[string]struct{})
        for _, names := range matchedNamesByIdx </span><span class="cov0" title="0">{
                for _, n := range names </span><span class="cov0" title="0">{
                        allMatchedSet[n] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">allMatched := make([]string, 0, len(allMatchedSet))
        for n := range allMatchedSet </span><span class="cov0" title="0">{
                allMatched = append(allMatched, n)
        }</span>
        <span class="cov0" title="0">matchedChannelsByModel, _ := model.GetBoundChannelsByModelsMap(allMatched)

        // 6) 回填每个规则模型的并集信息
        for _, idx := range ruleIndices </span><span class="cov0" title="0">{
                mm := models[idx]

                // 端点并集 -&gt; 序列化
                if es, ok := endpointSetByIdx[idx]; ok &amp;&amp; mm.Endpoints == "" </span><span class="cov0" title="0">{
                        eps := make([]constant.EndpointType, 0, len(es))
                        for et := range es </span><span class="cov0" title="0">{
                                eps = append(eps, et)
                        }</span>
                        <span class="cov0" title="0">if b, err := json.Marshal(eps); err == nil </span><span class="cov0" title="0">{
                                mm.Endpoints = string(b)
                        }</span>
                }

                // 分组并集
                <span class="cov0" title="0">if gs, ok := groupSetByIdx[idx]; ok </span><span class="cov0" title="0">{
                        groups := make([]string, 0, len(gs))
                        for g := range gs </span><span class="cov0" title="0">{
                                groups = append(groups, g)
                        }</span>
                        <span class="cov0" title="0">mm.EnableGroups = groups</span>
                }

                // 配额类型集合（保持去重并排序）
                <span class="cov0" title="0">if qs, ok := quotaSetByIdx[idx]; ok </span><span class="cov0" title="0">{
                        arr := make([]int, 0, len(qs))
                        for k := range qs </span><span class="cov0" title="0">{
                                arr = append(arr, k)
                        }</span>
                        <span class="cov0" title="0">sort.Ints(arr)
                        mm.QuotaTypes = arr</span>
                }

                // 渠道并集
                <span class="cov0" title="0">names := matchedNamesByIdx[idx]
                channelSet := make(map[string]model.BoundChannel)
                for _, n := range names </span><span class="cov0" title="0">{
                        for _, ch := range matchedChannelsByModel[n] </span><span class="cov0" title="0">{
                                key := ch.Name + "_" + strconv.Itoa(ch.Type)
                                channelSet[key] = ch
                        }</span>
                }
                <span class="cov0" title="0">if len(channelSet) &gt; 0 </span><span class="cov0" title="0">{
                        chs := make([]model.BoundChannel, 0, len(channelSet))
                        for _, ch := range channelSet </span><span class="cov0" title="0">{
                                chs = append(chs, ch)
                        }</span>
                        <span class="cov0" title="0">mm.BoundChannels = chs</span>
                }

                // 匹配信息
                <span class="cov0" title="0">mm.MatchedModels = names
                mm.MatchedCount = len(names)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/rand"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

// 上游地址
const (
        upstreamModelsURL  = "https://basellm.github.io/llm-metadata/api/newapi/models.json"
        upstreamVendorsURL = "https://basellm.github.io/llm-metadata/api/newapi/vendors.json"
)

func normalizeLocale(locale string) (string, bool) <span class="cov0" title="0">{
        l := strings.ToLower(strings.TrimSpace(locale))
        switch l </span>{
        case "en", "zh", "ja":<span class="cov0" title="0">
                return l, true</span>
        default:<span class="cov0" title="0">
                return "", false</span>
        }
}

func getUpstreamBase() string <span class="cov0" title="0">{
        return common.GetEnvOrDefaultString("SYNC_UPSTREAM_BASE", "https://basellm.github.io/llm-metadata")
}</span>

func getUpstreamURLs(locale string) (modelsURL, vendorsURL string) <span class="cov0" title="0">{
        base := strings.TrimRight(getUpstreamBase(), "/")
        if l, ok := normalizeLocale(locale); ok &amp;&amp; l != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/api/i18n/%s/newapi/models.json", base, l),
                        fmt.Sprintf("%s/api/i18n/%s/newapi/vendors.json", base, l)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s/api/newapi/models.json", base), fmt.Sprintf("%s/api/newapi/vendors.json", base)</span>
}

type upstreamEnvelope[T any] struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Data    []T    `json:"data"`
}

type upstreamModel struct {
        Description string          `json:"description"`
        Endpoints   json.RawMessage `json:"endpoints"`
        Icon        string          `json:"icon"`
        ModelName   string          `json:"model_name"`
        NameRule    int             `json:"name_rule"`
        Status      int             `json:"status"`
        Tags        string          `json:"tags"`
        VendorName  string          `json:"vendor_name"`
}

type upstreamVendor struct {
        Description string `json:"description"`
        Icon        string `json:"icon"`
        Name        string `json:"name"`
        Status      int    `json:"status"`
}

var (
        etagCache  = make(map[string]string)
        bodyCache  = make(map[string][]byte)
        cacheMutex sync.RWMutex
)

type overwriteField struct {
        ModelName string   `json:"model_name"`
        Fields    []string `json:"fields"`
}

type syncRequest struct {
        Overwrite []overwriteField `json:"overwrite"`
        Locale    string           `json:"locale"`
}

func newHTTPClient() *http.Client <span class="cov8" title="1">{
        timeoutSec := common.GetEnvOrDefault("SYNC_HTTP_TIMEOUT_SECONDS", 10)
        dialer := &amp;net.Dialer{Timeout: time.Duration(timeoutSec) * time.Second}
        transport := &amp;http.Transport{
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   time.Duration(timeoutSec) * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
                ResponseHeaderTimeout: time.Duration(timeoutSec) * time.Second,
        }
        transport.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(addr)
                if err != nil </span><span class="cov0" title="0">{
                        host = addr
                }</span>
                <span class="cov0" title="0">if strings.HasSuffix(host, "github.io") </span><span class="cov0" title="0">{
                        if conn, err := dialer.DialContext(ctx, "tcp4", addr); err == nil </span><span class="cov0" title="0">{
                                return conn, nil
                        }</span>
                        <span class="cov0" title="0">return dialer.DialContext(ctx, "tcp6", addr)</span>
                }
                <span class="cov0" title="0">return dialer.DialContext(ctx, network, addr)</span>
        }
        <span class="cov8" title="1">return &amp;http.Client{Transport: transport}</span>
}

var httpClient = newHTTPClient()

func fetchJSON[T any](ctx context.Context, url string, out *upstreamEnvelope[T]) error <span class="cov0" title="0">{
        var lastErr error
        attempts := common.GetEnvOrDefault("SYNC_HTTP_RETRY", 3)
        if attempts &lt; 1 </span><span class="cov0" title="0">{
                attempts = 1
        }</span>
        <span class="cov0" title="0">baseDelay := 200 * time.Millisecond
        maxMB := common.GetEnvOrDefault("SYNC_HTTP_MAX_MB", 10)
        maxBytes := int64(maxMB) &lt;&lt; 20
        for attempt := 0; attempt &lt; attempts; attempt++ </span><span class="cov0" title="0">{
                req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // ETag conditional request
                <span class="cov0" title="0">cacheMutex.RLock()
                if et := etagCache[url]; et != "" </span><span class="cov0" title="0">{
                        req.Header.Set("If-None-Match", et)
                }</span>
                <span class="cov0" title="0">cacheMutex.RUnlock()

                resp, err := httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        // backoff with jitter
                        sleep := baseDelay * time.Duration(1&lt;&lt;attempt)
                        jitter := time.Duration(rand.Intn(150)) * time.Millisecond
                        time.Sleep(sleep + jitter)
                        continue</span>
                }
                <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                        defer resp.Body.Close()
                        switch resp.StatusCode </span>{
                        case http.StatusOK:<span class="cov0" title="0">
                                // read body into buffer for caching and flexible decode
                                limited := io.LimitReader(resp.Body, maxBytes)
                                buf, err := io.ReadAll(limited)
                                if err != nil </span><span class="cov0" title="0">{
                                        lastErr = err
                                        return
                                }</span>
                                // cache body and ETag
                                <span class="cov0" title="0">cacheMutex.Lock()
                                if et := resp.Header.Get("ETag"); et != "" </span><span class="cov0" title="0">{
                                        etagCache[url] = et
                                }</span>
                                <span class="cov0" title="0">bodyCache[url] = buf
                                cacheMutex.Unlock()

                                // Try decode as envelope first
                                if err := json.Unmarshal(buf, out); err != nil </span><span class="cov0" title="0">{
                                        // Try decode as pure array
                                        var arr []T
                                        if err2 := json.Unmarshal(buf, &amp;arr); err2 != nil </span><span class="cov0" title="0">{
                                                lastErr = err
                                                return
                                        }</span>
                                        <span class="cov0" title="0">out.Success = true
                                        out.Data = arr
                                        out.Message = ""</span>
                                } else<span class="cov0" title="0"> {
                                        if !out.Success &amp;&amp; len(out.Data) == 0 &amp;&amp; out.Message == "" </span><span class="cov0" title="0">{
                                                out.Success = true
                                        }</span>
                                }
                                <span class="cov0" title="0">lastErr = nil</span>
                        case http.StatusNotModified:<span class="cov0" title="0">
                                // use cache
                                cacheMutex.RLock()
                                buf := bodyCache[url]
                                cacheMutex.RUnlock()
                                if len(buf) == 0 </span><span class="cov0" title="0">{
                                        lastErr = errors.New("cache miss for 304 response")
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := json.Unmarshal(buf, out); err != nil </span><span class="cov0" title="0">{
                                        var arr []T
                                        if err2 := json.Unmarshal(buf, &amp;arr); err2 != nil </span><span class="cov0" title="0">{
                                                lastErr = err
                                                return
                                        }</span>
                                        <span class="cov0" title="0">out.Success = true
                                        out.Data = arr
                                        out.Message = ""</span>
                                } else<span class="cov0" title="0"> {
                                        if !out.Success &amp;&amp; len(out.Data) == 0 &amp;&amp; out.Message == "" </span><span class="cov0" title="0">{
                                                out.Success = true
                                        }</span>
                                }
                                <span class="cov0" title="0">lastErr = nil</span>
                        default:<span class="cov0" title="0">
                                lastErr = errors.New(resp.Status)</span>
                        }
                }()
                <span class="cov0" title="0">if lastErr == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">sleep := baseDelay * time.Duration(1&lt;&lt;attempt)
                jitter := time.Duration(rand.Intn(150)) * time.Millisecond
                time.Sleep(sleep + jitter)</span>
        }
        <span class="cov0" title="0">return lastErr</span>
}

func ensureVendorID(vendorName string, vendorByName map[string]upstreamVendor, vendorIDCache map[string]int, createdVendors *int) int <span class="cov0" title="0">{
        if vendorName == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if id, ok := vendorIDCache[vendorName]; ok </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov0" title="0">var existing model.Vendor
        if err := model.DB.Where("name = ?", vendorName).First(&amp;existing).Error; err == nil </span><span class="cov0" title="0">{
                vendorIDCache[vendorName] = existing.Id
                return existing.Id
        }</span>
        <span class="cov0" title="0">uv := vendorByName[vendorName]
        v := &amp;model.Vendor{
                Name:        vendorName,
                Description: uv.Description,
                Icon:        coalesce(uv.Icon, ""),
                Status:      chooseStatus(uv.Status, 1),
        }
        if err := v.Insert(); err == nil </span><span class="cov0" title="0">{
                *createdVendors++
                vendorIDCache[vendorName] = v.Id
                return v.Id
        }</span>
        <span class="cov0" title="0">vendorIDCache[vendorName] = 0
        return 0</span>
}

// SyncUpstreamModels 同步上游模型与供应商，仅对「未配置模型」生效
func SyncUpstreamModels(c *gin.Context) <span class="cov0" title="0">{
        var req syncRequest
        // 允许空体
        _ = c.ShouldBindJSON(&amp;req)
        // 1) 获取未配置模型列表
        missing, err := model.GetMissingModels()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if len(missing) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": true, "data": gin.H{
                        "created_models":  0,
                        "created_vendors": 0,
                        "skipped_models":  []string{},
                }})
                return
        }</span>

        // 2) 拉取上游 vendors 与 models
        <span class="cov0" title="0">timeoutSec := common.GetEnvOrDefault("SYNC_HTTP_TIMEOUT_SECONDS", 15)
        ctx, cancel := context.WithTimeout(c.Request.Context(), time.Duration(timeoutSec)*time.Second)
        defer cancel()

        modelsURL, vendorsURL := getUpstreamURLs(req.Locale)
        var vendorsEnv upstreamEnvelope[upstreamVendor]
        var modelsEnv upstreamEnvelope[upstreamModel]
        var fetchErr error
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                // vendor 失败不拦截
                _ = fetchJSON(ctx, vendorsURL, &amp;vendorsEnv)
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                if err := fetchJSON(ctx, modelsURL, &amp;modelsEnv); err != nil </span><span class="cov0" title="0">{
                        fetchErr = err
                }</span>
        }()
        <span class="cov0" title="0">wg.Wait()
        if fetchErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": "获取上游模型失败: " + fetchErr.Error(), "locale": req.Locale, "source_urls": gin.H{"models_url": modelsURL, "vendors_url": vendorsURL}})
                return
        }</span>

        // 建立映射
        <span class="cov0" title="0">vendorByName := make(map[string]upstreamVendor)
        for _, v := range vendorsEnv.Data </span><span class="cov0" title="0">{
                if v.Name != "" </span><span class="cov0" title="0">{
                        vendorByName[v.Name] = v
                }</span>
        }
        <span class="cov0" title="0">modelByName := make(map[string]upstreamModel)
        for _, m := range modelsEnv.Data </span><span class="cov0" title="0">{
                if m.ModelName != "" </span><span class="cov0" title="0">{
                        modelByName[m.ModelName] = m
                }</span>
        }

        // 3) 执行同步：仅创建缺失模型；若上游缺失该模型则跳过
        <span class="cov0" title="0">createdModels := 0
        createdVendors := 0
        updatedModels := 0
        var skipped []string
        var createdList []string
        var updatedList []string

        // 本地缓存：vendorName -&gt; id
        vendorIDCache := make(map[string]int)

        for _, name := range missing </span><span class="cov0" title="0">{
                up, ok := modelByName[name]
                if !ok </span><span class="cov0" title="0">{
                        skipped = append(skipped, name)
                        continue</span>
                }

                // 若本地已存在且设置为不同步，则跳过（极端情况：缺失列表与本地状态不同步时）
                <span class="cov0" title="0">var existing model.Model
                if err := model.DB.Where("model_name = ?", name).First(&amp;existing).Error; err == nil </span><span class="cov0" title="0">{
                        if existing.SyncOfficial == 0 </span><span class="cov0" title="0">{
                                skipped = append(skipped, name)
                                continue</span>
                        }
                }

                // 确保 vendor 存在
                <span class="cov0" title="0">vendorID := ensureVendorID(up.VendorName, vendorByName, vendorIDCache, &amp;createdVendors)

                // 创建模型
                mi := &amp;model.Model{
                        ModelName:   name,
                        Description: up.Description,
                        Icon:        up.Icon,
                        Tags:        up.Tags,
                        VendorID:    vendorID,
                        Status:      chooseStatus(up.Status, 1),
                        NameRule:    up.NameRule,
                }
                if err := mi.Insert(); err == nil </span><span class="cov0" title="0">{
                        createdModels++
                        createdList = append(createdList, name)
                }</span> else<span class="cov0" title="0"> {
                        skipped = append(skipped, name)
                }</span>
        }

        // 4) 处理可选覆盖（更新本地已有模型的差异字段）
        <span class="cov0" title="0">if len(req.Overwrite) &gt; 0 </span><span class="cov0" title="0">{
                // vendorIDCache 已用于创建阶段，可复用
                for _, ow := range req.Overwrite </span><span class="cov0" title="0">{
                        up, ok := modelByName[ow.ModelName]
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">var local model.Model
                        if err := model.DB.Where("model_name = ?", ow.ModelName).First(&amp;local).Error; err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 跳过被禁用官方同步的模型
                        <span class="cov0" title="0">if local.SyncOfficial == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 映射 vendor
                        <span class="cov0" title="0">newVendorID := ensureVendorID(up.VendorName, vendorByName, vendorIDCache, &amp;createdVendors)

                        // 应用字段覆盖（事务）
                        _ = model.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                                needUpdate := false
                                if containsField(ow.Fields, "description") </span><span class="cov0" title="0">{
                                        local.Description = up.Description
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if containsField(ow.Fields, "icon") </span><span class="cov0" title="0">{
                                        local.Icon = up.Icon
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if containsField(ow.Fields, "tags") </span><span class="cov0" title="0">{
                                        local.Tags = up.Tags
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if containsField(ow.Fields, "vendor") </span><span class="cov0" title="0">{
                                        local.VendorID = newVendorID
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if containsField(ow.Fields, "name_rule") </span><span class="cov0" title="0">{
                                        local.NameRule = up.NameRule
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if containsField(ow.Fields, "status") </span><span class="cov0" title="0">{
                                        local.Status = chooseStatus(up.Status, local.Status)
                                        needUpdate = true
                                }</span>
                                <span class="cov0" title="0">if !needUpdate </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">if err := tx.Save(&amp;local).Error; err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">updatedModels++
                                updatedList = append(updatedList, ow.ModelName)
                                return nil</span>
                        })
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "created_models":  createdModels,
                        "created_vendors": createdVendors,
                        "updated_models":  updatedModels,
                        "skipped_models":  skipped,
                        "created_list":    createdList,
                        "updated_list":    updatedList,
                        "source": gin.H{
                                "locale":      req.Locale,
                                "models_url":  modelsURL,
                                "vendors_url": vendorsURL,
                        },
                },
        })</span>
}

func containsField(fields []string, key string) bool <span class="cov0" title="0">{
        key = strings.ToLower(strings.TrimSpace(key))
        for _, f := range fields </span><span class="cov0" title="0">{
                if strings.ToLower(strings.TrimSpace(f)) == key </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func coalesce(a, b string) string <span class="cov0" title="0">{
        if strings.TrimSpace(a) != "" </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func chooseStatus(primary, fallback int) int <span class="cov0" title="0">{
        if primary == 0 &amp;&amp; fallback != 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">if primary != 0 </span><span class="cov0" title="0">{
                return primary
        }</span>
        <span class="cov0" title="0">return 1</span>
}

// SyncUpstreamPreview 预览上游与本地的差异（仅用于弹窗选择）
func SyncUpstreamPreview(c *gin.Context) <span class="cov0" title="0">{
        // 1) 拉取上游数据
        timeoutSec := common.GetEnvOrDefault("SYNC_HTTP_TIMEOUT_SECONDS", 15)
        ctx, cancel := context.WithTimeout(c.Request.Context(), time.Duration(timeoutSec)*time.Second)
        defer cancel()

        locale := c.Query("locale")
        modelsURL, vendorsURL := getUpstreamURLs(locale)

        var vendorsEnv upstreamEnvelope[upstreamVendor]
        var modelsEnv upstreamEnvelope[upstreamModel]
        var fetchErr error
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                _ = fetchJSON(ctx, vendorsURL, &amp;vendorsEnv)
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                if err := fetchJSON(ctx, modelsURL, &amp;modelsEnv); err != nil </span><span class="cov0" title="0">{
                        fetchErr = err
                }</span>
        }()
        <span class="cov0" title="0">wg.Wait()
        if fetchErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": "获取上游模型失败: " + fetchErr.Error(), "locale": locale, "source_urls": gin.H{"models_url": modelsURL, "vendors_url": vendorsURL}})
                return
        }</span>

        <span class="cov0" title="0">vendorByName := make(map[string]upstreamVendor)
        for _, v := range vendorsEnv.Data </span><span class="cov0" title="0">{
                if v.Name != "" </span><span class="cov0" title="0">{
                        vendorByName[v.Name] = v
                }</span>
        }
        <span class="cov0" title="0">modelByName := make(map[string]upstreamModel)
        upstreamNames := make([]string, 0, len(modelsEnv.Data))
        for _, m := range modelsEnv.Data </span><span class="cov0" title="0">{
                if m.ModelName != "" </span><span class="cov0" title="0">{
                        modelByName[m.ModelName] = m
                        upstreamNames = append(upstreamNames, m.ModelName)
                }</span>
        }

        // 2) 本地已有模型
        <span class="cov0" title="0">var locals []model.Model
        if len(upstreamNames) &gt; 0 </span><span class="cov0" title="0">{
                _ = model.DB.Where("model_name IN ? AND sync_official &lt;&gt; 0", upstreamNames).Find(&amp;locals).Error
        }</span>

        // 本地 vendor 名称映射
        <span class="cov0" title="0">vendorIdSet := make(map[int]struct{})
        for _, m := range locals </span><span class="cov0" title="0">{
                if m.VendorID != 0 </span><span class="cov0" title="0">{
                        vendorIdSet[m.VendorID] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">vendorIDs := make([]int, 0, len(vendorIdSet))
        for id := range vendorIdSet </span><span class="cov0" title="0">{
                vendorIDs = append(vendorIDs, id)
        }</span>
        <span class="cov0" title="0">idToVendorName := make(map[int]string)
        if len(vendorIDs) &gt; 0 </span><span class="cov0" title="0">{
                var dbVendors []model.Vendor
                _ = model.DB.Where("id IN ?", vendorIDs).Find(&amp;dbVendors).Error
                for _, v := range dbVendors </span><span class="cov0" title="0">{
                        idToVendorName[v.Id] = v.Name
                }</span>
        }

        // 3) 缺失且上游存在的模型
        <span class="cov0" title="0">missingList, _ := model.GetMissingModels()
        var missing []string
        for _, name := range missingList </span><span class="cov0" title="0">{
                if _, ok := modelByName[name]; ok </span><span class="cov0" title="0">{
                        missing = append(missing, name)
                }</span>
        }

        // 4) 计算冲突字段
        <span class="cov0" title="0">type conflictField struct {
                Field    string      `json:"field"`
                Local    interface{} `json:"local"`
                Upstream interface{} `json:"upstream"`
        }
        type conflictItem struct {
                ModelName string          `json:"model_name"`
                Fields    []conflictField `json:"fields"`
        }

        var conflicts []conflictItem
        for _, local := range locals </span><span class="cov0" title="0">{
                up, ok := modelByName[local.ModelName]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fields := make([]conflictField, 0, 6)
                if strings.TrimSpace(local.Description) != strings.TrimSpace(up.Description) </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "description", Local: local.Description, Upstream: up.Description})
                }</span>
                <span class="cov0" title="0">if strings.TrimSpace(local.Icon) != strings.TrimSpace(up.Icon) </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "icon", Local: local.Icon, Upstream: up.Icon})
                }</span>
                <span class="cov0" title="0">if strings.TrimSpace(local.Tags) != strings.TrimSpace(up.Tags) </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "tags", Local: local.Tags, Upstream: up.Tags})
                }</span>
                // vendor 对比使用名称
                <span class="cov0" title="0">localVendor := idToVendorName[local.VendorID]
                if strings.TrimSpace(localVendor) != strings.TrimSpace(up.VendorName) </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "vendor", Local: localVendor, Upstream: up.VendorName})
                }</span>
                <span class="cov0" title="0">if local.NameRule != up.NameRule </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "name_rule", Local: local.NameRule, Upstream: up.NameRule})
                }</span>
                <span class="cov0" title="0">if local.Status != chooseStatus(up.Status, local.Status) </span><span class="cov0" title="0">{
                        fields = append(fields, conflictField{Field: "status", Local: local.Status, Upstream: up.Status})
                }</span>
                <span class="cov0" title="0">if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        conflicts = append(conflicts, conflictItem{ModelName: local.ModelName, Fields: fields})
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "missing":   missing,
                        "conflicts": conflicts,
                        "source": gin.H{
                                "locale":      locale,
                                "models_url":  modelsURL,
                                "vendors_url": vendorsURL,
                        },
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type OidcResponse struct {
        AccessToken  string `json:"access_token"`
        IDToken      string `json:"id_token"`
        RefreshToken string `json:"refresh_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int    `json:"expires_in"`
        Scope        string `json:"scope"`
}

type OidcUser struct {
        OpenID            string `json:"sub"`
        Email             string `json:"email"`
        Name              string `json:"name"`
        PreferredUsername string `json:"preferred_username"`
        Picture           string `json:"picture"`
}

func getOidcUserInfoByCode(code string) (*OidcUser, error) <span class="cov0" title="0">{
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("无效的参数")
        }</span>

        <span class="cov0" title="0">values := url.Values{}
        values.Set("client_id", system_setting.GetOIDCSettings().ClientId)
        values.Set("client_secret", system_setting.GetOIDCSettings().ClientSecret)
        values.Set("code", code)
        values.Set("grant_type", "authorization_code")
        values.Set("redirect_uri", fmt.Sprintf("%s/oauth/oidc", system_setting.ServerAddress))
        formData := values.Encode()
        req, err := http.NewRequest("POST", system_setting.GetOIDCSettings().TokenEndpoint, strings.NewReader(formData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("Accept", "application/json")
        client := http.Client{
                Timeout: 5 * time.Second,
        }
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 OIDC 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        var oidcResponse OidcResponse
        err = json.NewDecoder(res.Body).Decode(&amp;oidcResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if oidcResponse.AccessToken == "" </span><span class="cov0" title="0">{
                common.SysLog("OIDC 获取 Token 失败，请检查设置！")
                return nil, errors.New("OIDC 获取 Token 失败，请检查设置！")
        }</span>

        <span class="cov0" title="0">req, err = http.NewRequest("GET", system_setting.GetOIDCSettings().UserInfoEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+oidcResponse.AccessToken)
        res2, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(err.Error())
                return nil, errors.New("无法连接至 OIDC 服务器，请稍后重试！")
        }</span>
        <span class="cov0" title="0">defer res2.Body.Close()
        if res2.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                common.SysLog("OIDC 获取用户信息失败！请检查设置！")
                return nil, errors.New("OIDC 获取用户信息失败！请检查设置！")
        }</span>

        <span class="cov0" title="0">var oidcUser OidcUser
        err = json.NewDecoder(res2.Body).Decode(&amp;oidcUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if oidcUser.OpenID == "" || oidcUser.Email == "" </span><span class="cov0" title="0">{
                common.SysLog("OIDC 获取用户信息为空！请检查设置！")
                return nil, errors.New("OIDC 获取用户信息为空！请检查设置！")
        }</span>
        <span class="cov0" title="0">return &amp;oidcUser, nil</span>
}

func OidcAuth(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        state := c.Query("state")
        if state == "" || session.Get("oauth_state") == nil || state != session.Get("oauth_state").(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "message": "state is empty or not same",
                })
                return
        }</span>
        <span class="cov0" title="0">username := session.Get("username")
        if username != nil </span><span class="cov0" title="0">{
                OidcBind(c)
                return
        }</span>
        <span class="cov0" title="0">if !system_setting.GetOIDCSettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 OIDC 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        oidcUser, err := getOidcUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                OidcId: oidcUser.OpenID,
        }
        if model.IsOidcIdAlreadyTaken(user.OidcId) </span><span class="cov0" title="0">{
                err := user.FillUserByOidcId()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if common.RegisterEnabled </span><span class="cov0" title="0">{
                        user.Email = oidcUser.Email
                        if oidcUser.PreferredUsername != "" </span><span class="cov0" title="0">{
                                user.Username = oidcUser.PreferredUsername
                        }</span> else<span class="cov0" title="0"> {
                                user.Username = "oidc_" + strconv.Itoa(model.GetMaxUserId()+1)
                        }</span>
                        <span class="cov0" title="0">if oidcUser.Name != "" </span><span class="cov0" title="0">{
                                user.DisplayName = oidcUser.Name
                        }</span> else<span class="cov0" title="0"> {
                                user.DisplayName = "OIDC User"
                        }</span>
                        <span class="cov0" title="0">err := user.Insert(0)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员关闭了新用户注册",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "用户已被封禁",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

func OidcBind(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetOIDCSettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未开启通过 OIDC 登录以及注册",
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        oidcUser, err := getOidcUserInfoByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                OidcId: oidcUser.OpenID,
        }
        if model.IsOidcIdAlreadyTaken(user.OidcId) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该 OIDC 账户已被绑定",
                })
                return
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        // id := c.GetInt("id")  // critical bug!
        user.Id = id.(int)
        err = user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user.OidcId = oidcUser.OpenID
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "bind",
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/console_setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-gonic/gin"
)

func GetOptions(c *gin.Context) <span class="cov0" title="0">{
        var options []*model.Option
        common.OptionMapRWMutex.Lock()
        for k, v := range common.OptionMap </span><span class="cov0" title="0">{
                if strings.HasSuffix(k, "Token") || strings.HasSuffix(k, "Secret") || strings.HasSuffix(k, "Key") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">options = append(options, &amp;model.Option{
                        Key:   k,
                        Value: common.Interface2String(v),
                })</span>
        }
        <span class="cov0" title="0">common.OptionMapRWMutex.Unlock()
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    options,
        })
        return</span>
}

type OptionUpdateRequest struct {
        Key   string `json:"key"`
        Value any    `json:"value"`
}

func UpdateOption(c *gin.Context) <span class="cov0" title="0">{
        var option OptionUpdateRequest
        err := json.NewDecoder(c.Request.Body).Decode(&amp;option)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">switch option.Value.(type) </span>{
        case bool:<span class="cov0" title="0">
                option.Value = common.Interface2String(option.Value.(bool))</span>
        case float64:<span class="cov0" title="0">
                option.Value = common.Interface2String(option.Value.(float64))</span>
        case int:<span class="cov0" title="0">
                option.Value = common.Interface2String(option.Value.(int))</span>
        default:<span class="cov0" title="0">
                option.Value = fmt.Sprintf("%v", option.Value)</span>
        }
        <span class="cov0" title="0">switch option.Key </span>{
        case "GitHubOAuthEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; common.GitHubClientId == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 GitHub OAuth，请先填入 GitHub Client Id 以及 GitHub Client Secret！",
                        })
                        return
                }</span>
        case "discord.enabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; system_setting.GetDiscordSettings().ClientId == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 Discord OAuth，请先填入 Discord Client Id 以及 Discord Client Secret！",
                        })
                        return
                }</span>
        case "oidc.enabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; system_setting.GetOIDCSettings().ClientId == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 OIDC 登录，请先填入 OIDC Client Id 以及 OIDC Client Secret！",
                        })
                        return
                }</span>
        case "LinuxDOOAuthEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; common.LinuxDOClientId == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 LinuxDO OAuth，请先填入 LinuxDO Client Id 以及 LinuxDO Client Secret！",
                        })
                        return
                }</span>
        case "EmailDomainRestrictionEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; len(common.EmailDomainWhitelist) == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用邮箱域名限制，请先填入限制的邮箱域名！",
                        })
                        return
                }</span>
        case "WeChatAuthEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; common.WeChatServerAddress == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用微信登录，请先填入微信登录相关配置信息！",
                        })
                        return
                }</span>
        case "TurnstileCheckEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; common.TurnstileSiteKey == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 Turnstile 校验，请先填入 Turnstile 校验相关配置信息！",
                        })

                        return
                }</span>
        case "TelegramOAuthEnabled":<span class="cov0" title="0">
                if option.Value == "true" &amp;&amp; common.TelegramBotToken == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法启用 Telegram OAuth，请先填入 Telegram Bot Token！",
                        })
                        return
                }</span>
        case "GroupRatio":<span class="cov0" title="0">
                err = ratio_setting.CheckGroupRatio(option.Value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "ImageRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateImageRatioByJSONString(option.Value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "图片倍率设置失败: " + err.Error(),
                        })
                        return
                }</span>
        case "AudioRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateAudioRatioByJSONString(option.Value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "音频倍率设置失败: " + err.Error(),
                        })
                        return
                }</span>
        case "AudioCompletionRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateAudioCompletionRatioByJSONString(option.Value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "音频补全倍率设置失败: " + err.Error(),
                        })
                        return
                }</span>
        case "ModelRequestRateLimitGroup":<span class="cov0" title="0">
                err = setting.CheckModelRequestRateLimitGroup(option.Value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "console_setting.api_info":<span class="cov0" title="0">
                err = console_setting.ValidateConsoleSettings(option.Value.(string), "ApiInfo")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "console_setting.announcements":<span class="cov0" title="0">
                err = console_setting.ValidateConsoleSettings(option.Value.(string), "Announcements")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "console_setting.faq":<span class="cov0" title="0">
                err = console_setting.ValidateConsoleSettings(option.Value.(string), "FAQ")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "console_setting.uptime_kuma_groups":<span class="cov0" title="0">
                err = console_setting.ValidateConsoleSettings(option.Value.(string), "UptimeKumaGroups")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        }
        <span class="cov0" title="0">err = model.UpdateOption(option.Key, option.Value.(string))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package controller

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        passkeysvc "github.com/QuantumNous/new-api/service/passkey"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "github.com/go-webauthn/webauthn/protocol"
        webauthnlib "github.com/go-webauthn/webauthn/webauthn"
)

func PasskeyRegisterBegin(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">credential, err := model.GetPasskeyByUserID(user.Id)
        if err != nil &amp;&amp; !errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                credential = nil
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">waUser := passkeysvc.NewWebAuthnUser(user, credential)
        var options []webauthnlib.RegistrationOption
        if credential != nil </span><span class="cov0" title="0">{
                descriptor := credential.ToWebAuthnCredential().Descriptor()
                options = append(options, webauthnlib.WithExclusions([]protocol.CredentialDescriptor{descriptor}))
        }</span>

        <span class="cov0" title="0">creation, sessionData, err := wa.BeginRegistration(waUser, options...)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">if err := passkeysvc.SaveSessionData(c, passkeysvc.RegistrationSessionKey, sessionData); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "options": creation,
                },
        })</span>
}

func PasskeyRegisterFinish(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">credentialRecord, err := model.GetPasskeyByUserID(user.Id)
        if err != nil &amp;&amp; !errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                credentialRecord = nil
        }</span>

        <span class="cov0" title="0">sessionData, err := passkeysvc.PopSessionData(c, passkeysvc.RegistrationSessionKey)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">waUser := passkeysvc.NewWebAuthnUser(user, credentialRecord)
        credential, err := wa.FinishRegistration(waUser, *sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">passkeyCredential := model.NewPasskeyCredentialFromWebAuthn(user.Id, credential)
        if passkeyCredential == nil </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "无法创建 Passkey 凭证")
                return
        }</span>

        <span class="cov0" title="0">if err := model.UpsertPasskeyCredential(passkeyCredential); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Passkey 注册成功",
        })</span>
}

func PasskeyDelete(c *gin.Context) <span class="cov0" title="0">{
        user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">if err := model.DeletePasskeyByUserID(user.Id); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Passkey 已解绑",
        })</span>
}

func PasskeyStatus(c *gin.Context) <span class="cov0" title="0">{
        user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">credential, err := model.GetPasskeyByUserID(user.Id)
        if errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                        "data": gin.H{
                                "enabled": false,
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">data := gin.H{
                "enabled":      true,
                "last_used_at": credential.LastUsedAt,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    data,
        })</span>
}

func PasskeyLoginBegin(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">assertion, sessionData, err := wa.BeginDiscoverableLogin()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">if err := passkeysvc.SaveSessionData(c, passkeysvc.LoginSessionKey, sessionData); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "options": assertion,
                },
        })</span>
}

func PasskeyLoginFinish(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">sessionData, err := passkeysvc.PopSessionData(c, passkeysvc.LoginSessionKey)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">handler := func(rawID, userHandle []byte) (webauthnlib.User, error) </span><span class="cov0" title="0">{
                // 首先通过凭证ID查找用户
                credential, err := model.GetPasskeyByCredentialID(rawID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("未找到 Passkey 凭证: %w", err)
                }</span>

                // 通过凭证获取用户
                <span class="cov0" title="0">user := &amp;model.User{Id: credential.UserID}
                if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("用户信息获取失败: %w", err)
                }</span>

                <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                        return nil, errors.New("该用户已被禁用")
                }</span>

                <span class="cov0" title="0">if len(userHandle) &gt; 0 </span><span class="cov0" title="0">{
                        userID, parseErr := strconv.Atoi(string(userHandle))
                        if parseErr != nil </span><span class="cov0" title="0">{
                                // 记录异常但继续验证，因为某些客户端可能使用非数字格式
                                common.SysLog(fmt.Sprintf("PasskeyLogin: userHandle parse error for credential, length: %d", len(userHandle)))
                        }</span> else<span class="cov0" title="0"> if userID != user.Id </span><span class="cov0" title="0">{
                                return nil, errors.New("用户句柄与凭证不匹配")
                        }</span>
                }

                <span class="cov0" title="0">return passkeysvc.NewWebAuthnUser(user, credential), nil</span>
        }

        <span class="cov0" title="0">waUser, credential, err := wa.FinishPasskeyLogin(handler, *sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">userWrapper, ok := waUser.(*passkeysvc.WebAuthnUser)
        if !ok </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "Passkey 登录状态异常")
                return
        }</span>

        <span class="cov0" title="0">modelUser := userWrapper.ModelUser()
        if modelUser == nil </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "Passkey 登录状态异常")
                return
        }</span>

        <span class="cov0" title="0">if modelUser.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "该用户已被禁用")
                return
        }</span>

        // 更新凭证信息
        <span class="cov0" title="0">updatedCredential := model.NewPasskeyCredentialFromWebAuthn(modelUser.Id, credential)
        if updatedCredential == nil </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "Passkey 凭证更新失败")
                return
        }</span>
        <span class="cov0" title="0">now := time.Now()
        updatedCredential.LastUsedAt = &amp;now
        if err := model.UpsertPasskeyCredential(updatedCredential); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">setupLogin(modelUser, c)
        return</span>
}

func AdminResetPasskey(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "无效的用户 ID")
                return
        }</span>

        <span class="cov0" title="0">user := &amp;model.User{Id: id}
        if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">if _, err := model.GetPasskeyByUserID(user.Id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, model.ErrPasskeyNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "该用户尚未绑定 Passkey",
                        })
                        return
                }</span>
                <span class="cov0" title="0">common.ApiError(c, err)
                return</span>
        }

        <span class="cov0" title="0">if err := model.DeletePasskeyByUserID(user.Id); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Passkey 已重置",
        })</span>
}

func PasskeyVerifyBegin(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">credential, err := model.GetPasskeyByUserID(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该用户尚未绑定 Passkey",
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">waUser := passkeysvc.NewWebAuthnUser(user, credential)
        assertion, sessionData, err := wa.BeginLogin(waUser)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">if err := passkeysvc.SaveSessionData(c, passkeysvc.VerifySessionKey, sessionData); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": gin.H{
                        "options": assertion,
                },
        })</span>
}

func PasskeyVerifyFinish(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := getSessionUser(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">credential, err := model.GetPasskeyByUserID(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该用户尚未绑定 Passkey",
                })
                return
        }</span>

        <span class="cov0" title="0">sessionData, err := passkeysvc.PopSessionData(c, passkeysvc.VerifySessionKey)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">waUser := passkeysvc.NewWebAuthnUser(user, credential)
        _, err = wa.FinishLogin(waUser, *sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 更新凭证的最后使用时间
        <span class="cov0" title="0">now := time.Now()
        credential.LastUsedAt = &amp;now
        if err := model.UpsertPasskeyCredential(credential); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Passkey 验证成功",
        })</span>
}

func getSessionUser(c *gin.Context) (*model.User, error) <span class="cov0" title="0">{
        session := sessions.Default(c)
        idRaw := session.Get("id")
        if idRaw == nil </span><span class="cov0" title="0">{
                return nil, errors.New("未登录")
        }</span>
        <span class="cov0" title="0">id, ok := idRaw.(int)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("无效的会话信息")
        }</span>
        <span class="cov0" title="0">user := &amp;model.User{Id: id}
        if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                return nil, errors.New("该用户已被禁用")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package controller

import (
        "errors"
        "fmt"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/middleware"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/types"

        "github.com/gin-gonic/gin"
)

func Playground(c *gin.Context) <span class="cov0" title="0">{
        var newAPIError *types.NewAPIError

        defer func() </span><span class="cov0" title="0">{
                if newAPIError != nil </span><span class="cov0" title="0">{
                        c.JSON(newAPIError.StatusCode, gin.H{
                                "error": newAPIError.ToOpenAIError(),
                        })
                }</span>
        }()

        <span class="cov0" title="0">useAccessToken := c.GetBool("use_access_token")
        if useAccessToken </span><span class="cov0" title="0">{
                newAPIError = types.NewError(errors.New("暂不支持使用 access token"), types.ErrorCodeAccessDenied, types.ErrOptionWithSkipRetry())
                return
        }</span>

        <span class="cov0" title="0">group := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)
        modelName := c.GetString("original_model")

        userId := c.GetInt("id")

        // Write user context to ensure acceptUnsetRatio is available
        userCache, err := model.GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                newAPIError = types.NewError(err, types.ErrorCodeQueryDataError, types.ErrOptionWithSkipRetry())
                return
        }</span>
        <span class="cov0" title="0">userCache.WriteContext(c)

        tempToken := &amp;model.Token{
                UserId: userId,
                Name:   fmt.Sprintf("playground-%s", group),
                Group:  group,
        }
        _ = middleware.SetupContextForToken(c, tempToken)
        _, newAPIError = getChannel(c, group, modelName, 0)
        if newAPIError != nil </span><span class="cov0" title="0">{
                return
        }</span>
        //middleware.SetupContextForSelectedChannel(c, channel, playgroundRequest.Model)
        <span class="cov0" title="0">common.SetContextKey(c, constant.ContextKeyRequestStartTime, time.Now())

        Relay(c, types.RelayFormatOpenAI)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package controller

import (
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// GetPrefillGroups 获取预填组列表，可通过 ?type=xxx 过滤
func GetPrefillGroups(c *gin.Context) <span class="cov0" title="0">{
        groupType := c.Query("type")
        groups, err := model.GetAllPrefillGroups(groupType)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, groups)</span>
}

// CreatePrefillGroup 创建新的预填组
func CreatePrefillGroup(c *gin.Context) <span class="cov0" title="0">{
        var g model.PrefillGroup
        if err := c.ShouldBindJSON(&amp;g); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if g.Name == "" || g.Type == "" </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "组名称和类型不能为空")
                return
        }</span>
        // 创建前检查名称
        <span class="cov0" title="0">if dup, err := model.IsPrefillGroupNameDuplicated(0, g.Name); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "组名称已存在")
                return
        }</span>

        <span class="cov0" title="0">if err := g.Insert(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, &amp;g)</span>
}

// UpdatePrefillGroup 更新预填组
func UpdatePrefillGroup(c *gin.Context) <span class="cov0" title="0">{
        var g model.PrefillGroup
        if err := c.ShouldBindJSON(&amp;g); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if g.Id == 0 </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "缺少组 ID")
                return
        }</span>
        // 名称冲突检查
        <span class="cov0" title="0">if dup, err := model.IsPrefillGroupNameDuplicated(g.Id, g.Name); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "组名称已存在")
                return
        }</span>

        <span class="cov0" title="0">if err := g.Update(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, &amp;g)</span>
}

// DeletePrefillGroup 删除预填组
func DeletePrefillGroup(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if err := model.DeletePrefillGroupByID(id); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, nil)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package controller

import (
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting/ratio_setting"

        "github.com/gin-gonic/gin"
)

func GetPricing(c *gin.Context) <span class="cov0" title="0">{
        pricing := model.GetPricing()
        userId, exists := c.Get("id")
        usableGroup := map[string]string{}
        groupRatio := map[string]float64{}
        for s, f := range ratio_setting.GetGroupRatioCopy() </span><span class="cov0" title="0">{
                groupRatio[s] = f
        }</span>
        <span class="cov0" title="0">var group string
        if exists </span><span class="cov0" title="0">{
                user, err := model.GetUserCache(userId.(int))
                if err == nil </span><span class="cov0" title="0">{
                        group = user.Group
                        for g := range groupRatio </span><span class="cov0" title="0">{
                                ratio, ok := ratio_setting.GetGroupGroupRatio(group, g)
                                if ok </span><span class="cov0" title="0">{
                                        groupRatio[g] = ratio
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">usableGroup = service.GetUserUsableGroups(group)
        // check groupRatio contains usableGroup
        for group := range ratio_setting.GetGroupRatioCopy() </span><span class="cov0" title="0">{
                if _, ok := usableGroup[group]; !ok </span><span class="cov0" title="0">{
                        delete(groupRatio, group)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(200, gin.H{
                "success":            true,
                "data":               pricing,
                "vendors":            model.GetVendors(),
                "group_ratio":        groupRatio,
                "usable_group":       usableGroup,
                "supported_endpoint": model.GetSupportedEndpointMap(),
                "auto_groups":        service.GetUserAutoGroup(group),
        })</span>
}

func ResetModelRatio(c *gin.Context) <span class="cov0" title="0">{
        defaultStr := ratio_setting.DefaultModelRatio2JSONString()
        err := model.UpdateOption("ModelRatio", defaultStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">err = ratio_setting.UpdateModelRatioByJSONString(defaultStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{
                "success": true,
                "message": "重置模型倍率成功",
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package controller

import (
        "net/http"

        "github.com/QuantumNous/new-api/setting/ratio_setting"

        "github.com/gin-gonic/gin"
)

func GetRatioConfig(c *gin.Context) <span class="cov0" title="0">{
        if !ratio_setting.IsExposeRatioEnabled() </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "message": "倍率配置接口未启用",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    ratio_setting.GetExposedData(),
        })</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/logger"

        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/ratio_setting"

        "github.com/gin-gonic/gin"
)

const (
        defaultTimeoutSeconds = 10
        defaultEndpoint       = "/api/ratio_config"
        maxConcurrentFetches  = 8
        maxRatioConfigBytes   = 10 &lt;&lt; 20 // 10MB
        floatEpsilon          = 1e-9
)

func nearlyEqual(a, b float64) bool <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a-b &lt; floatEpsilon
        }</span>
        <span class="cov0" title="0">return b-a &lt; floatEpsilon</span>
}

func valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        af, aok := a.(float64)
        bf, bok := b.(float64)
        if aok &amp;&amp; bok </span><span class="cov0" title="0">{
                return nearlyEqual(af, bf)
        }</span>
        <span class="cov0" title="0">return a == b</span>
}

var ratioTypes = []string{"model_ratio", "completion_ratio", "cache_ratio", "model_price"}

type upstreamResult struct {
        Name string         `json:"name"`
        Data map[string]any `json:"data,omitempty"`
        Err  string         `json:"err,omitempty"`
}

func FetchUpstreamRatios(c *gin.Context) <span class="cov0" title="0">{
        var req dto.UpstreamRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"success": false, "message": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if req.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                req.Timeout = defaultTimeoutSeconds
        }</span>

        <span class="cov0" title="0">var upstreams []dto.UpstreamDTO

        if len(req.Upstreams) &gt; 0 </span><span class="cov0" title="0">{
                for _, u := range req.Upstreams </span><span class="cov0" title="0">{
                        if strings.HasPrefix(u.BaseURL, "http") </span><span class="cov0" title="0">{
                                if u.Endpoint == "" </span><span class="cov0" title="0">{
                                        u.Endpoint = defaultEndpoint
                                }</span>
                                <span class="cov0" title="0">u.BaseURL = strings.TrimRight(u.BaseURL, "/")
                                upstreams = append(upstreams, u)</span>
                        }
                }
        } else<span class="cov0" title="0"> if len(req.ChannelIDs) &gt; 0 </span><span class="cov0" title="0">{
                intIds := make([]int, 0, len(req.ChannelIDs))
                for _, id64 := range req.ChannelIDs </span><span class="cov0" title="0">{
                        intIds = append(intIds, int(id64))
                }</span>
                <span class="cov0" title="0">dbChannels, err := model.GetChannelsByIds(intIds)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(c.Request.Context(), "failed to query channels: "+err.Error())
                        c.JSON(http.StatusInternalServerError, gin.H{"success": false, "message": "查询渠道失败"})
                        return
                }</span>
                <span class="cov0" title="0">for _, ch := range dbChannels </span><span class="cov0" title="0">{
                        if base := ch.GetBaseURL(); strings.HasPrefix(base, "http") </span><span class="cov0" title="0">{
                                upstreams = append(upstreams, dto.UpstreamDTO{
                                        ID:       ch.Id,
                                        Name:     ch.Name,
                                        BaseURL:  strings.TrimRight(base, "/"),
                                        Endpoint: "",
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(upstreams) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": "无有效上游渠道"})
                return
        }</span>

        <span class="cov0" title="0">var wg sync.WaitGroup
        ch := make(chan upstreamResult, len(upstreams))

        sem := make(chan struct{}, maxConcurrentFetches)

        dialer := &amp;net.Dialer{Timeout: 10 * time.Second}
        transport := &amp;http.Transport{MaxIdleConns: 100, IdleConnTimeout: 90 * time.Second, TLSHandshakeTimeout: 10 * time.Second, ExpectContinueTimeout: 1 * time.Second, ResponseHeaderTimeout: 10 * time.Second}
        transport.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(addr)
                if err != nil </span><span class="cov0" title="0">{
                        host = addr
                }</span>
                // 对 github.io 优先尝试 IPv4，失败则回退 IPv6
                <span class="cov0" title="0">if strings.HasSuffix(host, "github.io") </span><span class="cov0" title="0">{
                        if conn, err := dialer.DialContext(ctx, "tcp4", addr); err == nil </span><span class="cov0" title="0">{
                                return conn, nil
                        }</span>
                        <span class="cov0" title="0">return dialer.DialContext(ctx, "tcp6", addr)</span>
                }
                <span class="cov0" title="0">return dialer.DialContext(ctx, network, addr)</span>
        }
        <span class="cov0" title="0">client := &amp;http.Client{Transport: transport}

        for _, chn := range upstreams </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(chItem dto.UpstreamDTO) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-sem }</span>()

                        <span class="cov0" title="0">endpoint := chItem.Endpoint
                        var fullURL string
                        if strings.HasPrefix(endpoint, "http://") || strings.HasPrefix(endpoint, "https://") </span><span class="cov0" title="0">{
                                fullURL = endpoint
                        }</span> else<span class="cov0" title="0"> {
                                if endpoint == "" </span><span class="cov0" title="0">{
                                        endpoint = defaultEndpoint
                                }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(endpoint, "/") </span><span class="cov0" title="0">{
                                        endpoint = "/" + endpoint
                                }</span>
                                <span class="cov0" title="0">fullURL = chItem.BaseURL + endpoint</span>
                        }

                        <span class="cov0" title="0">uniqueName := chItem.Name
                        if chItem.ID != 0 </span><span class="cov0" title="0">{
                                uniqueName = fmt.Sprintf("%s(%d)", chItem.Name, chItem.ID)
                        }</span>

                        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(c.Request.Context(), time.Duration(req.Timeout)*time.Second)
                        defer cancel()

                        httpReq, err := http.NewRequestWithContext(ctx, http.MethodGet, fullURL, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "build request failed: "+err.Error())
                                ch &lt;- upstreamResult{Name: uniqueName, Err: err.Error()}
                                return
                        }</span>

                        // 简单重试：最多 3 次，指数退避
                        <span class="cov0" title="0">var resp *http.Response
                        var lastErr error
                        for attempt := 0; attempt &lt; 3; attempt++ </span><span class="cov0" title="0">{
                                resp, lastErr = client.Do(httpReq)
                                if lastErr == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(time.Duration(200*(1&lt;&lt;attempt)) * time.Millisecond)</span>
                        }
                        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "http error on "+chItem.Name+": "+lastErr.Error())
                                ch &lt;- upstreamResult{Name: uniqueName, Err: lastErr.Error()}
                                return
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()
                        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "non-200 from "+chItem.Name+": "+resp.Status)
                                ch &lt;- upstreamResult{Name: uniqueName, Err: resp.Status}
                                return
                        }</span>

                        // Content-Type 和响应体大小校验
                        <span class="cov0" title="0">if ct := resp.Header.Get("Content-Type"); ct != "" &amp;&amp; !strings.Contains(strings.ToLower(ct), "application/json") </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "unexpected content-type from "+chItem.Name+": "+ct)
                        }</span>
                        <span class="cov0" title="0">limited := io.LimitReader(resp.Body, maxRatioConfigBytes)
                        // 兼容两种上游接口格式：
                        //  type1: /api/ratio_config -&gt; data 为 map[string]any，包含 model_ratio/completion_ratio/cache_ratio/model_price
                        //  type2: /api/pricing      -&gt; data 为 []Pricing 列表，需要转换为与 type1 相同的 map 格式
                        var body struct {
                                Success bool            `json:"success"`
                                Data    json.RawMessage `json:"data"`
                                Message string          `json:"message"`
                        }

                        if err := json.NewDecoder(limited).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "json decode failed from "+chItem.Name+": "+err.Error())
                                ch &lt;- upstreamResult{Name: uniqueName, Err: err.Error()}
                                return
                        }</span>

                        <span class="cov0" title="0">if !body.Success </span><span class="cov0" title="0">{
                                ch &lt;- upstreamResult{Name: uniqueName, Err: body.Message}
                                return
                        }</span>

                        // 若 Data 为空，将继续按 type1 尝试解析（与多数静态 ratio_config 兼容）

                        // 尝试按 type1 解析
                        <span class="cov0" title="0">var type1Data map[string]any
                        if err := json.Unmarshal(body.Data, &amp;type1Data); err == nil </span><span class="cov0" title="0">{
                                // 如果包含至少一个 ratioTypes 字段，则认为是 type1
                                isType1 := false
                                for _, rt := range ratioTypes </span><span class="cov0" title="0">{
                                        if _, ok := type1Data[rt]; ok </span><span class="cov0" title="0">{
                                                isType1 = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if isType1 </span><span class="cov0" title="0">{
                                        ch &lt;- upstreamResult{Name: uniqueName, Data: type1Data}
                                        return
                                }</span>
                        }

                        // 如果不是 type1，则尝试按 type2 (/api/pricing) 解析
                        <span class="cov0" title="0">var pricingItems []struct {
                                ModelName       string  `json:"model_name"`
                                QuotaType       int     `json:"quota_type"`
                                ModelRatio      float64 `json:"model_ratio"`
                                ModelPrice      float64 `json:"model_price"`
                                CompletionRatio float64 `json:"completion_ratio"`
                        }
                        if err := json.Unmarshal(body.Data, &amp;pricingItems); err != nil </span><span class="cov0" title="0">{
                                logger.LogWarn(c.Request.Context(), "unrecognized data format from "+chItem.Name+": "+err.Error())
                                ch &lt;- upstreamResult{Name: uniqueName, Err: "无法解析上游返回数据"}
                                return
                        }</span>

                        <span class="cov0" title="0">modelRatioMap := make(map[string]float64)
                        completionRatioMap := make(map[string]float64)
                        modelPriceMap := make(map[string]float64)

                        for _, item := range pricingItems </span><span class="cov0" title="0">{
                                if item.QuotaType == 1 </span><span class="cov0" title="0">{
                                        modelPriceMap[item.ModelName] = item.ModelPrice
                                }</span> else<span class="cov0" title="0"> {
                                        modelRatioMap[item.ModelName] = item.ModelRatio
                                        // completionRatio 可能为 0，此时也直接赋值，保持与上游一致
                                        completionRatioMap[item.ModelName] = item.CompletionRatio
                                }</span>
                        }

                        <span class="cov0" title="0">converted := make(map[string]any)

                        if len(modelRatioMap) &gt; 0 </span><span class="cov0" title="0">{
                                ratioAny := make(map[string]any, len(modelRatioMap))
                                for k, v := range modelRatioMap </span><span class="cov0" title="0">{
                                        ratioAny[k] = v
                                }</span>
                                <span class="cov0" title="0">converted["model_ratio"] = ratioAny</span>
                        }

                        <span class="cov0" title="0">if len(completionRatioMap) &gt; 0 </span><span class="cov0" title="0">{
                                compAny := make(map[string]any, len(completionRatioMap))
                                for k, v := range completionRatioMap </span><span class="cov0" title="0">{
                                        compAny[k] = v
                                }</span>
                                <span class="cov0" title="0">converted["completion_ratio"] = compAny</span>
                        }

                        <span class="cov0" title="0">if len(modelPriceMap) &gt; 0 </span><span class="cov0" title="0">{
                                priceAny := make(map[string]any, len(modelPriceMap))
                                for k, v := range modelPriceMap </span><span class="cov0" title="0">{
                                        priceAny[k] = v
                                }</span>
                                <span class="cov0" title="0">converted["model_price"] = priceAny</span>
                        }

                        <span class="cov0" title="0">ch &lt;- upstreamResult{Name: uniqueName, Data: converted}</span>
                }(chn)
        }

        <span class="cov0" title="0">wg.Wait()
        close(ch)

        localData := ratio_setting.GetExposedData()

        var testResults []dto.TestResult
        var successfulChannels []struct {
                name string
                data map[string]any
        }

        for r := range ch </span><span class="cov0" title="0">{
                if r.Err != "" </span><span class="cov0" title="0">{
                        testResults = append(testResults, dto.TestResult{
                                Name:   r.Name,
                                Status: "error",
                                Error:  r.Err,
                        })
                }</span> else<span class="cov0" title="0"> {
                        testResults = append(testResults, dto.TestResult{
                                Name:   r.Name,
                                Status: "success",
                        })
                        successfulChannels = append(successfulChannels, struct {
                                name string
                                data map[string]any
                        }{name: r.Name, data: r.Data})
                }</span>
        }

        <span class="cov0" title="0">differences := buildDifferences(localData, successfulChannels)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "differences":  differences,
                        "test_results": testResults,
                },
        })</span>
}

func buildDifferences(localData map[string]any, successfulChannels []struct {
        name string
        data map[string]any
}) map[string]map[string]dto.DifferenceItem <span class="cov0" title="0">{
        differences := make(map[string]map[string]dto.DifferenceItem)

        allModels := make(map[string]struct{})

        for _, ratioType := range ratioTypes </span><span class="cov0" title="0">{
                if localRatioAny, ok := localData[ratioType]; ok </span><span class="cov0" title="0">{
                        if localRatio, ok := localRatioAny.(map[string]float64); ok </span><span class="cov0" title="0">{
                                for modelName := range localRatio </span><span class="cov0" title="0">{
                                        allModels[modelName] = struct{}{}
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for _, channel := range successfulChannels </span><span class="cov0" title="0">{
                for _, ratioType := range ratioTypes </span><span class="cov0" title="0">{
                        if upstreamRatio, ok := channel.data[ratioType].(map[string]any); ok </span><span class="cov0" title="0">{
                                for modelName := range upstreamRatio </span><span class="cov0" title="0">{
                                        allModels[modelName] = struct{}{}
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">confidenceMap := make(map[string]map[string]bool)

        // 预处理阶段：检查pricing接口的可信度
        for _, channel := range successfulChannels </span><span class="cov0" title="0">{
                confidenceMap[channel.name] = make(map[string]bool)

                modelRatios, hasModelRatio := channel.data["model_ratio"].(map[string]any)
                completionRatios, hasCompletionRatio := channel.data["completion_ratio"].(map[string]any)

                if hasModelRatio &amp;&amp; hasCompletionRatio </span><span class="cov0" title="0">{
                        // 遍历所有模型，检查是否满足不可信条件
                        for modelName := range allModels </span><span class="cov0" title="0">{
                                // 默认为可信
                                confidenceMap[channel.name][modelName] = true

                                // 检查是否满足不可信条件：model_ratio为37.5且completion_ratio为1
                                if modelRatioVal, ok := modelRatios[modelName]; ok </span><span class="cov0" title="0">{
                                        if completionRatioVal, ok := completionRatios[modelName]; ok </span><span class="cov0" title="0">{
                                                // 转换为float64进行比较
                                                if modelRatioFloat, ok := modelRatioVal.(float64); ok </span><span class="cov0" title="0">{
                                                        if completionRatioFloat, ok := completionRatioVal.(float64); ok </span><span class="cov0" title="0">{
                                                                if modelRatioFloat == 37.5 &amp;&amp; completionRatioFloat == 1.0 </span><span class="cov0" title="0">{
                                                                        confidenceMap[channel.name][modelName] = false
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // 如果不是从pricing接口获取的数据，则全部标记为可信
                        for modelName := range allModels </span><span class="cov0" title="0">{
                                confidenceMap[channel.name][modelName] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">for modelName := range allModels </span><span class="cov0" title="0">{
                for _, ratioType := range ratioTypes </span><span class="cov0" title="0">{
                        var localValue interface{} = nil
                        if localRatioAny, ok := localData[ratioType]; ok </span><span class="cov0" title="0">{
                                if localRatio, ok := localRatioAny.(map[string]float64); ok </span><span class="cov0" title="0">{
                                        if val, exists := localRatio[modelName]; exists </span><span class="cov0" title="0">{
                                                localValue = val
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">upstreamValues := make(map[string]interface{})
                        confidenceValues := make(map[string]bool)
                        hasUpstreamValue := false
                        hasDifference := false

                        for _, channel := range successfulChannels </span><span class="cov0" title="0">{
                                var upstreamValue interface{} = nil

                                if upstreamRatio, ok := channel.data[ratioType].(map[string]any); ok </span><span class="cov0" title="0">{
                                        if val, exists := upstreamRatio[modelName]; exists </span><span class="cov0" title="0">{
                                                upstreamValue = val
                                                hasUpstreamValue = true

                                                if localValue != nil &amp;&amp; !valuesEqual(localValue, val) </span><span class="cov0" title="0">{
                                                        hasDifference = true
                                                }</span> else<span class="cov0" title="0"> if valuesEqual(localValue, val) </span><span class="cov0" title="0">{
                                                        upstreamValue = "same"
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if upstreamValue == nil &amp;&amp; localValue == nil </span><span class="cov0" title="0">{
                                        upstreamValue = "same"
                                }</span>

                                <span class="cov0" title="0">if localValue == nil &amp;&amp; upstreamValue != nil &amp;&amp; upstreamValue != "same" </span><span class="cov0" title="0">{
                                        hasDifference = true
                                }</span>

                                <span class="cov0" title="0">upstreamValues[channel.name] = upstreamValue

                                confidenceValues[channel.name] = confidenceMap[channel.name][modelName]</span>
                        }

                        <span class="cov0" title="0">shouldInclude := false

                        if localValue != nil </span><span class="cov0" title="0">{
                                if hasDifference </span><span class="cov0" title="0">{
                                        shouldInclude = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if hasUpstreamValue </span><span class="cov0" title="0">{
                                        shouldInclude = true
                                }</span>
                        }

                        <span class="cov0" title="0">if shouldInclude </span><span class="cov0" title="0">{
                                if differences[modelName] == nil </span><span class="cov0" title="0">{
                                        differences[modelName] = make(map[string]dto.DifferenceItem)
                                }</span>
                                <span class="cov0" title="0">differences[modelName][ratioType] = dto.DifferenceItem{
                                        Current:    localValue,
                                        Upstreams:  upstreamValues,
                                        Confidence: confidenceValues,
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">channelHasDiff := make(map[string]bool)
        for _, ratioMap := range differences </span><span class="cov0" title="0">{
                for _, item := range ratioMap </span><span class="cov0" title="0">{
                        for chName, val := range item.Upstreams </span><span class="cov0" title="0">{
                                if val != nil &amp;&amp; val != "same" </span><span class="cov0" title="0">{
                                        channelHasDiff[chName] = true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for modelName, ratioMap := range differences </span><span class="cov0" title="0">{
                for ratioType, item := range ratioMap </span><span class="cov0" title="0">{
                        for chName := range item.Upstreams </span><span class="cov0" title="0">{
                                if !channelHasDiff[chName] </span><span class="cov0" title="0">{
                                        delete(item.Upstreams, chName)
                                        delete(item.Confidence, chName)
                                }</span>
                        }

                        <span class="cov0" title="0">allSame := true
                        for _, v := range item.Upstreams </span><span class="cov0" title="0">{
                                if v != "same" </span><span class="cov0" title="0">{
                                        allSame = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if len(item.Upstreams) == 0 || allSame </span><span class="cov0" title="0">{
                                delete(ratioMap, ratioType)
                        }</span> else<span class="cov0" title="0"> {
                                differences[modelName][ratioType] = item
                        }</span>
                }

                <span class="cov0" title="0">if len(ratioMap) == 0 </span><span class="cov0" title="0">{
                        delete(differences, modelName)
                }</span>
        }

        <span class="cov0" title="0">return differences</span>
}

func GetSyncableChannels(c *gin.Context) <span class="cov0" title="0">{
        channels, err := model.GetAllChannels(0, 0, true, false)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">var syncableChannels []dto.SyncableChannel
        for _, channel := range channels </span><span class="cov0" title="0">{
                if channel.GetBaseURL() != "" </span><span class="cov0" title="0">{
                        syncableChannels = append(syncableChannels, dto.SyncableChannel{
                                ID:      channel.Id,
                                Name:    channel.Name,
                                BaseURL: channel.GetBaseURL(),
                                Status:  channel.Status,
                        })
                }</span>
        }

        <span class="cov0" title="0">syncableChannels = append(syncableChannels, dto.SyncableChannel{
                ID:      -100,
                Name:    "官方倍率预设",
                BaseURL: "https://basellm.github.io",
                Status:  1,
        })

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    syncableChannels,
        })</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package controller

import (
        "errors"
        "net/http"
        "strconv"
        "unicode/utf8"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

func GetAllRedemptions(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        redemptions, total, err := model.GetAllRedemptions(pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(redemptions)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func SearchRedemptions(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        pageInfo := common.GetPageQuery(c)
        redemptions, total, err := model.SearchRedemptions(keyword, pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(redemptions)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func GetRedemption(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">redemption, err := model.GetRedemptionById(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    redemption,
        })
        return</span>
}

func AddRedemption(c *gin.Context) <span class="cov0" title="0">{
        redemption := model.Redemption{}
        err := c.ShouldBindJSON(&amp;redemption)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if utf8.RuneCountInString(redemption.Name) == 0 || utf8.RuneCountInString(redemption.Name) &gt; 20 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "兑换码名称长度必须在1-20之间",
                })
                return
        }</span>
        <span class="cov0" title="0">if redemption.Count &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "兑换码个数必须大于0",
                })
                return
        }</span>
        <span class="cov0" title="0">if redemption.Count &gt; 100 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "一次兑换码批量生成的个数不能大于 100",
                })
                return
        }</span>
        <span class="cov0" title="0">if err := validateExpiredTime(redemption.ExpiredTime); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">var keys []string
        for i := 0; i &lt; redemption.Count; i++ </span><span class="cov0" title="0">{
                key := common.GetUUID()
                cleanRedemption := model.Redemption{
                        UserId:      c.GetInt("id"),
                        Name:        redemption.Name,
                        Key:         key,
                        CreatedTime: common.GetTimestamp(),
                        Quota:       redemption.Quota,
                        ExpiredTime: redemption.ExpiredTime,
                }
                err = cleanRedemption.Insert()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                                "data":    keys,
                        })
                        return
                }</span>
                <span class="cov0" title="0">keys = append(keys, key)</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    keys,
        })
        return</span>
}

func DeleteRedemption(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.Atoi(c.Param("id"))
        err := model.DeleteRedemptionById(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func UpdateRedemption(c *gin.Context) <span class="cov0" title="0">{
        statusOnly := c.Query("status_only")
        redemption := model.Redemption{}
        err := c.ShouldBindJSON(&amp;redemption)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">cleanRedemption, err := model.GetRedemptionById(redemption.Id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if statusOnly == "" </span><span class="cov0" title="0">{
                if err := validateExpiredTime(redemption.ExpiredTime); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
                        return
                }</span>
                // If you add more fields, please also update redemption.Update()
                <span class="cov0" title="0">cleanRedemption.Name = redemption.Name
                cleanRedemption.Quota = redemption.Quota
                cleanRedemption.ExpiredTime = redemption.ExpiredTime</span>
        }
        <span class="cov0" title="0">if statusOnly != "" </span><span class="cov0" title="0">{
                cleanRedemption.Status = redemption.Status
        }</span>
        <span class="cov0" title="0">err = cleanRedemption.Update()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    cleanRedemption,
        })
        return</span>
}

func DeleteInvalidRedemption(c *gin.Context) <span class="cov0" title="0">{
        rows, err := model.DeleteInvalidRedemptions()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    rows,
        })
        return</span>
}

func validateExpiredTime(expired int64) error <span class="cov0" title="0">{
        if expired != 0 &amp;&amp; expired &lt; common.GetTimestamp() </span><span class="cov0" title="0">{
                return errors.New("过期时间不能早于当前时间")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package controller

import (
        "bytes"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/middleware"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        relayconstant "github.com/QuantumNous/new-api/relay/constant"
        "github.com/QuantumNous/new-api/relay/helper"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/types"

        "github.com/bytedance/gopkg/util/gopool"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

func relayHandler(c *gin.Context, info *relaycommon.RelayInfo) *types.NewAPIError <span class="cov0" title="0">{
        var err *types.NewAPIError
        switch info.RelayMode </span>{
        case relayconstant.RelayModeImagesGenerations, relayconstant.RelayModeImagesEdits:<span class="cov0" title="0">
                err = relay.ImageHelper(c, info)</span>
        case relayconstant.RelayModeAudioSpeech:<span class="cov0" title="0">
                fallthrough</span>
        case relayconstant.RelayModeAudioTranslation:<span class="cov0" title="0">
                fallthrough</span>
        case relayconstant.RelayModeAudioTranscription:<span class="cov0" title="0">
                err = relay.AudioHelper(c, info)</span>
        case relayconstant.RelayModeRerank:<span class="cov0" title="0">
                err = relay.RerankHelper(c, info)</span>
        case relayconstant.RelayModeEmbeddings:<span class="cov0" title="0">
                err = relay.EmbeddingHelper(c, info)</span>
        case relayconstant.RelayModeResponses:<span class="cov0" title="0">
                err = relay.ResponsesHelper(c, info)</span>
        default:<span class="cov0" title="0">
                err = relay.TextHelper(c, info)</span>
        }
        <span class="cov0" title="0">return err</span>
}

func geminiRelayHandler(c *gin.Context, info *relaycommon.RelayInfo) *types.NewAPIError <span class="cov0" title="0">{
        var err *types.NewAPIError
        if strings.Contains(c.Request.URL.Path, "embed") </span><span class="cov0" title="0">{
                err = relay.GeminiEmbeddingHandler(c, info)
        }</span> else<span class="cov0" title="0"> {
                err = relay.GeminiHelper(c, info)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func Relay(c *gin.Context, relayFormat types.RelayFormat) <span class="cov0" title="0">{

        requestId := c.GetString(common.RequestIdKey)
        group := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)
        originalModel := common.GetContextKeyString(c, constant.ContextKeyOriginalModel)

        var (
                newAPIError *types.NewAPIError
                ws          *websocket.Conn
        )

        if relayFormat == types.RelayFormatOpenAIRealtime </span><span class="cov0" title="0">{
                var err error
                ws, err = upgrader.Upgrade(c.Writer, c.Request, nil)
                if err != nil </span><span class="cov0" title="0">{
                        helper.WssError(c, ws, types.NewError(err, types.ErrorCodeGetChannelFailed, types.ErrOptionWithSkipRetry()).ToOpenAIError())
                        return
                }</span>
                <span class="cov0" title="0">defer ws.Close()</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if newAPIError != nil </span><span class="cov0" title="0">{
                        logger.LogError(c, fmt.Sprintf("relay error: %s", newAPIError.Error()))
                        newAPIError.SetMessage(common.MessageWithRequestId(newAPIError.Error(), requestId))
                        switch relayFormat </span>{
                        case types.RelayFormatOpenAIRealtime:<span class="cov0" title="0">
                                helper.WssError(c, ws, newAPIError.ToOpenAIError())</span>
                        case types.RelayFormatClaude:<span class="cov0" title="0">
                                c.JSON(newAPIError.StatusCode, gin.H{
                                        "type":  "error",
                                        "error": newAPIError.ToClaudeError(),
                                })</span>
                        default:<span class="cov0" title="0">
                                c.JSON(newAPIError.StatusCode, gin.H{
                                        "error": newAPIError.ToOpenAIError(),
                                })</span>
                        }
                }
        }()

        <span class="cov0" title="0">request, err := helper.GetAndValidateRequest(c, relayFormat)
        if err != nil </span><span class="cov0" title="0">{
                newAPIError = types.NewError(err, types.ErrorCodeInvalidRequest)
                return
        }</span>

        <span class="cov0" title="0">relayInfo, err := relaycommon.GenRelayInfo(c, relayFormat, request, ws)
        if err != nil </span><span class="cov0" title="0">{
                newAPIError = types.NewError(err, types.ErrorCodeGenRelayInfoFailed)
                return
        }</span>

        <span class="cov0" title="0">meta := request.GetTokenCountMeta()

        if setting.ShouldCheckPromptSensitive() </span><span class="cov0" title="0">{
                contains, words := service.CheckSensitiveText(meta.CombineText)
                if contains </span><span class="cov0" title="0">{
                        logger.LogWarn(c, fmt.Sprintf("user sensitive words detected: %s", strings.Join(words, ", ")))
                        newAPIError = types.NewError(err, types.ErrorCodeSensitiveWordsDetected)
                        return
                }</span>
        }

        <span class="cov0" title="0">tokens, err := service.CountRequestToken(c, meta, relayInfo)
        if err != nil </span><span class="cov0" title="0">{
                newAPIError = types.NewError(err, types.ErrorCodeCountTokenFailed)
                return
        }</span>

        <span class="cov0" title="0">relayInfo.SetPromptTokens(tokens)

        priceData, err := helper.ModelPriceHelper(c, relayInfo, tokens, meta)
        if err != nil </span><span class="cov0" title="0">{
                newAPIError = types.NewError(err, types.ErrorCodeModelPriceError)
                return
        }</span>

        // common.SetContextKey(c, constant.ContextKeyTokenCountMeta, meta)

        <span class="cov0" title="0">if priceData.FreeModel </span><span class="cov0" title="0">{
                logger.LogInfo(c, fmt.Sprintf("模型 %s 免费，跳过预扣费", relayInfo.OriginModelName))
        }</span> else<span class="cov0" title="0"> {
                newAPIError = service.PreConsumeQuota(c, priceData.QuotaToPreConsume, relayInfo)
                if newAPIError != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // Only return quota if downstream failed and quota was actually pre-consumed
                if newAPIError != nil &amp;&amp; relayInfo.FinalPreConsumedQuota != 0 </span><span class="cov0" title="0">{
                        service.ReturnPreConsumedQuota(c, relayInfo)
                }</span>
        }()

        <span class="cov0" title="0">for i := 0; i &lt;= common.RetryTimes; i++ </span><span class="cov0" title="0">{
                channel, err := getChannel(c, group, originalModel, i)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(c, err.Error())
                        newAPIError = err
                        break</span>
                }

                <span class="cov0" title="0">addUsedChannel(c, channel.Id)
                requestBody, _ := common.GetRequestBody(c)
                c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))

                switch relayFormat </span>{
                case types.RelayFormatOpenAIRealtime:<span class="cov0" title="0">
                        newAPIError = relay.WssHelper(c, relayInfo)</span>
                case types.RelayFormatClaude:<span class="cov0" title="0">
                        newAPIError = relay.ClaudeHelper(c, relayInfo)</span>
                case types.RelayFormatGemini:<span class="cov0" title="0">
                        newAPIError = geminiRelayHandler(c, relayInfo)</span>
                default:<span class="cov0" title="0">
                        newAPIError = relayHandler(c, relayInfo)</span>
                }

                <span class="cov0" title="0">if newAPIError == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">processChannelError(c, *types.NewChannelError(channel.Id, channel.Type, channel.Name, channel.ChannelInfo.IsMultiKey, common.GetContextKeyString(c, constant.ContextKeyChannelKey), channel.GetAutoBan()), newAPIError)

                if !shouldRetry(c, newAPIError, common.RetryTimes-i) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">useChannel := c.GetStringSlice("use_channel")
        if len(useChannel) &gt; 1 </span><span class="cov0" title="0">{
                retryLogStr := fmt.Sprintf("重试：%s", strings.Trim(strings.Join(strings.Fields(fmt.Sprint(useChannel)), "-&gt;"), "[]"))
                logger.LogInfo(c, retryLogStr)
        }</span>
}

var upgrader = websocket.Upgrader{
        Subprotocols: []string{"realtime"}, // WS 握手支持的协议，如果有使用 Sec-WebSocket-Protocol，则必须在此声明对应的 Protocol TODO add other protocol
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // 允许跨域
        }</span>,
}

func addUsedChannel(c *gin.Context, channelId int) <span class="cov0" title="0">{
        useChannel := c.GetStringSlice("use_channel")
        useChannel = append(useChannel, fmt.Sprintf("%d", channelId))
        c.Set("use_channel", useChannel)
}</span>

func getChannel(c *gin.Context, group, originalModel string, retryCount int) (*model.Channel, *types.NewAPIError) <span class="cov0" title="0">{
        if retryCount == 0 </span><span class="cov0" title="0">{
                autoBan := c.GetBool("auto_ban")
                autoBanInt := 1
                if !autoBan </span><span class="cov0" title="0">{
                        autoBanInt = 0
                }</span>
                <span class="cov0" title="0">return &amp;model.Channel{
                        Id:      c.GetInt("channel_id"),
                        Type:    c.GetInt("channel_type"),
                        Name:    c.GetString("channel_name"),
                        AutoBan: &amp;autoBanInt,
                }, nil</span>
        }
        <span class="cov0" title="0">channel, selectGroup, err := service.CacheGetRandomSatisfiedChannel(c, group, originalModel, retryCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, types.NewError(fmt.Errorf("获取分组 %s 下模型 %s 的可用渠道失败（retry）: %s", selectGroup, originalModel, err.Error()), types.ErrorCodeGetChannelFailed, types.ErrOptionWithSkipRetry())
        }</span>
        <span class="cov0" title="0">if channel == nil </span><span class="cov0" title="0">{
                return nil, types.NewError(fmt.Errorf("分组 %s 下模型 %s 的可用渠道不存在（retry）", selectGroup, originalModel), types.ErrorCodeGetChannelFailed, types.ErrOptionWithSkipRetry())
        }</span>
        <span class="cov0" title="0">newAPIError := middleware.SetupContextForSelectedChannel(c, channel, originalModel)
        if newAPIError != nil </span><span class="cov0" title="0">{
                return nil, newAPIError
        }</span>
        <span class="cov0" title="0">return channel, nil</span>
}

func shouldRetry(c *gin.Context, openaiErr *types.NewAPIError, retryTimes int) bool <span class="cov0" title="0">{
        if openaiErr == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if types.IsChannelError(openaiErr) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if types.IsSkipRetryError(openaiErr) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if retryTimes &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if _, ok := c.Get("specific_channel_id"); ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if openaiErr.StatusCode == http.StatusTooManyRequests </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if openaiErr.StatusCode == 307 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if openaiErr.StatusCode/100 == 5 </span><span class="cov0" title="0">{
                // 超时不重试
                if openaiErr.StatusCode == 504 || openaiErr.StatusCode == 524 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">if openaiErr.StatusCode == http.StatusBadRequest </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if openaiErr.StatusCode == 408 </span><span class="cov0" title="0">{
                // azure处理超时不重试
                return false
        }</span>
        <span class="cov0" title="0">if openaiErr.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func processChannelError(c *gin.Context, channelError types.ChannelError, err *types.NewAPIError) <span class="cov0" title="0">{
        logger.LogError(c, fmt.Sprintf("channel error (channel #%d, status code: %d): %s", channelError.ChannelId, err.StatusCode, err.Error()))
        // 不要使用context获取渠道信息，异步处理时可能会出现渠道信息不一致的情况
        // do not use context to get channel info, there may be inconsistent channel info when processing asynchronously
        if service.ShouldDisableChannel(channelError.ChannelId, err) &amp;&amp; channelError.AutoBan </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        service.DisableChannel(channelError, err.Error())
                }</span>)
        }

        <span class="cov0" title="0">if constant.ErrorLogEnabled &amp;&amp; types.IsRecordErrorLog(err) </span><span class="cov0" title="0">{
                // 保存错误日志到mysql中
                userId := c.GetInt("id")
                tokenName := c.GetString("token_name")
                modelName := c.GetString("original_model")
                tokenId := c.GetInt("token_id")
                userGroup := c.GetString("group")
                channelId := c.GetInt("channel_id")
                other := make(map[string]interface{})
                if c.Request != nil &amp;&amp; c.Request.URL != nil </span><span class="cov0" title="0">{
                        other["request_path"] = c.Request.URL.Path
                }</span>
                <span class="cov0" title="0">other["error_type"] = err.GetErrorType()
                other["error_code"] = err.GetErrorCode()
                other["status_code"] = err.StatusCode
                other["channel_id"] = channelId
                other["channel_name"] = c.GetString("channel_name")
                other["channel_type"] = c.GetInt("channel_type")
                adminInfo := make(map[string]interface{})
                adminInfo["use_channel"] = c.GetStringSlice("use_channel")
                isMultiKey := common.GetContextKeyBool(c, constant.ContextKeyChannelIsMultiKey)
                if isMultiKey </span><span class="cov0" title="0">{
                        adminInfo["is_multi_key"] = true
                        adminInfo["multi_key_index"] = common.GetContextKeyInt(c, constant.ContextKeyChannelMultiKeyIndex)
                }</span>
                <span class="cov0" title="0">other["admin_info"] = adminInfo
                model.RecordErrorLog(c, userId, channelId, modelName, tokenName, err.MaskSensitiveError(), tokenId, 0, false, userGroup, other)</span>
        }

}

func RelayMidjourney(c *gin.Context) <span class="cov0" title="0">{
        relayInfo, err := relaycommon.GenRelayInfo(c, types.RelayFormatMjProxy, nil, nil)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "description": fmt.Sprintf("failed to generate relay info: %s", err.Error()),
                        "type":        "upstream_error",
                        "code":        4,
                })
                return
        }</span>

        <span class="cov0" title="0">var mjErr *dto.MidjourneyResponse
        switch relayInfo.RelayMode </span>{
        case relayconstant.RelayModeMidjourneyNotify:<span class="cov0" title="0">
                mjErr = relay.RelayMidjourneyNotify(c)</span>
        case relayconstant.RelayModeMidjourneyTaskFetch, relayconstant.RelayModeMidjourneyTaskFetchByCondition:<span class="cov0" title="0">
                mjErr = relay.RelayMidjourneyTask(c, relayInfo.RelayMode)</span>
        case relayconstant.RelayModeMidjourneyTaskImageSeed:<span class="cov0" title="0">
                mjErr = relay.RelayMidjourneyTaskImageSeed(c)</span>
        case relayconstant.RelayModeSwapFace:<span class="cov0" title="0">
                mjErr = relay.RelaySwapFace(c, relayInfo)</span>
        default:<span class="cov0" title="0">
                mjErr = relay.RelayMidjourneySubmit(c, relayInfo)</span>
        }
        //err = relayMidjourneySubmit(c, relayMode)
        <span class="cov0" title="0">log.Println(mjErr)
        if mjErr != nil </span><span class="cov0" title="0">{
                statusCode := http.StatusBadRequest
                if mjErr.Code == 30 </span><span class="cov0" title="0">{
                        mjErr.Result = "当前分组负载已饱和，请稍后再试，或升级账户以提升服务质量。"
                        statusCode = http.StatusTooManyRequests
                }</span>
                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "description": fmt.Sprintf("%s %s", mjErr.Description, mjErr.Result),
                        "type":        "upstream_error",
                        "code":        mjErr.Code,
                })
                channelId := c.GetInt("channel_id")
                logger.LogError(c, fmt.Sprintf("relay error (channel #%d, status code %d): %s", channelId, statusCode, fmt.Sprintf("%s %s", mjErr.Description, mjErr.Result)))</span>
        }
}

func RelayNotImplemented(c *gin.Context) <span class="cov0" title="0">{
        err := dto.OpenAIError{
                Message: "API not implemented",
                Type:    "new_api_error",
                Param:   "",
                Code:    "api_not_implemented",
        }
        c.JSON(http.StatusNotImplemented, gin.H{
                "error": err,
        })
}</span>

func RelayNotFound(c *gin.Context) <span class="cov0" title="0">{
        err := dto.OpenAIError{
                Message: fmt.Sprintf("Invalid URL (%s %s)", c.Request.Method, c.Request.URL.Path),
                Type:    "invalid_request_error",
                Param:   "",
                Code:    "",
        }
        c.JSON(http.StatusNotFound, gin.H{
                "error": err,
        })
}</span>

func RelayTask(c *gin.Context) <span class="cov0" title="0">{
        retryTimes := common.RetryTimes
        channelId := c.GetInt("channel_id")
        group := c.GetString("group")
        originalModel := c.GetString("original_model")
        c.Set("use_channel", []string{fmt.Sprintf("%d", channelId)})
        relayInfo, err := relaycommon.GenRelayInfo(c, types.RelayFormatTask, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">taskErr := taskRelayHandler(c, relayInfo)
        if taskErr == nil </span><span class="cov0" title="0">{
                retryTimes = 0
        }</span>
        <span class="cov0" title="0">for i := 0; shouldRetryTaskRelay(c, channelId, taskErr, retryTimes) &amp;&amp; i &lt; retryTimes; i++ </span><span class="cov0" title="0">{
                channel, newAPIError := getChannel(c, group, originalModel, i)
                if newAPIError != nil </span><span class="cov0" title="0">{
                        logger.LogError(c, fmt.Sprintf("CacheGetRandomSatisfiedChannel failed: %s", newAPIError.Error()))
                        taskErr = service.TaskErrorWrapperLocal(newAPIError.Err, "get_channel_failed", http.StatusInternalServerError)
                        break</span>
                }
                <span class="cov0" title="0">channelId = channel.Id
                useChannel := c.GetStringSlice("use_channel")
                useChannel = append(useChannel, fmt.Sprintf("%d", channelId))
                c.Set("use_channel", useChannel)
                logger.LogInfo(c, fmt.Sprintf("using channel #%d to retry (remain times %d)", channel.Id, i))
                //middleware.SetupContextForSelectedChannel(c, channel, originalModel)

                requestBody, _ := common.GetRequestBody(c)
                c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
                taskErr = taskRelayHandler(c, relayInfo)</span>
        }
        <span class="cov0" title="0">useChannel := c.GetStringSlice("use_channel")
        if len(useChannel) &gt; 1 </span><span class="cov0" title="0">{
                retryLogStr := fmt.Sprintf("重试：%s", strings.Trim(strings.Join(strings.Fields(fmt.Sprint(useChannel)), "-&gt;"), "[]"))
                logger.LogInfo(c, retryLogStr)
        }</span>
        <span class="cov0" title="0">if taskErr != nil </span><span class="cov0" title="0">{
                if taskErr.StatusCode == http.StatusTooManyRequests </span><span class="cov0" title="0">{
                        taskErr.Message = "当前分组上游负载已饱和，请稍后再试"
                }</span>
                <span class="cov0" title="0">c.JSON(taskErr.StatusCode, taskErr)</span>
        }
}

func taskRelayHandler(c *gin.Context, relayInfo *relaycommon.RelayInfo) *dto.TaskError <span class="cov0" title="0">{
        var err *dto.TaskError
        switch relayInfo.RelayMode </span>{
        case relayconstant.RelayModeSunoFetch, relayconstant.RelayModeSunoFetchByID, relayconstant.RelayModeVideoFetchByID:<span class="cov0" title="0">
                err = relay.RelayTaskFetch(c, relayInfo.RelayMode)</span>
        default:<span class="cov0" title="0">
                err = relay.RelayTaskSubmit(c, relayInfo)</span>
        }
        <span class="cov0" title="0">return err</span>
}

func shouldRetryTaskRelay(c *gin.Context, channelId int, taskErr *dto.TaskError, retryTimes int) bool <span class="cov0" title="0">{
        if taskErr == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if retryTimes &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if _, ok := c.Get("specific_channel_id"); ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if taskErr.StatusCode == http.StatusTooManyRequests </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if taskErr.StatusCode == 307 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if taskErr.StatusCode/100 == 5 </span><span class="cov0" title="0">{
                // 超时不重试
                if taskErr.StatusCode == 504 || taskErr.StatusCode == 524 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">if taskErr.StatusCode == http.StatusBadRequest </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if taskErr.StatusCode == 408 </span><span class="cov0" title="0">{
                // azure处理超时不重试
                return false
        }</span>
        <span class="cov0" title="0">if taskErr.LocalError </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if taskErr.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        passkeysvc "github.com/QuantumNous/new-api/service/passkey"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

const (
        // SecureVerificationSessionKey 安全验证的 session key
        SecureVerificationSessionKey = "secure_verified_at"
        // SecureVerificationTimeout 验证有效期（秒）
        SecureVerificationTimeout = 300 // 5分钟
)

type UniversalVerifyRequest struct {
        Method string `json:"method"` // "2fa" 或 "passkey"
        Code   string `json:"code,omitempty"`
}

type VerificationStatusResponse struct {
        Verified  bool  `json:"verified"`
        ExpiresAt int64 `json:"expires_at,omitempty"`
}

// UniversalVerify 通用验证接口
// 支持 2FA 和 Passkey 验证，验证成功后在 session 中记录时间戳
func UniversalVerify(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        if userId == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": "未登录",
                })
                return
        }</span>

        <span class="cov0" title="0">var req UniversalVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("参数错误: %v", err))
                return
        }</span>

        // 获取用户信息
        <span class="cov0" title="0">user := &amp;model.User{Id: userId}
        if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("获取用户信息失败: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("该用户已被禁用"))
                return
        }</span>

        // 检查用户的验证方式
        <span class="cov0" title="0">twoFA, _ := model.GetTwoFAByUserId(userId)
        has2FA := twoFA != nil &amp;&amp; twoFA.IsEnabled

        passkey, passkeyErr := model.GetPasskeyByUserID(userId)
        hasPasskey := passkeyErr == nil &amp;&amp; passkey != nil

        if !has2FA &amp;&amp; !hasPasskey </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("用户未启用2FA或Passkey"))
                return
        }</span>

        // 根据验证方式进行验证
        <span class="cov0" title="0">var verified bool
        var verifyMethod string

        switch req.Method </span>{
        case "2fa":<span class="cov0" title="0">
                if !has2FA </span><span class="cov0" title="0">{
                        common.ApiError(c, fmt.Errorf("用户未启用2FA"))
                        return
                }</span>
                <span class="cov0" title="0">if req.Code == "" </span><span class="cov0" title="0">{
                        common.ApiError(c, fmt.Errorf("验证码不能为空"))
                        return
                }</span>
                <span class="cov0" title="0">verified = validateTwoFactorAuth(twoFA, req.Code)
                verifyMethod = "2FA"</span>

        case "passkey":<span class="cov0" title="0">
                if !hasPasskey </span><span class="cov0" title="0">{
                        common.ApiError(c, fmt.Errorf("用户未启用Passkey"))
                        return
                }</span>
                // Passkey 验证需要先调用 PasskeyVerifyBegin 和 PasskeyVerifyFinish
                // 这里只是验证 Passkey 验证流程是否已经完成
                // 实际上，前端应该先调用这两个接口，然后再调用本接口
                <span class="cov0" title="0">verified = true // Passkey 验证逻辑已在 PasskeyVerifyFinish 中完成
                verifyMethod = "Passkey"</span>

        default:<span class="cov0" title="0">
                common.ApiError(c, fmt.Errorf("不支持的验证方式: %s", req.Method))
                return</span>
        }

        <span class="cov0" title="0">if !verified </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("验证失败，请检查验证码"))
                return
        }</span>

        // 验证成功，在 session 中记录时间戳
        <span class="cov0" title="0">session := sessions.Default(c)
        now := time.Now().Unix()
        session.Set(SecureVerificationSessionKey, now)
        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("保存验证状态失败: %v", err))
                return
        }</span>

        // 记录日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, fmt.Sprintf("通用安全验证成功 (验证方式: %s)", verifyMethod))

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "验证成功",
                "data": gin.H{
                        "verified":   true,
                        "expires_at": now + SecureVerificationTimeout,
                },
        })</span>
}

// GetVerificationStatus 获取验证状态
func GetVerificationStatus(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        if userId == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": "未登录",
                })
                return
        }</span>

        <span class="cov0" title="0">session := sessions.Default(c)
        verifiedAtRaw := session.Get(SecureVerificationSessionKey)

        if verifiedAtRaw == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                        "data": VerificationStatusResponse{
                                Verified: false,
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">verifiedAt, ok := verifiedAtRaw.(int64)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                        "data": VerificationStatusResponse{
                                Verified: false,
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">elapsed := time.Now().Unix() - verifiedAt
        if elapsed &gt;= SecureVerificationTimeout </span><span class="cov0" title="0">{
                // 验证已过期
                session.Delete(SecureVerificationSessionKey)
                _ = session.Save()
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                        "data": VerificationStatusResponse{
                                Verified: false,
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data": VerificationStatusResponse{
                        Verified:  true,
                        ExpiresAt: verifiedAt + SecureVerificationTimeout,
                },
        })</span>
}

// CheckSecureVerification 检查是否已通过安全验证
// 返回 true 表示验证有效，false 表示需要重新验证
func CheckSecureVerification(c *gin.Context) bool <span class="cov0" title="0">{
        session := sessions.Default(c)
        verifiedAtRaw := session.Get(SecureVerificationSessionKey)

        if verifiedAtRaw == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">verifiedAt, ok := verifiedAtRaw.(int64)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">elapsed := time.Now().Unix() - verifiedAt
        if elapsed &gt;= SecureVerificationTimeout </span><span class="cov0" title="0">{
                // 验证已过期，清除 session
                session.Delete(SecureVerificationSessionKey)
                _ = session.Save()
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// PasskeyVerifyAndSetSession Passkey 验证完成后设置 session
// 这是一个辅助函数，供 PasskeyVerifyFinish 调用
func PasskeyVerifyAndSetSession(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        now := time.Now().Unix()
        session.Set(SecureVerificationSessionKey, now)
        _ = session.Save()
}</span>

// PasskeyVerifyForSecure 用于安全验证的 Passkey 验证流程
// 整合了 begin 和 finish 流程
func PasskeyVerifyForSecure(c *gin.Context) <span class="cov0" title="0">{
        if !system_setting.GetPasskeySettings().Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "管理员未启用 Passkey 登录",
                })
                return
        }</span>

        <span class="cov0" title="0">userId := c.GetInt("id")
        if userId == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": "未登录",
                })
                return
        }</span>

        <span class="cov0" title="0">user := &amp;model.User{Id: userId}
        if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("获取用户信息失败: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                common.ApiError(c, fmt.Errorf("该用户已被禁用"))
                return
        }</span>

        <span class="cov0" title="0">credential, err := model.GetPasskeyByUserID(userId)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该用户尚未绑定 Passkey",
                })
                return
        }</span>

        <span class="cov0" title="0">wa, err := passkeysvc.BuildWebAuthn(c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">waUser := passkeysvc.NewWebAuthnUser(user, credential)
        sessionData, err := passkeysvc.PopSessionData(c, passkeysvc.VerifySessionKey)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">_, err = wa.FinishLogin(waUser, *sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 更新凭证的最后使用时间
        <span class="cov0" title="0">now := time.Now()
        credential.LastUsedAt = &amp;now
        if err := model.UpsertPasskeyCredential(credential); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 验证成功，设置 session
        <span class="cov0" title="0">PasskeyVerifyAndSetSession(c)

        // 记录日志
        model.RecordLog(userId, model.LogTypeSystem, "Passkey 安全验证成功")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Passkey 验证成功",
                "data": gin.H{
                        "verified":   true,
                        "expires_at": time.Now().Unix() + SecureVerificationTimeout,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package controller

import (
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/gin-gonic/gin"
)

type Setup struct {
        Status       bool   `json:"status"`
        RootInit     bool   `json:"root_init"`
        DatabaseType string `json:"database_type"`
}

type SetupRequest struct {
        Username           string `json:"username"`
        Password           string `json:"password"`
        ConfirmPassword    string `json:"confirmPassword"`
        SelfUseModeEnabled bool   `json:"SelfUseModeEnabled"`
        DemoSiteEnabled    bool   `json:"DemoSiteEnabled"`
}

func GetSetup(c *gin.Context) <span class="cov0" title="0">{
        setup := Setup{
                Status: constant.Setup,
        }
        if constant.Setup </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": true,
                        "data":    setup,
                })
                return
        }</span>
        <span class="cov0" title="0">setup.RootInit = model.RootUserExists()
        if common.UsingMySQL </span><span class="cov0" title="0">{
                setup.DatabaseType = "mysql"
        }</span>
        <span class="cov0" title="0">if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                setup.DatabaseType = "postgres"
        }</span>
        <span class="cov0" title="0">if common.UsingSQLite </span><span class="cov0" title="0">{
                setup.DatabaseType = "sqlite"
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{
                "success": true,
                "data":    setup,
        })</span>
}

func PostSetup(c *gin.Context) <span class="cov0" title="0">{
        // Check if setup is already completed
        if constant.Setup </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": "系统已经初始化完成",
                })
                return
        }</span>

        // Check if root user already exists
        <span class="cov0" title="0">rootExists := model.RootUserExists()

        var req SetupRequest
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": "请求参数有误",
                })
                return
        }</span>

        // If root doesn't exist, validate and create admin account
        <span class="cov0" title="0">if !rootExists </span><span class="cov0" title="0">{
                // Validate username length: max 12 characters to align with model.User validation
                if len(req.Username) &gt; 12 </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "success": false,
                                "message": "用户名长度不能超过12个字符",
                        })
                        return
                }</span>
                // Validate password
                <span class="cov0" title="0">if req.Password != req.ConfirmPassword </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "success": false,
                                "message": "两次输入的密码不一致",
                        })
                        return
                }</span>

                <span class="cov0" title="0">if len(req.Password) &lt; 8 </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "success": false,
                                "message": "密码长度至少为8个字符",
                        })
                        return
                }</span>

                // Create root user
                <span class="cov0" title="0">hashedPassword, err := common.Password2Hash(req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "success": false,
                                "message": "系统错误: " + err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">rootUser := model.User{
                        Username:    req.Username,
                        Password:    hashedPassword,
                        Role:        common.RoleRootUser,
                        Status:      common.UserStatusEnabled,
                        DisplayName: "Root User",
                        AccessToken: nil,
                        Quota:       100000000,
                }
                err = model.DB.Create(&amp;rootUser).Error
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "success": false,
                                "message": "创建管理员账号失败: " + err.Error(),
                        })
                        return
                }</span>
        }

        // Set operation modes
        <span class="cov0" title="0">operation_setting.SelfUseModeEnabled = req.SelfUseModeEnabled
        operation_setting.DemoSiteEnabled = req.DemoSiteEnabled

        // Save operation modes to database for persistence
        err = model.UpdateOption("SelfUseModeEnabled", boolToString(req.SelfUseModeEnabled))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": "保存自用模式设置失败: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">err = model.UpdateOption("DemoSiteEnabled", boolToString(req.DemoSiteEnabled))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": "保存演示站点模式设置失败: " + err.Error(),
                })
                return
        }</span>

        // Update setup status
        <span class="cov0" title="0">constant.Setup = true

        setup := model.Setup{
                Version:       common.Version,
                InitializedAt: time.Now().Unix(),
        }
        err = model.DB.Create(&amp;setup).Error
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "success": false,
                        "message": "系统初始化失败: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, gin.H{
                "success": true,
                "message": "系统初始化成功",
        })</span>
}

func boolToString(b bool) string <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return "true"
        }</span>
        <span class="cov0" title="0">return "false"</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
)

// VideoGenerations
// @Summary 生成视频
// @Description 调用视频生成接口生成视频
// @Description 支持多种视频生成服务：
// @Description - 可灵AI (Kling): https://app.klingai.com/cn/dev/document-api/apiReference/commonInfo
// @Description - 即梦 (Jimeng): https://www.volcengine.com/docs/85621/1538636
// @Tags Video
// @Accept json
// @Produce json
// @Param Authorization header string true "用户认证令牌 (Aeess-Token: sk-xxxx)"
// @Param request body dto.VideoRequest true "视频生成请求参数"
// @Failure 400 {object} dto.OpenAIError "请求参数错误"
// @Failure 401 {object} dto.OpenAIError "未授权"
// @Failure 403 {object} dto.OpenAIError "无权限"
// @Failure 500 {object} dto.OpenAIError "服务器内部错误"
// @Router /v1/video/generations [post]
func VideoGenerations(c *gin.Context) {<span class="cov0" title="0">
}</span>

// VideoGenerationsTaskId
// @Summary 查询视频
// @Description 根据任务ID查询视频生成任务的状态和结果
// @Tags Video
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param task_id path string true "Task ID"
// @Success 200 {object} dto.VideoTaskResponse "任务状态和结果"
// @Failure 400 {object} dto.OpenAIError "请求参数错误"
// @Failure 401 {object} dto.OpenAIError "未授权"
// @Failure 403 {object} dto.OpenAIError "无权限"
// @Failure 500 {object} dto.OpenAIError "服务器内部错误"
// @Router /v1/video/generations/{task_id} [get]
func VideoGenerationsTaskId(c *gin.Context) {<span class="cov0" title="0">
}</span>

// KlingText2VideoGenerations
// @Summary 可灵文生视频
// @Description 调用可灵AI文生视频接口，生成视频内容
// @Tags Video
// @Accept json
// @Produce json
// @Param Authorization header string true "用户认证令牌 (Aeess-Token: sk-xxxx)"
// @Param request body KlingText2VideoRequest true "视频生成请求参数"
// @Success 200 {object} dto.VideoTaskResponse "任务状态和结果"
// @Failure 400 {object} dto.OpenAIError "请求参数错误"
// @Failure 401 {object} dto.OpenAIError "未授权"
// @Failure 403 {object} dto.OpenAIError "无权限"
// @Failure 500 {object} dto.OpenAIError "服务器内部错误"
// @Router /kling/v1/videos/text2video [post]
func KlingText2VideoGenerations(c *gin.Context) {<span class="cov0" title="0">
}</span>

type KlingText2VideoRequest struct {
        ModelName      string              `json:"model_name,omitempty" example:"kling-v1"`
        Prompt         string              `json:"prompt" binding:"required" example:"A cat playing piano in the garden"`
        NegativePrompt string              `json:"negative_prompt,omitempty" example:"blurry, low quality"`
        CfgScale       float64             `json:"cfg_scale,omitempty" example:"0.7"`
        Mode           string              `json:"mode,omitempty" example:"std"`
        CameraControl  *KlingCameraControl `json:"camera_control,omitempty"`
        AspectRatio    string              `json:"aspect_ratio,omitempty" example:"16:9"`
        Duration       string              `json:"duration,omitempty" example:"5"`
        CallbackURL    string              `json:"callback_url,omitempty" example:"https://your.domain/callback"`
        ExternalTaskId string              `json:"external_task_id,omitempty" example:"custom-task-001"`
}

type KlingCameraControl struct {
        Type   string             `json:"type,omitempty" example:"simple"`
        Config *KlingCameraConfig `json:"config,omitempty"`
}

type KlingCameraConfig struct {
        Horizontal float64 `json:"horizontal,omitempty" example:"2.5"`
        Vertical   float64 `json:"vertical,omitempty" example:"0"`
        Pan        float64 `json:"pan,omitempty" example:"0"`
        Tilt       float64 `json:"tilt,omitempty" example:"0"`
        Roll       float64 `json:"roll,omitempty" example:"0"`
        Zoom       float64 `json:"zoom,omitempty" example:"0"`
}

// KlingImage2VideoGenerations
// @Summary 可灵官方-图生视频
// @Description 调用可灵AI图生视频接口，生成视频内容
// @Tags Video
// @Accept json
// @Produce json
// @Param Authorization header string true "用户认证令牌 (Aeess-Token: sk-xxxx)"
// @Param request body KlingImage2VideoRequest true "图生视频请求参数"
// @Success 200 {object} dto.VideoTaskResponse "任务状态和结果"
// @Failure 400 {object} dto.OpenAIError "请求参数错误"
// @Failure 401 {object} dto.OpenAIError "未授权"
// @Failure 403 {object} dto.OpenAIError "无权限"
// @Failure 500 {object} dto.OpenAIError "服务器内部错误"
// @Router /kling/v1/videos/image2video [post]
func KlingImage2VideoGenerations(c *gin.Context) {<span class="cov0" title="0">
}</span>

type KlingImage2VideoRequest struct {
        ModelName      string              `json:"model_name,omitempty" example:"kling-v2-master"`
        Image          string              `json:"image" binding:"required" example:"https://h2.inkwai.com/bs2/upload-ylab-stunt/se/ai_portal_queue_mmu_image_upscale_aiweb/3214b798-e1b4-4b00-b7af-72b5b0417420_raw_image_0.jpg"`
        Prompt         string              `json:"prompt,omitempty" example:"A cat playing piano in the garden"`
        NegativePrompt string              `json:"negative_prompt,omitempty" example:"blurry, low quality"`
        CfgScale       float64             `json:"cfg_scale,omitempty" example:"0.7"`
        Mode           string              `json:"mode,omitempty" example:"std"`
        CameraControl  *KlingCameraControl `json:"camera_control,omitempty"`
        AspectRatio    string              `json:"aspect_ratio,omitempty" example:"16:9"`
        Duration       string              `json:"duration,omitempty" example:"5"`
        CallbackURL    string              `json:"callback_url,omitempty" example:"https://your.domain/callback"`
        ExternalTaskId string              `json:"external_task_id,omitempty" example:"custom-task-002"`
}

// KlingImage2videoTaskId godoc
// @Summary 可灵任务查询--图生视频
// @Description Query the status and result of a Kling video generation task by task ID
// @Tags Origin
// @Accept json
// @Produce json
// @Param task_id path string true "Task ID"
// @Router /kling/v1/videos/image2video/{task_id} [get]
func KlingImage2videoTaskId(c *gin.Context) {<span class="cov0" title="0">}</span>

// KlingText2videoTaskId godoc
// @Summary 可灵任务查询--文生视频
// @Description Query the status and result of a Kling text-to-video generation task by task ID
// @Tags Origin
// @Accept json
// @Produce json
// @Param task_id path string true "Task ID"
// @Router /kling/v1/videos/text2video/{task_id} [get]
func KlingText2videoTaskId(c *gin.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "sort"
        "strconv"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"

        "github.com/gin-gonic/gin"
        "github.com/samber/lo"
)

func UpdateTaskBulk() <span class="cov0" title="0">{
        //revocer
        //imageModel := "midjourney"
        for </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(15) * time.Second)
                common.SysLog("任务进度轮询开始")
                ctx := context.TODO()
                allTasks := model.GetAllUnFinishSyncTasks(500)
                platformTask := make(map[constant.TaskPlatform][]*model.Task)
                for _, t := range allTasks </span><span class="cov0" title="0">{
                        platformTask[t.Platform] = append(platformTask[t.Platform], t)
                }</span>
                <span class="cov0" title="0">for platform, tasks := range platformTask </span><span class="cov0" title="0">{
                        if len(tasks) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">taskChannelM := make(map[int][]string)
                        taskM := make(map[string]*model.Task)
                        nullTaskIds := make([]int64, 0)
                        for _, task := range tasks </span><span class="cov0" title="0">{
                                if task.TaskID == "" </span><span class="cov0" title="0">{
                                        // 统计失败的未完成任务
                                        nullTaskIds = append(nullTaskIds, task.ID)
                                        continue</span>
                                }
                                <span class="cov0" title="0">taskM[task.TaskID] = task
                                taskChannelM[task.ChannelId] = append(taskChannelM[task.ChannelId], task.TaskID)</span>
                        }
                        <span class="cov0" title="0">if len(nullTaskIds) &gt; 0 </span><span class="cov0" title="0">{
                                err := model.TaskBulkUpdateByID(nullTaskIds, map[string]any{
                                        "status":   "FAILURE",
                                        "progress": "100%",
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.LogError(ctx, fmt.Sprintf("Fix null task_id task error: %v", err))
                                }</span> else<span class="cov0" title="0"> {
                                        logger.LogInfo(ctx, fmt.Sprintf("Fix null task_id task success: %v", nullTaskIds))
                                }</span>
                        }
                        <span class="cov0" title="0">if len(taskChannelM) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">UpdateTaskByPlatform(platform, taskChannelM, taskM)</span>
                }
                <span class="cov0" title="0">common.SysLog("任务进度轮询完成")</span>
        }
}

func UpdateTaskByPlatform(platform constant.TaskPlatform, taskChannelM map[int][]string, taskM map[string]*model.Task) <span class="cov0" title="0">{
        switch platform </span>{
        case constant.TaskPlatformMidjourney:<span class="cov0" title="0"></span>
                //_ = UpdateMidjourneyTaskAll(context.Background(), tasks)
        case constant.TaskPlatformSuno:<span class="cov0" title="0">
                _ = UpdateSunoTaskAll(context.Background(), taskChannelM, taskM)</span>
        default:<span class="cov0" title="0">
                if err := UpdateVideoTaskAll(context.Background(), platform, taskChannelM, taskM); err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("UpdateVideoTaskAll fail: %s", err))
                }</span>
        }
}

func UpdateSunoTaskAll(ctx context.Context, taskChannelM map[int][]string, taskM map[string]*model.Task) error <span class="cov0" title="0">{
        for channelId, taskIds := range taskChannelM </span><span class="cov0" title="0">{
                err := updateSunoTaskAll(ctx, channelId, taskIds, taskM)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(ctx, fmt.Sprintf("渠道 #%d 更新异步任务失败: %s", channelId, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func updateSunoTaskAll(ctx context.Context, channelId int, taskIds []string, taskM map[string]*model.Task) error <span class="cov0" title="0">{
        logger.LogInfo(ctx, fmt.Sprintf("渠道 #%d 未完成的任务有: %d", channelId, len(taskIds)))
        if len(taskIds) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel, err := model.CacheGetChannel(channelId)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("CacheGetChannel: %v", err))
                err = model.TaskBulkUpdate(taskIds, map[string]any{
                        "fail_reason": fmt.Sprintf("获取渠道信息失败，请联系管理员，渠道ID：%d", channelId),
                        "status":      "FAILURE",
                        "progress":    "100%",
                })
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("UpdateMidjourneyTask error2: %v", err))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">adaptor := relay.GetTaskAdaptor(constant.TaskPlatformSuno)
        if adaptor == nil </span><span class="cov0" title="0">{
                return errors.New("adaptor not found")
        }</span>
        <span class="cov0" title="0">resp, err := adaptor.FetchTask(*channel.BaseURL, channel.Key, map[string]any{
                "ids": taskIds,
        })
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("Get Task Do req error: %v", err))
                return err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                logger.LogError(ctx, fmt.Sprintf("Get Task status code: %d", resp.StatusCode))
                return errors.New(fmt.Sprintf("Get Task status code: %d", resp.StatusCode))
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        responseBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("Get Task parse body error: %v", err))
                return err
        }</span>
        <span class="cov0" title="0">var responseItems dto.TaskResponse[[]dto.SunoDataResponse]
        err = json.Unmarshal(responseBody, &amp;responseItems)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(ctx, fmt.Sprintf("Get Task parse body error2: %v, body: %s", err, string(responseBody)))
                return err
        }</span>
        <span class="cov0" title="0">if !responseItems.IsSuccess() </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("渠道 #%d 未完成的任务有: %d, 成功获取到任务数: %s", channelId, len(taskIds), string(responseBody)))
                return err
        }</span>

        <span class="cov0" title="0">for _, responseItem := range responseItems.Data </span><span class="cov0" title="0">{
                task := taskM[responseItem.TaskID]
                if !checkTaskNeedUpdate(task, responseItem) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">task.Status = lo.If(model.TaskStatus(responseItem.Status) != "", model.TaskStatus(responseItem.Status)).Else(task.Status)
                task.FailReason = lo.If(responseItem.FailReason != "", responseItem.FailReason).Else(task.FailReason)
                task.SubmitTime = lo.If(responseItem.SubmitTime != 0, responseItem.SubmitTime).Else(task.SubmitTime)
                task.StartTime = lo.If(responseItem.StartTime != 0, responseItem.StartTime).Else(task.StartTime)
                task.FinishTime = lo.If(responseItem.FinishTime != 0, responseItem.FinishTime).Else(task.FinishTime)
                if responseItem.FailReason != "" || task.Status == model.TaskStatusFailure </span><span class="cov0" title="0">{
                        logger.LogInfo(ctx, task.TaskID+" 构建失败，"+task.FailReason)
                        task.Progress = "100%"
                        //err = model.CacheUpdateUserQuota(task.UserId) ?
                        if err != nil </span><span class="cov0" title="0">{
                                logger.LogError(ctx, "error update user quota cache: "+err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                quota := task.Quota
                                if quota != 0 </span><span class="cov0" title="0">{
                                        err = model.IncreaseUserQuota(task.UserId, quota, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.LogError(ctx, "fail to increase user quota: "+err.Error())
                                        }</span>
                                        <span class="cov0" title="0">logContent := fmt.Sprintf("异步任务执行失败 %s，补偿 %s", task.TaskID, logger.LogQuota(quota))
                                        model.RecordLog(task.UserId, model.LogTypeSystem, logContent)</span>
                                }
                        }
                }
                <span class="cov0" title="0">if responseItem.Status == model.TaskStatusSuccess </span><span class="cov0" title="0">{
                        task.Progress = "100%"
                }</span>
                <span class="cov0" title="0">task.Data = responseItem.Data

                err = task.Update()
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("UpdateMidjourneyTask task error: " + err.Error())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func checkTaskNeedUpdate(oldTask *model.Task, newTask dto.SunoDataResponse) bool <span class="cov0" title="0">{

        if oldTask.SubmitTime != newTask.SubmitTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.StartTime != newTask.StartTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FinishTime != newTask.FinishTime </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if string(oldTask.Status) != newTask.Status </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FailReason != newTask.FailReason </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if oldTask.FinishTime != newTask.FinishTime </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if (oldTask.Status == model.TaskStatusFailure || oldTask.Status == model.TaskStatusSuccess) &amp;&amp; oldTask.Progress != "100%" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">oldData, _ := json.Marshal(oldTask.Data)
        newData, _ := json.Marshal(newTask.Data)

        sort.Slice(oldData, func(i, j int) bool </span><span class="cov0" title="0">{
                return oldData[i] &lt; oldData[j]
        }</span>)
        <span class="cov0" title="0">sort.Slice(newData, func(i, j int) bool </span><span class="cov0" title="0">{
                return newData[i] &lt; newData[j]
        }</span>)

        <span class="cov0" title="0">if string(oldData) != string(newData) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func GetAllTask(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)

        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        // 解析其他查询参数
        queryParams := model.SyncTaskQueryParams{
                Platform:       constant.TaskPlatform(c.Query("platform")),
                TaskID:         c.Query("task_id"),
                Status:         c.Query("status"),
                Action:         c.Query("action"),
                StartTimestamp: startTimestamp,
                EndTimestamp:   endTimestamp,
                ChannelID:      c.Query("channel_id"),
        }

        items := model.TaskGetAllTasks(pageInfo.GetStartIdx(), pageInfo.GetPageSize(), queryParams)
        total := model.TaskCountAllTasks(queryParams)
        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(items)
        common.ApiSuccess(c, pageInfo)
}</span>

func GetUserTask(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)

        userId := c.GetInt("id")

        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)

        queryParams := model.SyncTaskQueryParams{
                Platform:       constant.TaskPlatform(c.Query("platform")),
                TaskID:         c.Query("task_id"),
                Status:         c.Query("status"),
                Action:         c.Query("action"),
                StartTimestamp: startTimestamp,
                EndTimestamp:   endTimestamp,
        }

        items := model.TaskGetAllUserTask(userId, pageInfo.GetStartIdx(), pageInfo.GetPageSize(), queryParams)
        total := model.TaskCountAllUserTask(userId, queryParams)
        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(items)
        common.ApiSuccess(c, pageInfo)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"
        "github.com/QuantumNous/new-api/relay/channel"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
)

func UpdateVideoTaskAll(ctx context.Context, platform constant.TaskPlatform, taskChannelM map[int][]string, taskM map[string]*model.Task) error <span class="cov0" title="0">{
        for channelId, taskIds := range taskChannelM </span><span class="cov0" title="0">{
                if err := updateVideoTaskAll(ctx, platform, channelId, taskIds, taskM); err != nil </span><span class="cov0" title="0">{
                        logger.LogError(ctx, fmt.Sprintf("Channel #%d failed to update video async tasks: %s", channelId, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func updateVideoTaskAll(ctx context.Context, platform constant.TaskPlatform, channelId int, taskIds []string, taskM map[string]*model.Task) error <span class="cov0" title="0">{
        logger.LogInfo(ctx, fmt.Sprintf("Channel #%d pending video tasks: %d", channelId, len(taskIds)))
        if len(taskIds) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">cacheGetChannel, err := model.CacheGetChannel(channelId)
        if err != nil </span><span class="cov0" title="0">{
                errUpdate := model.TaskBulkUpdate(taskIds, map[string]any{
                        "fail_reason": fmt.Sprintf("Failed to get channel info, channel ID: %d", channelId),
                        "status":      "FAILURE",
                        "progress":    "100%",
                })
                if errUpdate != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("UpdateVideoTask error: %v", errUpdate))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("CacheGetChannel failed: %w", err)</span>
        }
        <span class="cov0" title="0">adaptor := relay.GetTaskAdaptor(platform)
        if adaptor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("video adaptor not found")
        }</span>
        <span class="cov0" title="0">info := &amp;relaycommon.RelayInfo{}
        info.ChannelMeta = &amp;relaycommon.ChannelMeta{
                ChannelBaseUrl: cacheGetChannel.GetBaseURL(),
        }
        info.ApiKey = cacheGetChannel.Key
        adaptor.Init(info)
        for _, taskId := range taskIds </span><span class="cov0" title="0">{
                if err := updateVideoSingleTask(ctx, adaptor, cacheGetChannel, taskId, taskM); err != nil </span><span class="cov0" title="0">{
                        logger.LogError(ctx, fmt.Sprintf("Failed to update video task %s: %s", taskId, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func updateVideoSingleTask(ctx context.Context, adaptor channel.TaskAdaptor, channel *model.Channel, taskId string, taskM map[string]*model.Task) error <span class="cov0" title="0">{
        baseURL := constant.ChannelBaseURLs[channel.Type]
        if channel.GetBaseURL() != "" </span><span class="cov0" title="0">{
                baseURL = channel.GetBaseURL()
        }</span>

        <span class="cov0" title="0">task := taskM[taskId]
        if task == nil </span><span class="cov0" title="0">{
                logger.LogError(ctx, fmt.Sprintf("Task %s not found in taskM", taskId))
                return fmt.Errorf("task %s not found", taskId)
        }</span>
        <span class="cov0" title="0">resp, err := adaptor.FetchTask(baseURL, channel.Key, map[string]any{
                "task_id": taskId,
                "action":  task.Action,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("fetchTask failed for task %s: %w", taskId, err)
        }</span>
        //if resp.StatusCode != http.StatusOK {
        //return fmt.Errorf("get Video Task status code: %d", resp.StatusCode)
        //}
        <span class="cov0" title="0">defer resp.Body.Close()
        responseBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("readAll failed for task %s: %w", taskId, err)
        }</span>

        <span class="cov0" title="0">logger.LogDebug(ctx, fmt.Sprintf("UpdateVideoSingleTask response: %s", string(responseBody)))

        taskResult := &amp;relaycommon.TaskInfo{}
        // try parse as New API response format
        var responseItems dto.TaskResponse[model.Task]
        if err = common.Unmarshal(responseBody, &amp;responseItems); err == nil &amp;&amp; responseItems.IsSuccess() </span><span class="cov0" title="0">{
                logger.LogDebug(ctx, fmt.Sprintf("UpdateVideoSingleTask parsed as new api response format: %+v", responseItems))
                t := responseItems.Data
                taskResult.TaskID = t.TaskID
                taskResult.Status = string(t.Status)
                taskResult.Url = t.FailReason
                taskResult.Progress = t.Progress
                taskResult.Reason = t.FailReason
                task.Data = t.Data
        }</span> else<span class="cov0" title="0"> if taskResult, err = adaptor.ParseTaskResult(responseBody); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parseTaskResult failed for task %s: %w", taskId, err)
        }</span> else<span class="cov0" title="0"> {
                task.Data = redactVideoResponseBody(responseBody)
        }</span>

        <span class="cov0" title="0">logger.LogDebug(ctx, fmt.Sprintf("UpdateVideoSingleTask taskResult: %+v", taskResult))

        now := time.Now().Unix()
        if taskResult.Status == "" </span><span class="cov0" title="0">{
                //return fmt.Errorf("task %s status is empty", taskId)
                taskResult = relaycommon.FailTaskInfo("upstream returned empty status")
        }</span>

        // 记录原本的状态，防止重复退款
        <span class="cov0" title="0">shouldRefund := false
        quota := task.Quota
        preStatus := task.Status

        task.Status = model.TaskStatus(taskResult.Status)
        switch taskResult.Status </span>{
        case model.TaskStatusSubmitted:<span class="cov0" title="0">
                task.Progress = "10%"</span>
        case model.TaskStatusQueued:<span class="cov0" title="0">
                task.Progress = "20%"</span>
        case model.TaskStatusInProgress:<span class="cov0" title="0">
                task.Progress = "30%"
                if task.StartTime == 0 </span><span class="cov0" title="0">{
                        task.StartTime = now
                }</span>
        case model.TaskStatusSuccess:<span class="cov0" title="0">
                task.Progress = "100%"
                if task.FinishTime == 0 </span><span class="cov0" title="0">{
                        task.FinishTime = now
                }</span>
                <span class="cov0" title="0">if !(len(taskResult.Url) &gt; 5 &amp;&amp; taskResult.Url[:5] == "data:") </span><span class="cov0" title="0">{
                        task.FailReason = taskResult.Url
                }</span>

                // 如果返回了 total_tokens 并且配置了模型倍率(非固定价格),则重新计费
                <span class="cov0" title="0">if taskResult.TotalTokens &gt; 0 </span><span class="cov0" title="0">{
                        // 获取模型名称
                        var taskData map[string]interface{}
                        if err := json.Unmarshal(task.Data, &amp;taskData); err == nil </span><span class="cov0" title="0">{
                                if modelName, ok := taskData["model"].(string); ok &amp;&amp; modelName != "" </span><span class="cov0" title="0">{
                                        // 获取模型价格和倍率
                                        modelRatio, hasRatioSetting, _ := ratio_setting.GetModelRatio(modelName)
                                        // 只有配置了倍率(非固定价格)时才按 token 重新计费
                                        if hasRatioSetting &amp;&amp; modelRatio &gt; 0 </span><span class="cov0" title="0">{
                                                // 获取用户和组的倍率信息
                                                group := task.Group
                                                if group == "" </span><span class="cov0" title="0">{
                                                        user, err := model.GetUserById(task.UserId, false)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                group = user.Group
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                                                        groupRatio := ratio_setting.GetGroupRatio(group)
                                                        userGroupRatio, hasUserGroupRatio := ratio_setting.GetGroupGroupRatio(group, group)

                                                        var finalGroupRatio float64
                                                        if hasUserGroupRatio </span><span class="cov0" title="0">{
                                                                finalGroupRatio = userGroupRatio
                                                        }</span> else<span class="cov0" title="0"> {
                                                                finalGroupRatio = groupRatio
                                                        }</span>

                                                        // 计算实际应扣费额度: totalTokens * modelRatio * groupRatio
                                                        <span class="cov0" title="0">actualQuota := int(float64(taskResult.TotalTokens) * modelRatio * finalGroupRatio)

                                                        // 计算差额
                                                        preConsumedQuota := task.Quota
                                                        quotaDelta := actualQuota - preConsumedQuota

                                                        if quotaDelta &gt; 0 </span><span class="cov0" title="0">{
                                                                // 需要补扣费
                                                                logger.LogInfo(ctx, fmt.Sprintf("视频任务 %s 预扣费后补扣费：%s（实际消耗：%s，预扣费：%s，tokens：%d）",
                                                                        task.TaskID,
                                                                        logger.LogQuota(quotaDelta),
                                                                        logger.LogQuota(actualQuota),
                                                                        logger.LogQuota(preConsumedQuota),
                                                                        taskResult.TotalTokens,
                                                                ))
                                                                if err := model.DecreaseUserQuota(task.UserId, quotaDelta); err != nil </span><span class="cov0" title="0">{
                                                                        logger.LogError(ctx, fmt.Sprintf("补扣费失败: %s", err.Error()))
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        model.UpdateUserUsedQuotaAndRequestCount(task.UserId, quotaDelta)
                                                                        model.UpdateChannelUsedQuota(task.ChannelId, quotaDelta)
                                                                        task.Quota = actualQuota // 更新任务记录的实际扣费额度

                                                                        // 记录消费日志
                                                                        logContent := fmt.Sprintf("视频任务成功补扣费，模型倍率 %.2f，分组倍率 %.2f，tokens %d，预扣费 %s，实际扣费 %s，补扣费 %s",
                                                                                modelRatio, finalGroupRatio, taskResult.TotalTokens,
                                                                                logger.LogQuota(preConsumedQuota), logger.LogQuota(actualQuota), logger.LogQuota(quotaDelta))
                                                                        model.RecordLog(task.UserId, model.LogTypeSystem, logContent)
                                                                }</span>
                                                        } else<span class="cov0" title="0"> if quotaDelta &lt; 0 </span><span class="cov0" title="0">{
                                                                // 需要退还多扣的费用
                                                                refundQuota := -quotaDelta
                                                                logger.LogInfo(ctx, fmt.Sprintf("视频任务 %s 预扣费后返还：%s（实际消耗：%s，预扣费：%s，tokens：%d）",
                                                                        task.TaskID,
                                                                        logger.LogQuota(refundQuota),
                                                                        logger.LogQuota(actualQuota),
                                                                        logger.LogQuota(preConsumedQuota),
                                                                        taskResult.TotalTokens,
                                                                ))
                                                                if err := model.IncreaseUserQuota(task.UserId, refundQuota, false); err != nil </span><span class="cov0" title="0">{
                                                                        logger.LogError(ctx, fmt.Sprintf("退还预扣费失败: %s", err.Error()))
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        task.Quota = actualQuota // 更新任务记录的实际扣费额度

                                                                        // 记录退款日志
                                                                        logContent := fmt.Sprintf("视频任务成功退还多扣费用，模型倍率 %.2f，分组倍率 %.2f，tokens %d，预扣费 %s，实际扣费 %s，退还 %s",
                                                                                modelRatio, finalGroupRatio, taskResult.TotalTokens,
                                                                                logger.LogQuota(preConsumedQuota), logger.LogQuota(actualQuota), logger.LogQuota(refundQuota))
                                                                        model.RecordLog(task.UserId, model.LogTypeSystem, logContent)
                                                                }</span>
                                                        } else<span class="cov0" title="0"> {
                                                                // quotaDelta == 0, 预扣费刚好准确
                                                                logger.LogInfo(ctx, fmt.Sprintf("视频任务 %s 预扣费准确（%s，tokens：%d）",
                                                                        task.TaskID, logger.LogQuota(actualQuota), taskResult.TotalTokens))
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        case model.TaskStatusFailure:<span class="cov0" title="0">
                logger.LogJson(ctx, fmt.Sprintf("Task %s failed", taskId), task)
                task.Status = model.TaskStatusFailure
                task.Progress = "100%"
                if task.FinishTime == 0 </span><span class="cov0" title="0">{
                        task.FinishTime = now
                }</span>
                <span class="cov0" title="0">task.FailReason = taskResult.Reason
                logger.LogInfo(ctx, fmt.Sprintf("Task %s failed: %s", task.TaskID, task.FailReason))
                taskResult.Progress = "100%"
                if quota != 0 </span><span class="cov0" title="0">{
                        if preStatus != model.TaskStatusFailure </span><span class="cov0" title="0">{
                                shouldRefund = true
                        }</span> else<span class="cov0" title="0"> {
                                logger.LogWarn(ctx, fmt.Sprintf("Task %s already in failure status, skip refund", task.TaskID))
                        }</span>
                }
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown task status %s for task %s", taskResult.Status, taskId)</span>
        }
        <span class="cov0" title="0">if taskResult.Progress != "" </span><span class="cov0" title="0">{
                task.Progress = taskResult.Progress
        }</span>
        <span class="cov0" title="0">if err := task.Update(); err != nil </span><span class="cov0" title="0">{
                common.SysLog("UpdateVideoTask task error: " + err.Error())
                shouldRefund = false
        }</span>

        <span class="cov0" title="0">if shouldRefund </span><span class="cov0" title="0">{
                // 任务失败且之前状态不是失败才退还额度，防止重复退还
                if err := model.IncreaseUserQuota(task.UserId, quota, false); err != nil </span><span class="cov0" title="0">{
                        logger.LogWarn(ctx, "Failed to increase user quota: "+err.Error())
                }</span>
                <span class="cov0" title="0">logContent := fmt.Sprintf("Video async task failed %s, refund %s", task.TaskID, logger.LogQuota(quota))
                model.RecordLog(task.UserId, model.LogTypeSystem, logContent)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func redactVideoResponseBody(body []byte) []byte <span class="cov0" title="0">{
        var m map[string]any
        if err := json.Unmarshal(body, &amp;m); err != nil </span><span class="cov0" title="0">{
                return body
        }</span>
        <span class="cov0" title="0">resp, _ := m["response"].(map[string]any)
        if resp != nil </span><span class="cov0" title="0">{
                delete(resp, "bytesBase64Encoded")
                if v, ok := resp["video"].(string); ok </span><span class="cov0" title="0">{
                        resp["video"] = truncateBase64(v)
                }</span>
                <span class="cov0" title="0">if vs, ok := resp["videos"].([]any); ok </span><span class="cov0" title="0">{
                        for i := range vs </span><span class="cov0" title="0">{
                                if vm, ok := vs[i].(map[string]any); ok </span><span class="cov0" title="0">{
                                        delete(vm, "bytesBase64Encoded")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">b, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return body
        }</span>
        <span class="cov0" title="0">return b</span>
}

func truncateBase64(s string) string <span class="cov0" title="0">{
        const maxKeep = 256
        if len(s) &lt;= maxKeep </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxKeep] + "..."</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package controller

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "sort"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

func TelegramBind(c *gin.Context) <span class="cov0" title="0">{
        if !common.TelegramOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": "管理员未开启通过 Telegram 登录以及注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">params := c.Request.URL.Query()
        if !checkTelegramAuthorization(params, common.TelegramBotToken) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": "无效的请求",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">telegramId := params["id"][0]
        if model.IsTelegramIdAlreadyTaken(telegramId) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": "该 Telegram 账户已被绑定",
                        "success": false,
                })
                return
        }</span>

        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        user := model.User{Id: id.(int)}
        if err := user.FillUserById(); err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">if user.Id == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户已注销",
                })
                return
        }</span>
        <span class="cov0" title="0">user.TelegramId = telegramId
        if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>

        <span class="cov0" title="0">c.Redirect(302, "/console/personal")</span>
}

func TelegramLogin(c *gin.Context) <span class="cov0" title="0">{
        if !common.TelegramOAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": "管理员未开启通过 Telegram 登录以及注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">params := c.Request.URL.Query()
        if !checkTelegramAuthorization(params, common.TelegramBotToken) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": "无效的请求",
                        "success": false,
                })
                return
        }</span>

        <span class="cov0" title="0">telegramId := params["id"][0]
        user := model.User{TelegramId: telegramId}
        if err := user.FillUserByTelegramId(); err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

func checkTelegramAuthorization(params map[string][]string, token string) bool <span class="cov0" title="0">{
        strs := []string{}
        var hash = ""
        for k, v := range params </span><span class="cov0" title="0">{
                if k == "hash" </span><span class="cov0" title="0">{
                        hash = v[0]
                        continue</span>
                }
                <span class="cov0" title="0">strs = append(strs, k+"="+v[0])</span>
        }
        <span class="cov0" title="0">sort.Strings(strs)
        var imploded = ""
        for _, s := range strs </span><span class="cov0" title="0">{
                if imploded != "" </span><span class="cov0" title="0">{
                        imploded += "\n"
                }</span>
                <span class="cov0" title="0">imploded += s</span>
        }
        <span class="cov0" title="0">sha256hash := sha256.New()
        io.WriteString(sha256hash, token)
        hmachash := hmac.New(sha256.New, sha256hash.Sum(nil))
        io.WriteString(hmachash, imploded)
        ss := hex.EncodeToString(hmachash.Sum(nil))
        return hash == ss</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package controller

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// TokenRequest 用于接收创建/更新令牌的请求
type TokenRequest struct {
        model.Token
        GroupPrioritiesArray []model.GroupPriority `json:"group_priorities_array,omitempty"` // 接收前端发送的数组格式
}

func GetAllTokens(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        pageInfo := common.GetPageQuery(c)
        tokens, err := model.GetAllUserTokens(userId, pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">total, _ := model.CountUserTokens(userId)
        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(tokens)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func SearchTokens(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        keyword := c.Query("keyword")
        token := c.Query("token")
        tokens, err := model.SearchUserTokens(userId, keyword, token)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    tokens,
        })
        return</span>
}

func GetToken(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        userId := c.GetInt("id")
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">token, err := model.GetTokenByIds(id, userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    token,
        })
        return</span>
}

func GetTokenStatus(c *gin.Context) <span class="cov0" title="0">{
        tokenId := c.GetInt("token_id")
        userId := c.GetInt("id")
        token, err := model.GetTokenByIds(tokenId, userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">expiredAt := token.ExpiredTime
        if expiredAt == -1 </span><span class="cov0" title="0">{
                expiredAt = 0
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "object":          "credit_summary",
                "total_granted":   token.RemainQuota,
                "total_used":      0, // not supported currently
                "total_available": token.RemainQuota,
                "expires_at":      expiredAt * 1000,
        })</span>
}

func GetTokenUsage(c *gin.Context) <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": "No Authorization header",
                })
                return
        }</span>

        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "message": "Invalid Bearer token",
                })
                return
        }</span>
        <span class="cov0" title="0">tokenKey := parts[1]

        token, err := model.GetTokenByKey(strings.TrimPrefix(tokenKey, "sk-"), false)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">expiredAt := token.ExpiredTime
        if expiredAt == -1 </span><span class="cov0" title="0">{
                expiredAt = 0
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "code":    true,
                "message": "ok",
                "data": gin.H{
                        "object":               "token_usage",
                        "name":                 token.Name,
                        "total_granted":        token.RemainQuota + token.UsedQuota,
                        "total_used":           token.UsedQuota,
                        "total_available":      token.RemainQuota,
                        "unlimited_quota":      token.UnlimitedQuota,
                        "model_limits":         token.GetModelLimitsMap(),
                        "model_limits_enabled": token.ModelLimitsEnabled,
                        "expires_at":           expiredAt,
                },
        })</span>
}

func AddToken(c *gin.Context) <span class="cov8" title="1">{
        tokenReq := TokenRequest{}
        err := c.ShouldBindJSON(&amp;tokenReq)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov8" title="1">if len(tokenReq.Name) &gt; 30 </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "令牌名称过长",
                })
                return
        }</span>
        <span class="cov8" title="1">key, err := common.GenerateKey()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "生成令牌失败",
                })
                common.SysLog("failed to generate token key: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">cleanToken := model.Token{
                UserId:             c.GetInt("id"),
                Name:               tokenReq.Name,
                Key:                key,
                CreatedTime:        common.GetTimestamp(),
                AccessedTime:       common.GetTimestamp(),
                ExpiredTime:        tokenReq.ExpiredTime,
                RemainQuota:        tokenReq.RemainQuota,
                UnlimitedQuota:     tokenReq.UnlimitedQuota,
                ModelLimitsEnabled: tokenReq.ModelLimitsEnabled,
                ModelLimits:        tokenReq.ModelLimits,
                AllowIps:           tokenReq.AllowIps,
                Group:              tokenReq.Group,
                AutoSmartGroup:     tokenReq.AutoSmartGroup,
        }

        // 处理分组优先级
        if len(tokenReq.GroupPrioritiesArray) &gt; 0 </span><span class="cov8" title="1">{
                err = cleanToken.SetGroupPriorities(tokenReq.GroupPrioritiesArray)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "分组优先级设置失败: " + err.Error(),
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">err = cleanToken.Insert()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func DeleteToken(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.Atoi(c.Param("id"))
        userId := c.GetInt("id")
        err := model.DeleteTokenById(id, userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func UpdateToken(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        statusOnly := c.Query("status_only")
        tokenReq := TokenRequest{}
        err := c.ShouldBindJSON(&amp;tokenReq)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if len(tokenReq.Name) &gt; 30 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "令牌名称过长",
                })
                return
        }</span>
        <span class="cov0" title="0">cleanToken, err := model.GetTokenByIds(tokenReq.Id, userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if tokenReq.Status == common.TokenStatusEnabled </span><span class="cov0" title="0">{
                if cleanToken.Status == common.TokenStatusExpired &amp;&amp; cleanToken.ExpiredTime &lt;= common.GetTimestamp() &amp;&amp; cleanToken.ExpiredTime != -1 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "令牌已过期，无法启用，请先修改令牌过期时间，或者设置为永不过期",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if cleanToken.Status == common.TokenStatusExhausted &amp;&amp; cleanToken.RemainQuota &lt;= 0 &amp;&amp; !cleanToken.UnlimitedQuota </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "令牌可用额度已用尽，无法启用，请先修改令牌剩余额度，或者设置为无限额度",
                        })
                        return
                }</span>
        }
        <span class="cov0" title="0">if statusOnly != "" </span><span class="cov0" title="0">{
                cleanToken.Status = tokenReq.Status
        }</span> else<span class="cov0" title="0"> {
                // If you add more fields, please also update token.Update()
                cleanToken.Name = tokenReq.Name
                cleanToken.ExpiredTime = tokenReq.ExpiredTime
                cleanToken.RemainQuota = tokenReq.RemainQuota
                cleanToken.UnlimitedQuota = tokenReq.UnlimitedQuota
                cleanToken.ModelLimitsEnabled = tokenReq.ModelLimitsEnabled
                cleanToken.ModelLimits = tokenReq.ModelLimits
                cleanToken.AllowIps = tokenReq.AllowIps
                cleanToken.Group = tokenReq.Group
                cleanToken.AutoSmartGroup = tokenReq.AutoSmartGroup

                // 处理分组优先级
                if len(tokenReq.GroupPrioritiesArray) &gt; 0 </span><span class="cov0" title="0">{
                        err = cleanToken.SetGroupPriorities(tokenReq.GroupPrioritiesArray)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": "分组优先级设置失败: " + err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> if tokenReq.GroupPriorities == "" </span><span class="cov0" title="0">{
                        // 如果前端明确传递空字符串，清��优先级
                        cleanToken.GroupPriorities = ""
                }</span>
        }
        <span class="cov0" title="0">err = cleanToken.Update()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    cleanToken,
        })
        return</span>
}

type TokenBatch struct {
        Ids []int `json:"ids"`
}

func DeleteTokenBatch(c *gin.Context) <span class="cov0" title="0">{
        tokenBatch := TokenBatch{}
        if err := c.ShouldBindJSON(&amp;tokenBatch); err != nil || len(tokenBatch.Ids) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>
        <span class="cov0" title="0">userId := c.GetInt("id")
        count, err := model.BatchDeleteTokens(tokenBatch.Ids, userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    count,
        })</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package controller

import (
        "fmt"
        "log"
        "net/url"
        "strconv"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/Calcium-Ion/go-epay/epay"
        "github.com/gin-gonic/gin"
        "github.com/samber/lo"
        "github.com/shopspring/decimal"
)

func GetTopUpInfo(c *gin.Context) <span class="cov0" title="0">{
        // 获取支付方式
        payMethods := operation_setting.PayMethods

        // 如果启用了 Stripe 支付，添加到支付方法列表
        if setting.StripeApiSecret != "" &amp;&amp; setting.StripeWebhookSecret != "" &amp;&amp; setting.StripePriceId != "" </span><span class="cov0" title="0">{
                // 检查是否已经包含 Stripe
                hasStripe := false
                for _, method := range payMethods </span><span class="cov0" title="0">{
                        if method["type"] == "stripe" </span><span class="cov0" title="0">{
                                hasStripe = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasStripe </span><span class="cov0" title="0">{
                        stripeMethod := map[string]string{
                                "name":      "Stripe",
                                "type":      "stripe",
                                "color":     "rgba(var(--semi-purple-5), 1)",
                                "min_topup": strconv.Itoa(setting.StripeMinTopUp),
                        }
                        payMethods = append(payMethods, stripeMethod)
                }</span>
        }

        <span class="cov0" title="0">data := gin.H{
                "enable_online_topup": operation_setting.PayAddress != "" &amp;&amp; operation_setting.EpayId != "" &amp;&amp; operation_setting.EpayKey != "",
                "enable_stripe_topup": setting.StripeApiSecret != "" &amp;&amp; setting.StripeWebhookSecret != "" &amp;&amp; setting.StripePriceId != "",
                "enable_creem_topup":  setting.CreemApiKey != "" &amp;&amp; setting.CreemProducts != "[]",
                "creem_products":      setting.CreemProducts,
                "pay_methods":         payMethods,
                "min_topup":           operation_setting.MinTopUp,
                "stripe_min_topup":    setting.StripeMinTopUp,
                "amount_options":      operation_setting.GetPaymentSetting().AmountOptions,
                "discount":            operation_setting.GetPaymentSetting().AmountDiscount,
        }
        common.ApiSuccess(c, data)</span>
}

type EpayRequest struct {
        Amount        int64  `json:"amount"`
        PaymentMethod string `json:"payment_method"`
        TopUpCode     string `json:"top_up_code"`
}

type AmountRequest struct {
        Amount    int64  `json:"amount"`
        TopUpCode string `json:"top_up_code"`
}

func GetEpayClient() *epay.Client <span class="cov0" title="0">{
        if operation_setting.PayAddress == "" || operation_setting.EpayId == "" || operation_setting.EpayKey == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">withUrl, err := epay.NewClient(&amp;epay.Config{
                PartnerID: operation_setting.EpayId,
                Key:       operation_setting.EpayKey,
        }, operation_setting.PayAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return withUrl</span>
}

func getPayMoney(amount int64, group string) float64 <span class="cov0" title="0">{
        dAmount := decimal.NewFromInt(amount)
        // 充值金额以“展示类型”为准：
        // - USD/CNY: 前端传 amount 为金额单位；TOKENS: 前端传 tokens，需要换成 USD 金额
        if operation_setting.GetQuotaDisplayType() == operation_setting.QuotaDisplayTypeTokens </span><span class="cov0" title="0">{
                dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                dAmount = dAmount.Div(dQuotaPerUnit)
        }</span>

        <span class="cov0" title="0">topupGroupRatio := common.GetTopupGroupRatio(group)
        if topupGroupRatio == 0 </span><span class="cov0" title="0">{
                topupGroupRatio = 1
        }</span>

        <span class="cov0" title="0">dTopupGroupRatio := decimal.NewFromFloat(topupGroupRatio)
        dPrice := decimal.NewFromFloat(operation_setting.Price)
        // apply optional preset discount by the original request amount (if configured), default 1.0
        discount := 1.0
        if ds, ok := operation_setting.GetPaymentSetting().AmountDiscount[int(amount)]; ok </span><span class="cov0" title="0">{
                if ds &gt; 0 </span><span class="cov0" title="0">{
                        discount = ds
                }</span>
        }
        <span class="cov0" title="0">dDiscount := decimal.NewFromFloat(discount)

        payMoney := dAmount.Mul(dPrice).Mul(dTopupGroupRatio).Mul(dDiscount)

        return payMoney.InexactFloat64()</span>
}

func getMinTopup() int64 <span class="cov0" title="0">{
        minTopup := operation_setting.MinTopUp
        if operation_setting.GetQuotaDisplayType() == operation_setting.QuotaDisplayTypeTokens </span><span class="cov0" title="0">{
                dMinTopup := decimal.NewFromInt(int64(minTopup))
                dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                minTopup = int(dMinTopup.Mul(dQuotaPerUnit).IntPart())
        }</span>
        <span class="cov0" title="0">return int64(minTopup)</span>
}

func RequestEpay(c *gin.Context) <span class="cov0" title="0">{
        var req EpayRequest
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "参数错误"})
                return
        }</span>
        <span class="cov0" title="0">if req.Amount &lt; getMinTopup() </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": fmt.Sprintf("充值数量不能小于 %d", getMinTopup())})
                return
        }</span>

        <span class="cov0" title="0">id := c.GetInt("id")
        group, err := model.GetUserGroup(id, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "获取用户分组失败"})
                return
        }</span>
        <span class="cov0" title="0">payMoney := getPayMoney(req.Amount, group)
        if payMoney &lt; 0.01 </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "充值金额过低"})
                return
        }</span>

        <span class="cov0" title="0">if !operation_setting.ContainsPayMethod(req.PaymentMethod) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "支付方式不存在"})
                return
        }</span>

        <span class="cov0" title="0">callBackAddress := service.GetCallbackAddress()
        returnUrl, _ := url.Parse(system_setting.ServerAddress + "/console/log")
        notifyUrl, _ := url.Parse(callBackAddress + "/api/user/epay/notify")
        tradeNo := fmt.Sprintf("%s%d", common.GetRandomString(6), time.Now().Unix())
        tradeNo = fmt.Sprintf("USR%dNO%s", id, tradeNo)
        client := GetEpayClient()
        if client == nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "当前管理员未配置支付信息"})
                return
        }</span>
        <span class="cov0" title="0">uri, params, err := client.Purchase(&amp;epay.PurchaseArgs{
                Type:           req.PaymentMethod,
                ServiceTradeNo: tradeNo,
                Name:           fmt.Sprintf("TUC%d", req.Amount),
                Money:          strconv.FormatFloat(payMoney, 'f', 2, 64),
                Device:         epay.PC,
                NotifyUrl:      notifyUrl,
                ReturnUrl:      returnUrl,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "拉起支付失败"})
                return
        }</span>
        <span class="cov0" title="0">amount := req.Amount
        if operation_setting.GetQuotaDisplayType() == operation_setting.QuotaDisplayTypeTokens </span><span class="cov0" title="0">{
                dAmount := decimal.NewFromInt(int64(amount))
                dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                amount = dAmount.Div(dQuotaPerUnit).IntPart()
        }</span>
        <span class="cov0" title="0">topUp := &amp;model.TopUp{
                UserId:        id,
                Amount:        amount,
                Money:         payMoney,
                TradeNo:       tradeNo,
                PaymentMethod: req.PaymentMethod,
                CreateTime:    time.Now().Unix(),
                Status:        "pending",
        }
        err = topUp.Insert()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "创建订单失败"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"message": "success", "data": params, "url": uri})</span>
}

// tradeNo lock
var orderLocks sync.Map
var createLock sync.Mutex

// LockOrder 尝试对给定订单号加锁
func LockOrder(tradeNo string) <span class="cov0" title="0">{
        lock, ok := orderLocks.Load(tradeNo)
        if !ok </span><span class="cov0" title="0">{
                createLock.Lock()
                defer createLock.Unlock()
                lock, ok = orderLocks.Load(tradeNo)
                if !ok </span><span class="cov0" title="0">{
                        lock = new(sync.Mutex)
                        orderLocks.Store(tradeNo, lock)
                }</span>
        }
        <span class="cov0" title="0">lock.(*sync.Mutex).Lock()</span>
}

// UnlockOrder 释放给定订单号的锁
func UnlockOrder(tradeNo string) <span class="cov0" title="0">{
        lock, ok := orderLocks.Load(tradeNo)
        if ok </span><span class="cov0" title="0">{
                lock.(*sync.Mutex).Unlock()
        }</span>
}

func EpayNotify(c *gin.Context) <span class="cov0" title="0">{
        params := lo.Reduce(lo.Keys(c.Request.URL.Query()), func(r map[string]string, t string, i int) map[string]string </span><span class="cov0" title="0">{
                r[t] = c.Request.URL.Query().Get(t)
                return r
        }</span>, map[string]string{})
        <span class="cov0" title="0">client := GetEpayClient()
        if client == nil </span><span class="cov0" title="0">{
                log.Println("易支付回调失败 未找到配置信息")
                _, err := c.Writer.Write([]byte("fail"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("易支付回调写入失败")
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">verifyInfo, err := client.Verify(params)
        if err == nil &amp;&amp; verifyInfo.VerifyStatus </span><span class="cov0" title="0">{
                _, err := c.Writer.Write([]byte("success"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("易支付回调写入失败")
                }</span>
        } else<span class="cov0" title="0"> {
                _, err := c.Writer.Write([]byte("fail"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("易支付回调写入失败")
                }</span>
                <span class="cov0" title="0">log.Println("易支付回调签名验证失败")
                return</span>
        }

        <span class="cov0" title="0">if verifyInfo.TradeStatus == epay.StatusTradeSuccess </span><span class="cov0" title="0">{
                log.Println(verifyInfo)
                LockOrder(verifyInfo.ServiceTradeNo)
                defer UnlockOrder(verifyInfo.ServiceTradeNo)
                topUp := model.GetTopUpByTradeNo(verifyInfo.ServiceTradeNo)
                if topUp == nil </span><span class="cov0" title="0">{
                        log.Printf("易支付回调未找到订单: %v", verifyInfo)
                        return
                }</span>
                <span class="cov0" title="0">if topUp.Status == "pending" </span><span class="cov0" title="0">{
                        topUp.Status = "success"
                        err := topUp.Update()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("易支付回调更新订单失败: %v", topUp)
                                return
                        }</span>
                        //user, _ := model.GetUserById(topUp.UserId, false)
                        //user.Quota += topUp.Amount * 500000
                        <span class="cov0" title="0">dAmount := decimal.NewFromInt(int64(topUp.Amount))
                        dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                        quotaToAdd := int(dAmount.Mul(dQuotaPerUnit).IntPart())
                        err = model.IncreaseUserQuota(topUp.UserId, quotaToAdd, true)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("易支付回调更新用户失败: %v", topUp)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("易支付回调更新用户成功 %v", topUp)
                        model.RecordLog(topUp.UserId, model.LogTypeTopup, fmt.Sprintf("使用在线充值成功，充值金额: %v，支付金额：%f", logger.LogQuota(quotaToAdd), topUp.Money))</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("易支付异常回调: %v", verifyInfo)
        }</span>
}

func RequestAmount(c *gin.Context) <span class="cov0" title="0">{
        var req AmountRequest
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "参数错误"})
                return
        }</span>

        <span class="cov0" title="0">if req.Amount &lt; getMinTopup() </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": fmt.Sprintf("充值数量不能小于 %d", getMinTopup())})
                return
        }</span>
        <span class="cov0" title="0">id := c.GetInt("id")
        group, err := model.GetUserGroup(id, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "获取用户分组失败"})
                return
        }</span>
        <span class="cov0" title="0">payMoney := getPayMoney(req.Amount, group)
        if payMoney &lt;= 0.01 </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "充值金额过低"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"message": "success", "data": strconv.FormatFloat(payMoney, 'f', 2, 64)})</span>
}

func GetUserTopUps(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        pageInfo := common.GetPageQuery(c)
        keyword := c.Query("keyword")

        var (
                topups []*model.TopUp
                total  int64
                err    error
        )
        if keyword != "" </span><span class="cov0" title="0">{
                topups, total, err = model.SearchUserTopUps(userId, keyword, pageInfo)
        }</span> else<span class="cov0" title="0"> {
                topups, total, err = model.GetUserTopUps(userId, pageInfo)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(topups)
        common.ApiSuccess(c, pageInfo)</span>
}

// GetAllTopUps 管理员获取全平台充值记录
func GetAllTopUps(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        keyword := c.Query("keyword")

        var (
                topups []*model.TopUp
                total  int64
                err    error
        )
        if keyword != "" </span><span class="cov0" title="0">{
                topups, total, err = model.SearchAllTopUps(keyword, pageInfo)
        }</span> else<span class="cov0" title="0"> {
                topups, total, err = model.GetAllTopUps(pageInfo)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(topups)
        common.ApiSuccess(c, pageInfo)</span>
}

type AdminCompleteTopupRequest struct {
        TradeNo string `json:"trade_no"`
}

// AdminCompleteTopUp 管理员补单接口
func AdminCompleteTopUp(c *gin.Context) <span class="cov0" title="0">{
        var req AdminCompleteTopupRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil || req.TradeNo == "" </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "参数错误")
                return
        }</span>

        // 订单级互斥，防止并发补单
        <span class="cov0" title="0">LockOrder(req.TradeNo)
        defer UnlockOrder(req.TradeNo)

        if err := model.ManualCompleteTopUp(req.TradeNo); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, nil)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package controller

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/thanhpk/randstr"
)

const (
        PaymentMethodCreem   = "creem"
        CreemSignatureHeader = "creem-signature"
)

var creemAdaptor = &amp;CreemAdaptor{}

// 生成HMAC-SHA256签名
func generateCreemSignature(payload string, secret string) string <span class="cov0" title="0">{
        h := hmac.New(sha256.New, []byte(secret))
        h.Write([]byte(payload))
        return hex.EncodeToString(h.Sum(nil))
}</span>

// 验证Creem webhook签名
func verifyCreemSignature(payload string, signature string, secret string) bool <span class="cov0" title="0">{
        if secret == "" </span><span class="cov0" title="0">{
                log.Printf("Creem webhook secret not set")
                if setting.CreemTestMode </span><span class="cov0" title="0">{
                        log.Printf("Skip Creem webhook sign verify in test mode")
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov0" title="0">expectedSignature := generateCreemSignature(payload, secret)
        return hmac.Equal([]byte(signature), []byte(expectedSignature))</span>
}

type CreemPayRequest struct {
        ProductId     string `json:"product_id"`
        PaymentMethod string `json:"payment_method"`
}

type CreemProduct struct {
        ProductId string  `json:"productId"`
        Name      string  `json:"name"`
        Price     float64 `json:"price"`
        Currency  string  `json:"currency"`
        Quota     int64   `json:"quota"`
}

type CreemAdaptor struct {
}

func (*CreemAdaptor) RequestPay(c *gin.Context, req *CreemPayRequest) <span class="cov0" title="0">{
        if req.PaymentMethod != PaymentMethodCreem </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "不支持的支付渠道"})
                return
        }</span>

        <span class="cov0" title="0">if req.ProductId == "" </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "请选择产品"})
                return
        }</span>

        // 解析产品列表
        <span class="cov0" title="0">var products []CreemProduct
        err := json.Unmarshal([]byte(setting.CreemProducts), &amp;products)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("解析Creem产品列表失败", err)
                c.JSON(200, gin.H{"message": "error", "data": "产品配置错误"})
                return
        }</span>

        // 查找对应的产品
        <span class="cov0" title="0">var selectedProduct *CreemProduct
        for _, product := range products </span><span class="cov0" title="0">{
                if product.ProductId == req.ProductId </span><span class="cov0" title="0">{
                        selectedProduct = &amp;product
                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedProduct == nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "产品不存在"})
                return
        }</span>

        <span class="cov0" title="0">id := c.GetInt("id")
        user, _ := model.GetUserById(id, false)

        // 生成唯一的订单引用ID
        reference := fmt.Sprintf("creem-api-ref-%d-%d-%s", user.Id, time.Now().UnixMilli(), randstr.String(4))
        referenceId := "ref_" + common.Sha1([]byte(reference))

        // 先创建订单记录，使用产品配置的金额和充值额度
        topUp := &amp;model.TopUp{
                UserId:     id,
                Amount:     selectedProduct.Quota, // 充值额度
                Money:      selectedProduct.Price, // 支付金额
                TradeNo:    referenceId,
                CreateTime: time.Now().Unix(),
                Status:     common.TopUpStatusPending,
        }
        err = topUp.Insert()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("创建Creem订单失败: %v", err)
                c.JSON(200, gin.H{"message": "error", "data": "创建订单失败"})
                return
        }</span>

        // 创建支付链接，传入用户邮箱
        <span class="cov0" title="0">checkoutUrl, err := genCreemLink(referenceId, selectedProduct, user.Email, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("获取Creem支付链接失败: %v", err)
                c.JSON(200, gin.H{"message": "error", "data": "拉起支付失败"})
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Creem订单创建成功 - 用户ID: %d, 订单号: %s, 产品: %s, 充值额度: %d, 支付金额: %.2f",
                id, referenceId, selectedProduct.Name, selectedProduct.Quota, selectedProduct.Price)

        c.JSON(200, gin.H{
                "message": "success",
                "data": gin.H{
                        "checkout_url": checkoutUrl,
                        "order_id":     referenceId,
                },
        })</span>
}

func RequestCreemPay(c *gin.Context) <span class="cov0" title="0">{
        var req CreemPayRequest

        // 读取body内容用于打印，同时保留原始数据供后续使用
        bodyBytes, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("read creem pay req body err: %v", err)
                c.JSON(200, gin.H{"message": "error", "data": "read query error"})
                return
        }</span>

        // 打印body内容
        <span class="cov0" title="0">log.Printf("creem pay request body: %s", string(bodyBytes))

        // 重新设置body供后续的ShouldBindJSON使用
        c.Request.Body = io.NopCloser(bytes.NewReader(bodyBytes))

        err = c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "参数错误"})
                return
        }</span>
        <span class="cov0" title="0">creemAdaptor.RequestPay(c, &amp;req)</span>
}

// 新的Creem Webhook结构体，匹配实际的webhook数据格式
type CreemWebhookEvent struct {
        Id        string `json:"id"`
        EventType string `json:"eventType"`
        CreatedAt int64  `json:"created_at"`
        Object    struct {
                Id        string `json:"id"`
                Object    string `json:"object"`
                RequestId string `json:"request_id"`
                Order     struct {
                        Object      string `json:"object"`
                        Id          string `json:"id"`
                        Customer    string `json:"customer"`
                        Product     string `json:"product"`
                        Amount      int    `json:"amount"`
                        Currency    string `json:"currency"`
                        SubTotal    int    `json:"sub_total"`
                        TaxAmount   int    `json:"tax_amount"`
                        AmountDue   int    `json:"amount_due"`
                        AmountPaid  int    `json:"amount_paid"`
                        Status      string `json:"status"`
                        Type        string `json:"type"`
                        Transaction string `json:"transaction"`
                        CreatedAt   string `json:"created_at"`
                        UpdatedAt   string `json:"updated_at"`
                        Mode        string `json:"mode"`
                } `json:"order"`
                Product struct {
                        Id                string  `json:"id"`
                        Object            string  `json:"object"`
                        Name              string  `json:"name"`
                        Description       string  `json:"description"`
                        Price             int     `json:"price"`
                        Currency          string  `json:"currency"`
                        BillingType       string  `json:"billing_type"`
                        BillingPeriod     string  `json:"billing_period"`
                        Status            string  `json:"status"`
                        TaxMode           string  `json:"tax_mode"`
                        TaxCategory       string  `json:"tax_category"`
                        DefaultSuccessUrl *string `json:"default_success_url"`
                        CreatedAt         string  `json:"created_at"`
                        UpdatedAt         string  `json:"updated_at"`
                        Mode              string  `json:"mode"`
                } `json:"product"`
                Units    int `json:"units"`
                Customer struct {
                        Id        string `json:"id"`
                        Object    string `json:"object"`
                        Email     string `json:"email"`
                        Name      string `json:"name"`
                        Country   string `json:"country"`
                        CreatedAt string `json:"created_at"`
                        UpdatedAt string `json:"updated_at"`
                        Mode      string `json:"mode"`
                } `json:"customer"`
                Status   string            `json:"status"`
                Metadata map[string]string `json:"metadata"`
                Mode     string            `json:"mode"`
        } `json:"object"`
}

// 保留旧的结构体作为兼容
type CreemWebhookData struct {
        Type string `json:"type"`
        Data struct {
                RequestId string            `json:"request_id"`
                Status    string            `json:"status"`
                Metadata  map[string]string `json:"metadata"`
        } `json:"data"`
}

func CreemWebhook(c *gin.Context) <span class="cov0" title="0">{
        // 读取body内容用于打印，同时保留原始数据供后续使用
        bodyBytes, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("读取Creem Webhook请求body失败: %v", err)
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        // 获取签名头
        <span class="cov0" title="0">signature := c.GetHeader(CreemSignatureHeader)

        // 打印关键信息（避免输出完整敏感payload）
        log.Printf("Creem Webhook - URI: %s", c.Request.RequestURI)
        if setting.CreemTestMode </span><span class="cov0" title="0">{
                log.Printf("Creem Webhook - Signature: %s , Body: %s", signature, bodyBytes)
        }</span> else<span class="cov0" title="0"> if signature == "" </span><span class="cov0" title="0">{
                log.Printf("Creem Webhook缺少签名头")
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        // 验证签名
        <span class="cov0" title="0">if !verifyCreemSignature(string(bodyBytes), signature, setting.CreemWebhookSecret) </span><span class="cov0" title="0">{
                log.Printf("Creem Webhook签名验证失败")
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Creem Webhook签名验证成功")

        // 重新设置body供后续的ShouldBindJSON使用
        c.Request.Body = io.NopCloser(bytes.NewReader(bodyBytes))

        // 解析新格式的webhook数据
        var webhookEvent CreemWebhookEvent
        if err := c.ShouldBindJSON(&amp;webhookEvent); err != nil </span><span class="cov0" title="0">{
                log.Printf("解析Creem Webhook参数失败: %v", err)
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Creem Webhook解析成功 - EventType: %s, EventId: %s", webhookEvent.EventType, webhookEvent.Id)

        // 根据事件类型处理不同的webhook
        switch webhookEvent.EventType </span>{
        case "checkout.completed":<span class="cov0" title="0">
                handleCheckoutCompleted(c, &amp;webhookEvent)</span>
        default:<span class="cov0" title="0">
                log.Printf("忽略Creem Webhook事件类型: %s", webhookEvent.EventType)
                c.Status(http.StatusOK)</span>
        }
}

// 处理支付完成事件
func handleCheckoutCompleted(c *gin.Context, event *CreemWebhookEvent) <span class="cov0" title="0">{
        // 验证订单状态
        if event.Object.Order.Status != "paid" </span><span class="cov0" title="0">{
                log.Printf("订单状态不是已支付: %s, 跳过处理", event.Object.Order.Status)
                c.Status(http.StatusOK)
                return
        }</span>

        // 获取引用ID（这是我们创建订单时传递的request_id）
        <span class="cov0" title="0">referenceId := event.Object.RequestId
        if referenceId == "" </span><span class="cov0" title="0">{
                log.Println("Creem Webhook缺少request_id字段")
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        // 验证订单类型，目前只处理一次性付款
        <span class="cov0" title="0">if event.Object.Order.Type != "onetime" </span><span class="cov0" title="0">{
                log.Printf("暂不支持的订单类型: %s, 跳过处理", event.Object.Order.Type)
                c.Status(http.StatusOK)
                return
        }</span>

        // 记录详细的支付信息
        <span class="cov0" title="0">log.Printf("处理Creem支付完成 - 订单号: %s, Creem订单ID: %s, 支付金额: %d %s, 客户邮箱: &lt;redacted&gt;, 产品: %s",
                referenceId,
                event.Object.Order.Id,
                event.Object.Order.AmountPaid,
                event.Object.Order.Currency,
                event.Object.Product.Name)

        // 查询本地订单确认存在
        topUp := model.GetTopUpByTradeNo(referenceId)
        if topUp == nil </span><span class="cov0" title="0">{
                log.Printf("Creem充值订单不存在: %s", referenceId)
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if topUp.Status != common.TopUpStatusPending </span><span class="cov0" title="0">{
                log.Printf("Creem充值订单状态错误: %s, 当前状态: %s", referenceId, topUp.Status)
                c.Status(http.StatusOK) // 已处理过的订单，返回成功避免重复处理
                return
        }</span>

        // 处理充值，传入客户邮箱和姓名信息
        <span class="cov0" title="0">customerEmail := event.Object.Customer.Email
        customerName := event.Object.Customer.Name

        // 防护性检查，确保邮箱和姓名不为空字符串
        if customerEmail == "" </span><span class="cov0" title="0">{
                log.Printf("警告：Creem回调中客户邮箱为空 - 订单号: %s", referenceId)
        }</span>
        <span class="cov0" title="0">if customerName == "" </span><span class="cov0" title="0">{
                log.Printf("警告：Creem回调中客户姓名为空 - 订单号: %s", referenceId)
        }</span>

        <span class="cov0" title="0">err := model.RechargeCreem(referenceId, customerEmail, customerName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Creem充值处理失败: %s, 订单号: %s", err.Error(), referenceId)
                c.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Creem充值成功 - 订单号: %s, 充值额度: %d, 支付金额: %.2f",
                referenceId, topUp.Amount, topUp.Money)
        c.Status(http.StatusOK)</span>
}

type CreemCheckoutRequest struct {
        ProductId string `json:"product_id"`
        RequestId string `json:"request_id"`
        Customer  struct {
                Email string `json:"email"`
        } `json:"customer"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

type CreemCheckoutResponse struct {
        CheckoutUrl string `json:"checkout_url"`
        Id          string `json:"id"`
}

func genCreemLink(referenceId string, product *CreemProduct, email string, username string) (string, error) <span class="cov0" title="0">{
        if setting.CreemApiKey == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("未配置Creem API密钥")
        }</span>

        // 根据测试模式选择 API 端点
        <span class="cov0" title="0">apiUrl := "https://api.creem.io/v1/checkouts"
        if setting.CreemTestMode </span><span class="cov0" title="0">{
                apiUrl = "https://test-api.creem.io/v1/checkouts"
                log.Printf("使用Creem测试环境: %s", apiUrl)
        }</span>

        // 构建请求数据，确保包含用户邮箱
        <span class="cov0" title="0">requestData := CreemCheckoutRequest{
                ProductId: product.ProductId,
                RequestId: referenceId, // 这个作为订单ID传递给Creem
                Customer: struct {
                        Email string `json:"email"`
                }{
                        Email: email, // 用户邮箱会在支付页面预填充
                },
                Metadata: map[string]string{
                        "username":     username,
                        "reference_id": referenceId,
                        "product_name": product.Name,
                        "quota":        fmt.Sprintf("%d", product.Quota),
                },
        }

        // 序列化请求数据
        jsonData, err := json.Marshal(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("序列化请求数据失败: %v", err)
        }</span>

        // 创建 HTTP 请求
        <span class="cov0" title="0">req, err := http.NewRequest("POST", apiUrl, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("创建HTTP请求失败: %v", err)
        }</span>

        // 设置请求头
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", setting.CreemApiKey)

        log.Printf("发送Creem支付请求 - URL: %s, 产品ID: %s, 用户邮箱: %s, 订单号: %s",
                apiUrl, product.ProductId, email, referenceId)

        // 发送请求
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("发送HTTP请求失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // 读取响应
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("读取响应失败: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Creem API resp - status code: %d, resp: %s", resp.StatusCode, string(body))

        // 检查响应状态
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Creem API http status %d ", resp.StatusCode)
        }</span>
        // 解析响应
        <span class="cov0" title="0">var checkoutResp CreemCheckoutResponse
        err = json.Unmarshal(body, &amp;checkoutResp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("解析响应失败: %v", err)
        }</span>

        <span class="cov0" title="0">if checkoutResp.CheckoutUrl == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Creem API resp no checkout url ")
        }</span>

        <span class="cov0" title="0">log.Printf("Creem 支付链接创建成功 - 订单号: %s, 支付链接: %s", referenceId, checkoutResp.CheckoutUrl)
        return checkoutResp.CheckoutUrl, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package controller

import (
        "fmt"
        "io"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "github.com/gin-gonic/gin"
        "github.com/stripe/stripe-go/v81"
        "github.com/stripe/stripe-go/v81/checkout/session"
        "github.com/stripe/stripe-go/v81/webhook"
        "github.com/thanhpk/randstr"
)

const (
        PaymentMethodStripe = "stripe"
)

var stripeAdaptor = &amp;StripeAdaptor{}

type StripePayRequest struct {
        Amount        int64  `json:"amount"`
        PaymentMethod string `json:"payment_method"`
}

type StripeAdaptor struct {
}

func (*StripeAdaptor) RequestAmount(c *gin.Context, req *StripePayRequest) <span class="cov0" title="0">{
        if req.Amount &lt; getStripeMinTopup() </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": fmt.Sprintf("充值数量不能小于 %d", getStripeMinTopup())})
                return
        }</span>
        <span class="cov0" title="0">id := c.GetInt("id")
        group, err := model.GetUserGroup(id, true)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "获取用户分组失败"})
                return
        }</span>
        <span class="cov0" title="0">payMoney := getStripePayMoney(float64(req.Amount), group)
        if payMoney &lt;= 0.01 </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "充值金额过低"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"message": "success", "data": strconv.FormatFloat(payMoney, 'f', 2, 64)})</span>
}

func (*StripeAdaptor) RequestPay(c *gin.Context, req *StripePayRequest) <span class="cov0" title="0">{
        if req.PaymentMethod != PaymentMethodStripe </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "不支持的支付渠道"})
                return
        }</span>
        <span class="cov0" title="0">if req.Amount &lt; getStripeMinTopup() </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": fmt.Sprintf("充值数量不能小于 %d", getStripeMinTopup()), "data": 10})
                return
        }</span>
        <span class="cov0" title="0">if req.Amount &gt; 10000 </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "充值数量不能大于 10000", "data": 10})
                return
        }</span>

        <span class="cov0" title="0">id := c.GetInt("id")
        user, _ := model.GetUserById(id, false)
        chargedMoney := GetChargedAmount(float64(req.Amount), *user)

        reference := fmt.Sprintf("new-api-ref-%d-%d-%s", user.Id, time.Now().UnixMilli(), randstr.String(4))
        referenceId := "ref_" + common.Sha1([]byte(reference))

        payLink, err := genStripeLink(referenceId, user.StripeCustomer, user.Email, req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("获取Stripe Checkout支付链接失败", err)
                c.JSON(200, gin.H{"message": "error", "data": "拉起支付失败"})
                return
        }</span>

        <span class="cov0" title="0">topUp := &amp;model.TopUp{
                UserId:        id,
                Amount:        req.Amount,
                Money:         chargedMoney,
                TradeNo:       referenceId,
                PaymentMethod: PaymentMethodStripe,
                CreateTime:    time.Now().Unix(),
                Status:        common.TopUpStatusPending,
        }
        err = topUp.Insert()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "创建订单失败"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{
                "message": "success",
                "data": gin.H{
                        "pay_link": payLink,
                },
        })</span>
}

func RequestStripeAmount(c *gin.Context) <span class="cov0" title="0">{
        var req StripePayRequest
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "参数错误"})
                return
        }</span>
        <span class="cov0" title="0">stripeAdaptor.RequestAmount(c, &amp;req)</span>
}

func RequestStripePay(c *gin.Context) <span class="cov0" title="0">{
        var req StripePayRequest
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"message": "error", "data": "参数错误"})
                return
        }</span>
        <span class="cov0" title="0">stripeAdaptor.RequestPay(c, &amp;req)</span>
}

func StripeWebhook(c *gin.Context) <span class="cov0" title="0">{
        payload, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("解析Stripe Webhook参数失败: %v\n", err)
                c.AbortWithStatus(http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">signature := c.GetHeader("Stripe-Signature")
        endpointSecret := setting.StripeWebhookSecret
        event, err := webhook.ConstructEventWithOptions(payload, signature, endpointSecret, webhook.ConstructEventOptions{
                IgnoreAPIVersionMismatch: true,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Stripe Webhook验签失败: %v\n", err)
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">switch event.Type </span>{
        case stripe.EventTypeCheckoutSessionCompleted:<span class="cov0" title="0">
                sessionCompleted(event)</span>
        case stripe.EventTypeCheckoutSessionExpired:<span class="cov0" title="0">
                sessionExpired(event)</span>
        default:<span class="cov0" title="0">
                log.Printf("不支持的Stripe Webhook事件类型: %s\n", event.Type)</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func sessionCompleted(event stripe.Event) <span class="cov0" title="0">{
        customerId := event.GetObjectValue("customer")
        referenceId := event.GetObjectValue("client_reference_id")
        status := event.GetObjectValue("status")
        if "complete" != status </span><span class="cov0" title="0">{
                log.Println("错误的Stripe Checkout完成状态:", status, ",", referenceId)
                return
        }</span>

        <span class="cov0" title="0">err := model.Recharge(referenceId, customerId)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error(), referenceId)
                return
        }</span>

        <span class="cov0" title="0">total, _ := strconv.ParseFloat(event.GetObjectValue("amount_total"), 64)
        currency := strings.ToUpper(event.GetObjectValue("currency"))
        log.Printf("收到款项：%s, %.2f(%s)", referenceId, total/100, currency)</span>
}

func sessionExpired(event stripe.Event) <span class="cov0" title="0">{
        referenceId := event.GetObjectValue("client_reference_id")
        status := event.GetObjectValue("status")
        if "expired" != status </span><span class="cov0" title="0">{
                log.Println("错误的Stripe Checkout过期状态:", status, ",", referenceId)
                return
        }</span>

        <span class="cov0" title="0">if len(referenceId) == 0 </span><span class="cov0" title="0">{
                log.Println("未提供支付单号")
                return
        }</span>

        <span class="cov0" title="0">topUp := model.GetTopUpByTradeNo(referenceId)
        if topUp == nil </span><span class="cov0" title="0">{
                log.Println("充值订单不存在", referenceId)
                return
        }</span>

        <span class="cov0" title="0">if topUp.Status != common.TopUpStatusPending </span><span class="cov0" title="0">{
                log.Println("充值订单状态错误", referenceId)
        }</span>

        <span class="cov0" title="0">topUp.Status = common.TopUpStatusExpired
        err := topUp.Update()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("过期充值订单失败", referenceId, ", err:", err.Error())
                return
        }</span>

        <span class="cov0" title="0">log.Println("充值订单已过期", referenceId)</span>
}

func genStripeLink(referenceId string, customerId string, email string, amount int64) (string, error) <span class="cov0" title="0">{
        if !strings.HasPrefix(setting.StripeApiSecret, "sk_") &amp;&amp; !strings.HasPrefix(setting.StripeApiSecret, "rk_") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("无效的Stripe API密钥")
        }</span>

        <span class="cov0" title="0">stripe.Key = setting.StripeApiSecret

        params := &amp;stripe.CheckoutSessionParams{
                ClientReferenceID: stripe.String(referenceId),
                SuccessURL:        stripe.String(system_setting.ServerAddress + "/console/log"),
                CancelURL:         stripe.String(system_setting.ServerAddress + "/console/topup"),
                LineItems: []*stripe.CheckoutSessionLineItemParams{
                        {
                                Price:    stripe.String(setting.StripePriceId),
                                Quantity: stripe.Int64(amount),
                        },
                },
                Mode:                stripe.String(string(stripe.CheckoutSessionModePayment)),
                AllowPromotionCodes: stripe.Bool(setting.StripePromotionCodesEnabled),
        }

        if "" == customerId </span><span class="cov0" title="0">{
                if "" != email </span><span class="cov0" title="0">{
                        params.CustomerEmail = stripe.String(email)
                }</span>

                <span class="cov0" title="0">params.CustomerCreation = stripe.String(string(stripe.CheckoutSessionCustomerCreationAlways))</span>
        } else<span class="cov0" title="0"> {
                params.Customer = stripe.String(customerId)
        }</span>

        <span class="cov0" title="0">result, err := session.New(params)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return result.URL, nil</span>
}

func GetChargedAmount(count float64, user model.User) float64 <span class="cov0" title="0">{
        topUpGroupRatio := common.GetTopupGroupRatio(user.Group)
        if topUpGroupRatio == 0 </span><span class="cov0" title="0">{
                topUpGroupRatio = 1
        }</span>

        <span class="cov0" title="0">return count * topUpGroupRatio</span>
}

func getStripePayMoney(amount float64, group string) float64 <span class="cov0" title="0">{
        originalAmount := amount
        if operation_setting.GetQuotaDisplayType() == operation_setting.QuotaDisplayTypeTokens </span><span class="cov0" title="0">{
                amount = amount / common.QuotaPerUnit
        }</span>
        // Using float64 for monetary calculations is acceptable here due to the small amounts involved
        <span class="cov0" title="0">topupGroupRatio := common.GetTopupGroupRatio(group)
        if topupGroupRatio == 0 </span><span class="cov0" title="0">{
                topupGroupRatio = 1
        }</span>
        // apply optional preset discount by the original request amount (if configured), default 1.0
        <span class="cov0" title="0">discount := 1.0
        if ds, ok := operation_setting.GetPaymentSetting().AmountDiscount[int(originalAmount)]; ok </span><span class="cov0" title="0">{
                if ds &gt; 0 </span><span class="cov0" title="0">{
                        discount = ds
                }</span>
        }
        <span class="cov0" title="0">payMoney := amount * setting.StripeUnitPrice * topupGroupRatio * discount
        return payMoney</span>
}

func getStripeMinTopup() int64 <span class="cov0" title="0">{
        minTopup := setting.StripeMinTopUp
        if operation_setting.GetQuotaDisplayType() == operation_setting.QuotaDisplayTypeTokens </span><span class="cov0" title="0">{
                minTopup = minTopup * int(common.QuotaPerUnit)
        }</span>
        <span class="cov0" title="0">return int64(minTopup)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package controller

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

// Setup2FARequest 设置2FA请求结构
type Setup2FARequest struct {
        Code string `json:"code" binding:"required"`
}

// Verify2FARequest 验证2FA请求结构
type Verify2FARequest struct {
        Code string `json:"code" binding:"required"`
}

// Setup2FAResponse 设置2FA响应结构
type Setup2FAResponse struct {
        Secret      string   `json:"secret"`
        QRCodeData  string   `json:"qr_code_data"`
        BackupCodes []string `json:"backup_codes"`
}

// Setup2FA 初始化2FA设置
func Setup2FA(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")

        // 检查用户是否已经启用2FA
        existing, err := model.GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if existing != nil &amp;&amp; existing.IsEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户已启用2FA，请先禁用后重新设置",
                })
                return
        }</span>

        // 如果存在已禁用的2FA记录，先删除它
        <span class="cov0" title="0">if existing != nil &amp;&amp; !existing.IsEnabled </span><span class="cov0" title="0">{
                if err := existing.Delete(); err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>
                <span class="cov0" title="0">existing = nil</span> // 重置为nil，后续将创建新记录
        }

        // 获取用户信息
        <span class="cov0" title="0">user, err := model.GetUserById(userId, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 生成TOTP密钥
        <span class="cov0" title="0">key, err := common.GenerateTOTPSecret(user.Username)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "生成2FA密钥失败",
                })
                common.SysLog("生成TOTP密钥失败: " + err.Error())
                return
        }</span>

        // 生成备用码
        <span class="cov0" title="0">backupCodes, err := common.GenerateBackupCodes()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "生成备用码失败",
                })
                common.SysLog("生成备用码失败: " + err.Error())
                return
        }</span>

        // 生成二维码数据
        <span class="cov0" title="0">qrCodeData := common.GenerateQRCodeData(key.Secret(), user.Username)

        // 创建或更新2FA记录（暂未启用）
        twoFA := &amp;model.TwoFA{
                UserId:    userId,
                Secret:    key.Secret(),
                IsEnabled: false,
        }

        if existing != nil </span><span class="cov0" title="0">{
                // 更新现有记录
                twoFA.Id = existing.Id
                err = twoFA.Update()
        }</span> else<span class="cov0" title="0"> {
                // 创建新记录
                err = twoFA.Create()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 创建备用码记录
        <span class="cov0" title="0">if err := model.CreateBackupCodes(userId, backupCodes); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "保存备用码失败",
                })
                common.SysLog("保存备用码失败: " + err.Error())
                return
        }</span>

        // 记录操作日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, "开始设置两步验证")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "2FA设置初始化成功，请使用认证器扫描二维码并输入验证码完成设置",
                "data": Setup2FAResponse{
                        Secret:      key.Secret(),
                        QRCodeData:  qrCodeData,
                        BackupCodes: backupCodes,
                },
        })</span>
}

// Enable2FA 启用2FA
func Enable2FA(c *gin.Context) <span class="cov0" title="0">{
        var req Setup2FARequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>

        <span class="cov0" title="0">userId := c.GetInt("id")

        // 获取2FA记录
        twoFA, err := model.GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if twoFA == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "请先完成2FA初始化设置",
                })
                return
        }</span>
        <span class="cov0" title="0">if twoFA.IsEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "2FA已经启用",
                })
                return
        }</span>

        // 验证TOTP验证码
        <span class="cov0" title="0">cleanCode, err := common.ValidateNumericCode(req.Code)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">if !common.ValidateTOTPCode(twoFA.Secret, cleanCode) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "验证码或备用码错误，请重试",
                })
                return
        }</span>

        // 启用2FA
        <span class="cov0" title="0">if err := twoFA.Enable(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 记录操作日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, "成功启用两步验证")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "两步验证启用成功",
        })</span>
}

// Disable2FA 禁用2FA
func Disable2FA(c *gin.Context) <span class="cov0" title="0">{
        var req Verify2FARequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>

        <span class="cov0" title="0">userId := c.GetInt("id")

        // 获取2FA记录
        twoFA, err := model.GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if twoFA == nil || !twoFA.IsEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户未启用2FA",
                })
                return
        }</span>

        // 验证TOTP验证码或备用码
        <span class="cov0" title="0">cleanCode, err := common.ValidateNumericCode(req.Code)
        isValidTOTP := false
        isValidBackup := false

        if err == nil </span><span class="cov0" title="0">{
                // 尝试验证TOTP
                isValidTOTP, _ = twoFA.ValidateTOTPAndUpdateUsage(cleanCode)
        }</span>

        <span class="cov0" title="0">if !isValidTOTP </span><span class="cov0" title="0">{
                // 尝试验证备用码
                isValidBackup, err = twoFA.ValidateBackupCodeAndUpdateUsage(req.Code)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if !isValidTOTP &amp;&amp; !isValidBackup </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "验证码或备用码错误，请重试",
                })
                return
        }</span>

        // 禁用2FA
        <span class="cov0" title="0">if err := model.DisableTwoFA(userId); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 记录操作日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, "禁用两步验证")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "两步验证已禁用",
        })</span>
}

// Get2FAStatus 获取用户2FA状态
func Get2FAStatus(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")

        twoFA, err := model.GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "enabled": false,
                "locked":  false,
        }

        if twoFA != nil </span><span class="cov0" title="0">{
                status["enabled"] = twoFA.IsEnabled
                status["locked"] = twoFA.IsLocked()
                if twoFA.IsEnabled </span><span class="cov0" title="0">{
                        // 获取剩余备用码数量
                        backupCount, err := model.GetUnusedBackupCodeCount(userId)
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog("获取备用码数量失败: " + err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                status["backup_codes_remaining"] = backupCount
                        }</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    status,
        })</span>
}

// RegenerateBackupCodes 重新生成备用码
func RegenerateBackupCodes(c *gin.Context) <span class="cov0" title="0">{
        var req Verify2FARequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>

        <span class="cov0" title="0">userId := c.GetInt("id")

        // 获取2FA记录
        twoFA, err := model.GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if twoFA == nil || !twoFA.IsEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户未启用2FA",
                })
                return
        }</span>

        // 验证TOTP验证码
        <span class="cov0" title="0">cleanCode, err := common.ValidateNumericCode(req.Code)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">valid, err := twoFA.ValidateTOTPAndUpdateUsage(cleanCode)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "验证码或备用码错误，请重试",
                })
                return
        }</span>

        // 生成新的备用码
        <span class="cov0" title="0">backupCodes, err := common.GenerateBackupCodes()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "生成备用码失败",
                })
                common.SysLog("生成备用码失败: " + err.Error())
                return
        }</span>

        // 保存新的备用码
        <span class="cov0" title="0">if err := model.CreateBackupCodes(userId, backupCodes); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "保存备用码失败",
                })
                common.SysLog("保存备用码失败: " + err.Error())
                return
        }</span>

        // 记录操作日志
        <span class="cov0" title="0">model.RecordLog(userId, model.LogTypeSystem, "重新生成两步验证备用码")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "备用码重新生成成功",
                "data": map[string]interface{}{
                        "backup_codes": backupCodes,
                },
        })</span>
}

// Verify2FALogin 登录时验证2FA
func Verify2FALogin(c *gin.Context) <span class="cov0" title="0">{
        var req Verify2FARequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "参数错误",
                })
                return
        }</span>

        // 从会话中获取pending用户信息
        <span class="cov0" title="0">session := sessions.Default(c)
        pendingUserId := session.Get("pending_user_id")
        if pendingUserId == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "会话已过期，请重新登录",
                })
                return
        }</span>
        <span class="cov0" title="0">userId, ok := pendingUserId.(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "会话数据无效，请重新登录",
                })
                return
        }</span>
        // 获取用户信息
        <span class="cov0" title="0">user, err := model.GetUserById(userId, false)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户不存在",
                })
                return
        }</span>

        // 获取2FA记录
        <span class="cov0" title="0">twoFA, err := model.GetTwoFAByUserId(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if twoFA == nil || !twoFA.IsEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户未启用2FA",
                })
                return
        }</span>

        // 验证TOTP验证码或备用码
        <span class="cov0" title="0">cleanCode, err := common.ValidateNumericCode(req.Code)
        isValidTOTP := false
        isValidBackup := false

        if err == nil </span><span class="cov0" title="0">{
                // 尝试验证TOTP
                isValidTOTP, _ = twoFA.ValidateTOTPAndUpdateUsage(cleanCode)
        }</span>

        <span class="cov0" title="0">if !isValidTOTP </span><span class="cov0" title="0">{
                // 尝试验证备用码
                isValidBackup, err = twoFA.ValidateBackupCodeAndUpdateUsage(req.Code)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if !isValidTOTP &amp;&amp; !isValidBackup </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "验证码或备用码错误，请重试",
                })
                return
        }</span>

        // 2FA验证成功，清理pending会话信息并完成登录
        <span class="cov0" title="0">session.Delete("pending_username")
        session.Delete("pending_user_id")
        session.Save()

        setupLogin(user, c)</span>
}

// Admin2FAStats 管理员获取2FA统计信息
func Admin2FAStats(c *gin.Context) <span class="cov0" title="0">{
        stats, err := model.GetTwoFAStats()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    stats,
        })</span>
}

// AdminDisable2FA 管理员强制禁用用户2FA
func AdminDisable2FA(c *gin.Context) <span class="cov0" title="0">{
        userIdStr := c.Param("id")
        userId, err := strconv.Atoi(userIdStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户ID格式错误",
                })
                return
        }</span>

        // 检查目标用户权限
        <span class="cov0" title="0">targetUser, err := model.GetUserById(userId, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">myRole := c.GetInt("role")
        if myRole &lt;= targetUser.Role &amp;&amp; myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权操作同级或更高级用户的2FA设置",
                })
                return
        }</span>

        // 禁用2FA
        <span class="cov0" title="0">if err := model.DisableTwoFA(userId); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, model.ErrTwoFANotEnabled) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "用户未启用2FA",
                        })
                        return
                }</span>
                <span class="cov0" title="0">common.ApiError(c, err)
                return</span>
        }

        // 记录操作日志
        <span class="cov0" title="0">adminId := c.GetInt("id")
        model.RecordLog(userId, model.LogTypeManage,
                fmt.Sprintf("管理员(ID:%d)强制禁用了用户的两步验证", adminId))

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "用户2FA已被强制禁用",
        })</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/setting/console_setting"

        "github.com/gin-gonic/gin"
        "golang.org/x/sync/errgroup"
)

const (
        requestTimeout   = 30 * time.Second
        httpTimeout      = 10 * time.Second
        uptimeKeySuffix  = "_24"
        apiStatusPath    = "/api/status-page/"
        apiHeartbeatPath = "/api/status-page/heartbeat/"
)

type Monitor struct {
        Name   string  `json:"name"`
        Uptime float64 `json:"uptime"`
        Status int     `json:"status"`
        Group  string  `json:"group,omitempty"`
}

type UptimeGroupResult struct {
        CategoryName string    `json:"categoryName"`
        Monitors     []Monitor `json:"monitors"`
}

func getAndDecode(ctx context.Context, client *http.Client, url string, dest interface{}) error <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return errors.New("non-200 status")
        }</span>

        <span class="cov0" title="0">return json.NewDecoder(resp.Body).Decode(dest)</span>
}

func fetchGroupData(ctx context.Context, client *http.Client, groupConfig map[string]interface{}) UptimeGroupResult <span class="cov0" title="0">{
        url, _ := groupConfig["url"].(string)
        slug, _ := groupConfig["slug"].(string)
        categoryName, _ := groupConfig["categoryName"].(string)

        result := UptimeGroupResult{
                CategoryName: categoryName,
                Monitors:     []Monitor{},
        }

        if url == "" || slug == "" </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">baseURL := strings.TrimSuffix(url, "/")

        var statusData struct {
                PublicGroupList []struct {
                        ID          int    `json:"id"`
                        Name        string `json:"name"`
                        MonitorList []struct {
                                ID   int    `json:"id"`
                                Name string `json:"name"`
                        } `json:"monitorList"`
                } `json:"publicGroupList"`
        }

        var heartbeatData struct {
                HeartbeatList map[string][]struct {
                        Status int `json:"status"`
                } `json:"heartbeatList"`
                UptimeList map[string]float64 `json:"uptimeList"`
        }

        g, gCtx := errgroup.WithContext(ctx)
        g.Go(func() error </span><span class="cov0" title="0">{
                return getAndDecode(gCtx, client, baseURL+apiStatusPath+slug, &amp;statusData)
        }</span>)
        <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{
                return getAndDecode(gCtx, client, baseURL+apiHeartbeatPath+slug, &amp;heartbeatData)
        }</span>)

        <span class="cov0" title="0">if g.Wait() != nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for _, pg := range statusData.PublicGroupList </span><span class="cov0" title="0">{
                if len(pg.MonitorList) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, m := range pg.MonitorList </span><span class="cov0" title="0">{
                        monitor := Monitor{
                                Name:  m.Name,
                                Group: pg.Name,
                        }

                        monitorID := strconv.Itoa(m.ID)

                        if uptime, exists := heartbeatData.UptimeList[monitorID+uptimeKeySuffix]; exists </span><span class="cov0" title="0">{
                                monitor.Uptime = uptime
                        }</span>

                        <span class="cov0" title="0">if heartbeats, exists := heartbeatData.HeartbeatList[monitorID]; exists &amp;&amp; len(heartbeats) &gt; 0 </span><span class="cov0" title="0">{
                                monitor.Status = heartbeats[0].Status
                        }</span>

                        <span class="cov0" title="0">result.Monitors = append(result.Monitors, monitor)</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func GetUptimeKumaStatus(c *gin.Context) <span class="cov0" title="0">{
        groups := console_setting.GetUptimeKumaGroups()
        if len(groups) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": []UptimeGroupResult{}})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(c.Request.Context(), requestTimeout)
        defer cancel()

        client := &amp;http.Client{Timeout: httpTimeout}
        results := make([]UptimeGroupResult, len(groups))

        g, gCtx := errgroup.WithContext(ctx)
        for i, group := range groups </span><span class="cov0" title="0">{
                i, group := i, group
                g.Go(func() error </span><span class="cov0" title="0">{
                        results[i] = fetchGroupData(gCtx, client, group)
                        return nil
                }</span>)
        }

        <span class="cov0" title="0">g.Wait()
        c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": results})</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

func GetAllQuotaDates(c *gin.Context) <span class="cov0" title="0">{
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        username := c.Query("username")
        dates, err := model.GetAllQuotaDates(startTimestamp, endTimestamp, username)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    dates,
        })
        return</span>
}

func GetUserQuotaDates(c *gin.Context) <span class="cov0" title="0">{
        userId := c.GetInt("id")
        startTimestamp, _ := strconv.ParseInt(c.Query("start_timestamp"), 10, 64)
        endTimestamp, _ := strconv.ParseInt(c.Query("end_timestamp"), 10, 64)
        // 判断时间跨度是否超过 1 个月
        if endTimestamp-startTimestamp &gt; 2592000 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "时间跨度不能超过 1 个月",
                })
                return
        }</span>
        <span class="cov0" title="0">dates, err := model.GetQuotaDataByUserId(userId, startTimestamp, endTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    dates,
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package controller

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "sync"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/service"
        "github.com/QuantumNous/new-api/setting"

        "github.com/QuantumNous/new-api/constant"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type LoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

func Login(c *gin.Context) <span class="cov0" title="0">{
        if !common.PasswordLoginEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "管理员关闭了密码登录",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">var loginRequest LoginRequest
        err := json.NewDecoder(c.Request.Body).Decode(&amp;loginRequest)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "无效的参数",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">username := loginRequest.Username
        password := loginRequest.Password
        if username == "" || password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "无效的参数",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                Username: username,
                Password: password,
        }
        err = user.ValidateAndFill()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>

        // 检查是否启用2FA
        <span class="cov0" title="0">if model.IsTwoFAEnabled(user.Id) </span><span class="cov0" title="0">{
                // 设置pending session，等待2FA验证
                session := sessions.Default(c)
                session.Set("pending_username", user.Username)
                session.Set("pending_user_id", user.Id)
                err := session.Save()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "message": "无法保存会话信息，请重试",
                                "success": false,
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "message": "请输入两步验证码",
                        "success": true,
                        "data": map[string]interface{}{
                                "require_2fa": true,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

// setup session &amp; cookies and then return user info
func setupLogin(user *model.User, c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        session.Set("id", user.Id)
        session.Set("username", user.Username)
        session.Set("role", user.Role)
        session.Set("status", user.Status)
        session.Set("group", user.Group)
        err := session.Save()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "无法保存会话信息，请重试",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">cleanUser := model.User{
                Id:          user.Id,
                Username:    user.Username,
                DisplayName: user.DisplayName,
                Role:        user.Role,
                Status:      user.Status,
                Group:       user.Group,
        }
        c.JSON(http.StatusOK, gin.H{
                "message": "",
                "success": true,
                "data":    cleanUser,
        })</span>
}

func Logout(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        session.Clear()
        err := session.Save()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "",
                "success": true,
        })</span>
}

func Register(c *gin.Context) <span class="cov0" title="0">{
        if !common.RegisterEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "管理员关闭了新用户注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">if !common.PasswordRegisterEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "管理员关闭了通过密码进行注册，请使用第三方账户验证的形式进行注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">var user model.User
        err := json.NewDecoder(c.Request.Body).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">if err := common.Validate.Struct(&amp;user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "输入不合法 " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">if common.EmailVerificationEnabled </span><span class="cov0" title="0">{
                if user.Email == "" || user.VerificationCode == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员开启了邮箱验证，请输入邮箱地址和验证码",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if !common.VerifyCodeWithKey(user.Email, user.VerificationCode, common.EmailVerificationPurpose) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "验证码错误或已过期",
                        })
                        return
                }</span>
        }
        <span class="cov0" title="0">exist, err := model.CheckUserExistOrDeleted(user.Username, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "数据库错误，请稍后重试",
                })
                common.SysLog(fmt.Sprintf("CheckUserExistOrDeleted error: %v", err))
                return
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户名已存在，或已注销",
                })
                return
        }</span>
        <span class="cov0" title="0">affCode := user.AffCode // this code is the inviter's code, not the user's own code
        inviterId, _ := model.GetUserIdByAffCode(affCode)
        cleanUser := model.User{
                Username:    user.Username,
                Password:    user.Password,
                DisplayName: user.Username,
                InviterId:   inviterId,
                Role:        common.RoleCommonUser, // 明确设置角色为普通用户
        }
        if common.EmailVerificationEnabled </span><span class="cov0" title="0">{
                cleanUser.Email = user.Email
        }</span>
        <span class="cov0" title="0">if err := cleanUser.Insert(inviterId); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 获取插入后的用户ID
        <span class="cov0" title="0">var insertedUser model.User
        if err := model.DB.Where("username = ?", cleanUser.Username).First(&amp;insertedUser).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户注册失败或用户ID获取失败",
                })
                return
        }</span>
        // 生成默认令牌
        <span class="cov0" title="0">if constant.GenerateDefaultToken </span><span class="cov0" title="0">{
                key, err := common.GenerateKey()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "生成默认令牌失败",
                        })
                        common.SysLog("failed to generate token key: " + err.Error())
                        return
                }</span>
                // 生成默认令牌
                <span class="cov0" title="0">token := model.Token{
                        UserId:             insertedUser.Id, // 使用插入后的用户ID
                        Name:               cleanUser.Username + "的初始令牌",
                        Key:                key,
                        CreatedTime:        common.GetTimestamp(),
                        AccessedTime:       common.GetTimestamp(),
                        ExpiredTime:        -1,     // 永不过期
                        RemainQuota:        500000, // 示例额度
                        UnlimitedQuota:     true,
                        ModelLimitsEnabled: false,
                }
                if setting.DefaultUseAutoGroup </span><span class="cov0" title="0">{
                        token.Group = "auto"
                }</span>
                <span class="cov0" title="0">if err := token.Insert(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "创建默认令牌失败",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func GetAllUsers(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        users, total, err := model.GetAllUsers(pageInfo)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(users)

        common.ApiSuccess(c, pageInfo)
        return</span>
}

func SearchUsers(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        group := c.Query("group")
        pageInfo := common.GetPageQuery(c)
        users, total, err := model.SearchUsers(keyword, group, pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(users)
        common.ApiSuccess(c, pageInfo)
        return</span>
}

func GetUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user, err := model.GetUserById(id, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">myRole := c.GetInt("role")
        if myRole &lt;= user.Role &amp;&amp; myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权获取同级或更高等级用户的信息",
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    user,
        })
        return</span>
}

func GenerateAccessToken(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        user, err := model.GetUserById(id, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        // get rand int 28-32
        <span class="cov0" title="0">randI := common.GetRandomInt(4)
        key, err := common.GenerateRandomKey(29 + randI)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "生成失败",
                })
                common.SysLog("failed to generate key: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">user.SetAccessToken(key)

        if model.DB.Where("access_token = ?", user.AccessToken).First(user).RowsAffected != 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "请重试，系统生成的 UUID 竟然重复了！",
                })
                return
        }</span>

        <span class="cov0" title="0">if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    user.AccessToken,
        })
        return</span>
}

type TransferAffQuotaRequest struct {
        Quota int `json:"quota" binding:"required"`
}

func TransferAffQuota(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        user, err := model.GetUserById(id, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">tran := TransferAffQuotaRequest{}
        if err := c.ShouldBindJSON(&amp;tran); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">err = user.TransferAffQuotaToQuota(tran.Quota)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "划转失败 " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "划转成功",
        })</span>
}

func GetAffCode(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        user, err := model.GetUserById(id, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if user.AffCode == "" </span><span class="cov0" title="0">{
                user.AffCode = common.GetRandomString(4)
                if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    user.AffCode,
        })
        return</span>
}

func GetSelf(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        userRole := c.GetInt("role")
        user, err := model.GetUserById(id, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        // Hide admin remarks: set to empty to trigger omitempty tag, ensuring the remark field is not included in JSON returned to regular users
        <span class="cov0" title="0">user.Remark = ""

        // 计算用户权限信息
        permissions := calculateUserPermissions(userRole)

        // 获取用户设置并提取sidebar_modules
        userSetting := user.GetSetting()

        // 构建响应数据，包含用户信息和权限
        responseData := map[string]interface{}{
                "id":                user.Id,
                "username":          user.Username,
                "display_name":      user.DisplayName,
                "role":              user.Role,
                "status":            user.Status,
                "email":             user.Email,
                "github_id":         user.GitHubId,
                "discord_id":        user.DiscordId,
                "oidc_id":           user.OidcId,
                "wechat_id":         user.WeChatId,
                "telegram_id":       user.TelegramId,
                "group":             user.Group,
                "quota":             user.Quota,
                "used_quota":        user.UsedQuota,
                "request_count":     user.RequestCount,
                "aff_code":          user.AffCode,
                "aff_count":         user.AffCount,
                "aff_quota":         user.AffQuota,
                "aff_history_quota": user.AffHistoryQuota,
                "inviter_id":        user.InviterId,
                "linux_do_id":       user.LinuxDOId,
                "setting":           user.Setting,
                "stripe_customer":   user.StripeCustomer,
                "sidebar_modules":   userSetting.SidebarModules, // 正确提取sidebar_modules字段
                "permissions":       permissions,                // 新增权限字段
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    responseData,
        })
        return</span>
}

// 计算用户权限的辅助函数
func calculateUserPermissions(userRole int) map[string]interface{} <span class="cov0" title="0">{
        permissions := map[string]interface{}{}

        // 根据用户角色计算权限
        if userRole == common.RoleRootUser </span><span class="cov0" title="0">{
                // 超级管理员不需要边栏设置功能
                permissions["sidebar_settings"] = false
                permissions["sidebar_modules"] = map[string]interface{}{}
        }</span> else<span class="cov0" title="0"> if userRole == common.RoleAdminUser </span><span class="cov0" title="0">{
                // 管理员可以设置边栏，但不包含系统设置功能
                permissions["sidebar_settings"] = true
                permissions["sidebar_modules"] = map[string]interface{}{
                        "admin": map[string]interface{}{
                                "setting": false, // 管理员不能访问系统设置
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                // 普通用户只能设置个人功能，不包含管理员区域
                permissions["sidebar_settings"] = true
                permissions["sidebar_modules"] = map[string]interface{}{
                        "admin": false, // 普通用户不能访问管理员区域
                }
        }</span>

        <span class="cov0" title="0">return permissions</span>
}

// 根据用户角色生成默认的边栏配置
func generateDefaultSidebarConfig(userRole int) string <span class="cov0" title="0">{
        defaultConfig := map[string]interface{}{}

        // 聊天区域 - 所有用户都可以访问
        defaultConfig["chat"] = map[string]interface{}{
                "enabled":    true,
                "playground": true,
                "chat":       true,
        }

        // 控制台区域 - 所有用户都可以访问
        defaultConfig["console"] = map[string]interface{}{
                "enabled":    true,
                "detail":     true,
                "token":      true,
                "log":        true,
                "midjourney": true,
                "task":       true,
        }

        // 个人中心区域 - 所有用户都可以访问
        defaultConfig["personal"] = map[string]interface{}{
                "enabled":  true,
                "topup":    true,
                "personal": true,
        }

        // 管理员区域 - 根据角色决定
        if userRole == common.RoleAdminUser </span><span class="cov0" title="0">{
                // 管理员可以访问管理员区域，但不能访问系统设置
                defaultConfig["admin"] = map[string]interface{}{
                        "enabled":    true,
                        "channel":    true,
                        "models":     true,
                        "redemption": true,
                        "user":       true,
                        "setting":    false, // 管理员不能访问系统设置
                }
        }</span> else<span class="cov0" title="0"> if userRole == common.RoleRootUser </span><span class="cov0" title="0">{
                // 超级管理员可以访问所有功能
                defaultConfig["admin"] = map[string]interface{}{
                        "enabled":    true,
                        "channel":    true,
                        "models":     true,
                        "redemption": true,
                        "user":       true,
                        "setting":    true,
                }
        }</span>
        // 普通用户不包含admin区域

        // 转换为JSON字符串
        <span class="cov0" title="0">configBytes, err := json.Marshal(defaultConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("生成默认边栏配置失败: " + err.Error())
                return ""
        }</span>

        <span class="cov0" title="0">return string(configBytes)</span>
}

func GetUserModels(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                id = c.GetInt("id")
        }</span>
        <span class="cov0" title="0">user, err := model.GetUserCache(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">groups := service.GetUserUsableGroups(user.Group)
        var models []string
        for group := range groups </span><span class="cov0" title="0">{
                for _, g := range model.GetGroupEnabledModels(group) </span><span class="cov0" title="0">{
                        if !common.StringsContains(models, g) </span><span class="cov0" title="0">{
                                models = append(models, g)
                        }</span>
                }
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    models,
        })
        return</span>
}

func UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        var updatedUser model.User
        err := json.NewDecoder(c.Request.Body).Decode(&amp;updatedUser)
        if err != nil || updatedUser.Id == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">if updatedUser.Password == "" </span><span class="cov0" title="0">{
                updatedUser.Password = "$I_LOVE_U" // make Validator happy :)
        }</span>
        <span class="cov0" title="0">if err := common.Validate.Struct(&amp;updatedUser); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "输入不合法 " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">originUser, err := model.GetUserById(updatedUser.Id, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">myRole := c.GetInt("role")
        if myRole &lt;= originUser.Role &amp;&amp; myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权更新同权限等级或更高权限等级的用户信息",
                })
                return
        }</span>
        <span class="cov0" title="0">if myRole &lt;= updatedUser.Role &amp;&amp; myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权将其他用户权限等级提升到大于等于自己的权限等级",
                })
                return
        }</span>
        <span class="cov0" title="0">if updatedUser.Password == "$I_LOVE_U" </span><span class="cov0" title="0">{
                updatedUser.Password = "" // rollback to what it should be
        }</span>
        <span class="cov0" title="0">updatePassword := updatedUser.Password != ""
        if err := updatedUser.Edit(updatePassword); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if originUser.Quota != updatedUser.Quota </span><span class="cov0" title="0">{
                model.RecordLog(originUser.Id, model.LogTypeManage, fmt.Sprintf("管理员将用户额度从 %s修改为 %s", logger.LogQuota(originUser.Quota), logger.LogQuota(updatedUser.Quota)))
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func UpdateSelf(c *gin.Context) <span class="cov0" title="0">{
        var requestData map[string]interface{}
        err := json.NewDecoder(c.Request.Body).Decode(&amp;requestData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>

        // 检查是否是sidebar_modules更新请求
        <span class="cov0" title="0">if sidebarModules, exists := requestData["sidebar_modules"]; exists </span><span class="cov0" title="0">{
                userId := c.GetInt("id")
                user, err := model.GetUserById(userId, false)
                if err != nil </span><span class="cov0" title="0">{
                        common.ApiError(c, err)
                        return
                }</span>

                // 获取当前用户设置
                <span class="cov0" title="0">currentSetting := user.GetSetting()

                // 更新sidebar_modules字段
                if sidebarModulesStr, ok := sidebarModules.(string); ok </span><span class="cov0" title="0">{
                        currentSetting.SidebarModules = sidebarModulesStr
                }</span>

                // 保存更新后的设置
                <span class="cov0" title="0">user.SetSetting(currentSetting)
                if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "更新设置失败: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "设置更新成功",
                })
                return</span>
        }

        // 原有的用户信息更新逻辑
        <span class="cov0" title="0">var user model.User
        requestDataBytes, err := json.Marshal(requestData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(requestDataBytes, &amp;user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>

        <span class="cov0" title="0">if user.Password == "" </span><span class="cov0" title="0">{
                user.Password = "$I_LOVE_U" // make Validator happy :)
        }</span>
        <span class="cov0" title="0">if err := common.Validate.Struct(&amp;user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "输入不合法 " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">cleanUser := model.User{
                Id:          c.GetInt("id"),
                Username:    user.Username,
                Password:    user.Password,
                DisplayName: user.DisplayName,
        }
        if user.Password == "$I_LOVE_U" </span><span class="cov0" title="0">{
                user.Password = "" // rollback to what it should be
                cleanUser.Password = ""
        }</span>
        <span class="cov0" title="0">updatePassword, err := checkUpdatePassword(user.OriginalPassword, user.Password, cleanUser.Id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if err := cleanUser.Update(updatePassword); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func checkUpdatePassword(originalPassword string, newPassword string, userId int) (updatePassword bool, err error) <span class="cov0" title="0">{
        var currentUser *model.User
        currentUser, err = model.GetUserById(userId, true)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !common.ValidatePasswordAndHash(originalPassword, currentUser.Password) </span><span class="cov0" title="0">{
                err = fmt.Errorf("原密码错误")
                return
        }</span>
        <span class="cov0" title="0">if newPassword == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">updatePassword = true
        return</span>
}

func DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">originUser, err := model.GetUserById(id, false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">myRole := c.GetInt("role")
        if myRole &lt;= originUser.Role </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权删除同权限等级或更高权限等级的用户",
                })
                return
        }</span>
        <span class="cov0" title="0">err = model.HardDeleteUserById(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "",
                })
                return
        }</span>
}

func DeleteSelf(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        user, _ := model.GetUserById(id, false)

        if user.Role == common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "不能删除超级管理员账户",
                })
                return
        }</span>

        <span class="cov0" title="0">err := model.DeleteUserById(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

func CreateUser(c *gin.Context) <span class="cov0" title="0">{
        var user model.User
        err := json.NewDecoder(c.Request.Body).Decode(&amp;user)
        user.Username = strings.TrimSpace(user.Username)
        if err != nil || user.Username == "" || user.Password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">if err := common.Validate.Struct(&amp;user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "输入不合法 " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">if user.DisplayName == "" </span><span class="cov0" title="0">{
                user.DisplayName = user.Username
        }</span>
        <span class="cov0" title="0">myRole := c.GetInt("role")
        if user.Role &gt;= myRole </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无法创建权限大于等于自己的用户",
                })
                return
        }</span>
        // Even for admin users, we cannot fully trust them!
        <span class="cov0" title="0">cleanUser := model.User{
                Username:    user.Username,
                Password:    user.Password,
                DisplayName: user.DisplayName,
                Role:        user.Role, // 保持管理员设置的角色
        }
        if err := cleanUser.Insert(0); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

type ManageRequest struct {
        Id     int    `json:"id"`
        Action string `json:"action"`
}

// ManageUser Only admin user can do this
func ManageUser(c *gin.Context) <span class="cov0" title="0">{
        var req ManageRequest
        err := json.NewDecoder(c.Request.Body).Decode(&amp;req)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                Id: req.Id,
        }
        // Fill attributes
        model.DB.Unscoped().Where(&amp;user).First(&amp;user)
        if user.Id == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "用户不存在",
                })
                return
        }</span>
        <span class="cov0" title="0">myRole := c.GetInt("role")
        if myRole &lt;= user.Role &amp;&amp; myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无权更新同权限等级或更高权限等级的用户信息",
                })
                return
        }</span>
        <span class="cov0" title="0">switch req.Action </span>{
        case "disable":<span class="cov0" title="0">
                user.Status = common.UserStatusDisabled
                if user.Role == common.RoleRootUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法禁用超级管理员用户",
                        })
                        return
                }</span>
        case "enable":<span class="cov0" title="0">
                user.Status = common.UserStatusEnabled</span>
        case "delete":<span class="cov0" title="0">
                if user.Role == common.RoleRootUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法删除超级管理员用户",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if err := user.Delete(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
        case "promote":<span class="cov0" title="0">
                if myRole != common.RoleRootUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "普通管理员用户无法提升其他用户为管理员",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if user.Role &gt;= common.RoleAdminUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "该用户已经是管理员",
                        })
                        return
                }</span>
                <span class="cov0" title="0">user.Role = common.RoleAdminUser</span>
        case "demote":<span class="cov0" title="0">
                if user.Role == common.RoleRootUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无法降级超级管理员用户",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if user.Role == common.RoleCommonUser </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "该用户已经是普通用户",
                        })
                        return
                }</span>
                <span class="cov0" title="0">user.Role = common.RoleCommonUser</span>
        }

        <span class="cov0" title="0">if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">clearUser := model.User{
                Role:   user.Role,
                Status: user.Status,
        }
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    clearUser,
        })
        return</span>
}

func EmailBind(c *gin.Context) <span class="cov0" title="0">{
        email := c.Query("email")
        code := c.Query("code")
        if !common.VerifyCodeWithKey(email, code, common.EmailVerificationPurpose) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "验证码错误或已过期",
                })
                return
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        user := model.User{
                Id: id.(int),
        }
        err := user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user.Email = email
        // no need to check if this email already taken, because we have used verification code to check it
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}

type topUpRequest struct {
        Key string `json:"key"`
}

var topUpLocks sync.Map
var topUpCreateLock sync.Mutex

type topUpTryLock struct {
        ch chan struct{}
}

func newTopUpTryLock() *topUpTryLock <span class="cov0" title="0">{
        return &amp;topUpTryLock{ch: make(chan struct{}, 1)}
}</span>

func (l *topUpTryLock) TryLock() bool <span class="cov0" title="0">{
        select </span>{
        case l.ch &lt;- struct{}{}:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (l *topUpTryLock) Unlock() <span class="cov0" title="0">{
        select </span>{
        case &lt;-l.ch:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func getTopUpLock(userID int) *topUpTryLock <span class="cov0" title="0">{
        if v, ok := topUpLocks.Load(userID); ok </span><span class="cov0" title="0">{
                return v.(*topUpTryLock)
        }</span>
        <span class="cov0" title="0">topUpCreateLock.Lock()
        defer topUpCreateLock.Unlock()
        if v, ok := topUpLocks.Load(userID); ok </span><span class="cov0" title="0">{
                return v.(*topUpTryLock)
        }</span>
        <span class="cov0" title="0">l := newTopUpTryLock()
        topUpLocks.Store(userID, l)
        return l</span>
}

func TopUp(c *gin.Context) <span class="cov0" title="0">{
        id := c.GetInt("id")
        lock := getTopUpLock(id)
        if !lock.TryLock() </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "充值处理中，请稍后重试",
                })
                return
        }</span>
        <span class="cov0" title="0">defer lock.Unlock()
        req := topUpRequest{}
        err := c.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">quota, err := model.Redeem(req.Key, id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
                "data":    quota,
        })</span>
}

type UpdateUserSettingRequest struct {
        QuotaWarningType           string  `json:"notify_type"`
        QuotaWarningThreshold      float64 `json:"quota_warning_threshold"`
        WebhookUrl                 string  `json:"webhook_url,omitempty"`
        WebhookSecret              string  `json:"webhook_secret,omitempty"`
        NotificationEmail          string  `json:"notification_email,omitempty"`
        BarkUrl                    string  `json:"bark_url,omitempty"`
        GotifyUrl                  string  `json:"gotify_url,omitempty"`
        GotifyToken                string  `json:"gotify_token,omitempty"`
        GotifyPriority             int     `json:"gotify_priority,omitempty"`
        AcceptUnsetModelRatioModel bool    `json:"accept_unset_model_ratio_model"`
        RecordIpLog                bool    `json:"record_ip_log"`
}

func UpdateUserSetting(c *gin.Context) <span class="cov0" title="0">{
        var req UpdateUserSettingRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的参数",
                })
                return
        }</span>

        // 验证预警类型
        <span class="cov0" title="0">if req.QuotaWarningType != dto.NotifyTypeEmail &amp;&amp; req.QuotaWarningType != dto.NotifyTypeWebhook &amp;&amp; req.QuotaWarningType != dto.NotifyTypeBark &amp;&amp; req.QuotaWarningType != dto.NotifyTypeGotify </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "无效的预警类型",
                })
                return
        }</span>

        // 验证预警阈值
        <span class="cov0" title="0">if req.QuotaWarningThreshold &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "预警阈值必须大于0",
                })
                return
        }</span>

        // 如果是webhook类型,验证webhook地址
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeWebhook </span><span class="cov0" title="0">{
                if req.WebhookUrl == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Webhook地址不能为空",
                        })
                        return
                }</span>
                // 验证URL格式
                <span class="cov0" title="0">if _, err := url.ParseRequestURI(req.WebhookUrl); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无效的Webhook地址",
                        })
                        return
                }</span>
        }

        // 如果是邮件类型，验证邮箱地址
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeEmail &amp;&amp; req.NotificationEmail != "" </span><span class="cov0" title="0">{
                // 验证邮箱格式
                if !strings.Contains(req.NotificationEmail, "@") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无效的邮箱地址",
                        })
                        return
                }</span>
        }

        // 如果是Bark类型，验证Bark URL
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeBark </span><span class="cov0" title="0">{
                if req.BarkUrl == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Bark推送URL不能为空",
                        })
                        return
                }</span>
                // 验证URL格式
                <span class="cov0" title="0">if _, err := url.ParseRequestURI(req.BarkUrl); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无效的Bark推送URL",
                        })
                        return
                }</span>
                // 检查是否是HTTP或HTTPS
                <span class="cov0" title="0">if !strings.HasPrefix(req.BarkUrl, "https://") &amp;&amp; !strings.HasPrefix(req.BarkUrl, "http://") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Bark推送URL必须以http://或https://开头",
                        })
                        return
                }</span>
        }

        // 如果是Gotify类型，验证Gotify URL和Token
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeGotify </span><span class="cov0" title="0">{
                if req.GotifyUrl == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Gotify服务器地址不能为空",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if req.GotifyToken == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Gotify令牌不能为空",
                        })
                        return
                }</span>
                // 验证URL格式
                <span class="cov0" title="0">if _, err := url.ParseRequestURI(req.GotifyUrl); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "无效的Gotify服务器地址",
                        })
                        return
                }</span>
                // 检查是否是HTTP或HTTPS
                <span class="cov0" title="0">if !strings.HasPrefix(req.GotifyUrl, "https://") &amp;&amp; !strings.HasPrefix(req.GotifyUrl, "http://") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "Gotify服务器地址必须以http://或https://开头",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">userId := c.GetInt("id")
        user, err := model.GetUserById(userId, true)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>

        // 构建设置
        <span class="cov0" title="0">settings := dto.UserSetting{
                NotifyType:            req.QuotaWarningType,
                QuotaWarningThreshold: req.QuotaWarningThreshold,
                AcceptUnsetRatioModel: req.AcceptUnsetModelRatioModel,
                RecordIpLog:           req.RecordIpLog,
        }

        // 如果是webhook类型,添加webhook相关设置
        if req.QuotaWarningType == dto.NotifyTypeWebhook </span><span class="cov0" title="0">{
                settings.WebhookUrl = req.WebhookUrl
                if req.WebhookSecret != "" </span><span class="cov0" title="0">{
                        settings.WebhookSecret = req.WebhookSecret
                }</span>
        }

        // 如果提供了通知邮箱，添加到设置中
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeEmail &amp;&amp; req.NotificationEmail != "" </span><span class="cov0" title="0">{
                settings.NotificationEmail = req.NotificationEmail
        }</span>

        // 如果是Bark类型，添加Bark URL到设置中
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeBark </span><span class="cov0" title="0">{
                settings.BarkUrl = req.BarkUrl
        }</span>

        // 如果是Gotify类型，添加Gotify配置到设置中
        <span class="cov0" title="0">if req.QuotaWarningType == dto.NotifyTypeGotify </span><span class="cov0" title="0">{
                settings.GotifyUrl = req.GotifyUrl
                settings.GotifyToken = req.GotifyToken
                // Gotify优先级范围0-10，超出范围则使用默认值5
                if req.GotifyPriority &lt; 0 || req.GotifyPriority &gt; 10 </span><span class="cov0" title="0">{
                        settings.GotifyPriority = 5
                }</span> else<span class="cov0" title="0"> {
                        settings.GotifyPriority = req.GotifyPriority
                }</span>
        }

        // 更新用户设置
        <span class="cov0" title="0">user.SetSetting(settings)
        if err := user.Update(false); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "更新设置失败: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "设置已更新",
        })</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package controller

import (
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

// GetAllVendors 获取供应商列表（分页）
func GetAllVendors(c *gin.Context) <span class="cov0" title="0">{
        pageInfo := common.GetPageQuery(c)
        vendors, err := model.GetAllVendors(pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">var total int64
        model.DB.Model(&amp;model.Vendor{}).Count(&amp;total)
        pageInfo.SetTotal(int(total))
        pageInfo.SetItems(vendors)
        common.ApiSuccess(c, pageInfo)</span>
}

// SearchVendors 搜索供应商
func SearchVendors(c *gin.Context) <span class="cov0" title="0">{
        keyword := c.Query("keyword")
        pageInfo := common.GetPageQuery(c)
        vendors, total, err := model.SearchVendors(keyword, pageInfo.GetStartIdx(), pageInfo.GetPageSize())
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">pageInfo.SetTotal(int(total))
        pageInfo.SetItems(vendors)
        common.ApiSuccess(c, pageInfo)</span>
}

// GetVendorMeta 根据 ID 获取供应商
func GetVendorMeta(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">v, err := model.GetVendorByID(id)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, v)</span>
}

// CreateVendorMeta 新建供应商
func CreateVendorMeta(c *gin.Context) <span class="cov0" title="0">{
        var v model.Vendor
        if err := c.ShouldBindJSON(&amp;v); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if v.Name == "" </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "供应商名称不能为空")
                return
        }</span>
        // 创建前先检查名称
        <span class="cov0" title="0">if dup, err := model.IsVendorNameDuplicated(0, v.Name); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "供应商名称已存在")
                return
        }</span>

        <span class="cov0" title="0">if err := v.Insert(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, &amp;v)</span>
}

// UpdateVendorMeta 更新供应商
func UpdateVendorMeta(c *gin.Context) <span class="cov0" title="0">{
        var v model.Vendor
        if err := c.ShouldBindJSON(&amp;v); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if v.Id == 0 </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "缺少供应商 ID")
                return
        }</span>
        // 名称冲突检查
        <span class="cov0" title="0">if dup, err := model.IsVendorNameDuplicated(v.Id, v.Name); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span> else<span class="cov0" title="0"> if dup </span><span class="cov0" title="0">{
                common.ApiErrorMsg(c, "供应商名称已存在")
                return
        }</span>

        <span class="cov0" title="0">if err := v.Update(); err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, &amp;v)</span>
}

// DeleteVendorMeta 删除供应商
func DeleteVendorMeta(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">if err := model.DB.Delete(&amp;model.Vendor{}, id).Error; err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">common.ApiSuccess(c, nil)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package controller

import (
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-gonic/gin"
)

func VideoProxy(c *gin.Context) <span class="cov0" title="0">{
        taskID := c.Param("task_id")
        if taskID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": gin.H{
                                "message": "task_id is required",
                                "type":    "invalid_request_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">task, exists, err := model.GetByOnlyTaskId(taskID)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to query task %s: %s", taskID, err.Error()))
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": gin.H{
                                "message": "Failed to query task",
                                "type":    "server_error",
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">if !exists || task == nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to get task %s: %v", taskID, err))
                c.JSON(http.StatusNotFound, gin.H{
                        "error": gin.H{
                                "message": "Task not found",
                                "type":    "invalid_request_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">if task.Status != model.TaskStatusSuccess </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": gin.H{
                                "message": fmt.Sprintf("Task is not completed yet, current status: %s", task.Status),
                                "type":    "invalid_request_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">channel, err := model.CacheGetChannel(task.ChannelId)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to get task %s: not found", taskID))
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": gin.H{
                                "message": "Failed to retrieve channel information",
                                "type":    "server_error",
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">baseURL := channel.GetBaseURL()
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://api.openai.com"
        }</span>

        <span class="cov0" title="0">var videoURL string
        client := &amp;http.Client{
                Timeout: 60 * time.Second,
        }

        req, err := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to create request: %s", err.Error()))
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": gin.H{
                                "message": "Failed to create proxy request",
                                "type":    "server_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">switch channel.Type </span>{
        case constant.ChannelTypeGemini:<span class="cov0" title="0">
                apiKey := task.PrivateData.Key
                if apiKey == "" </span><span class="cov0" title="0">{
                        logger.LogError(c.Request.Context(), fmt.Sprintf("Missing stored API key for Gemini task %s", taskID))
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": gin.H{
                                        "message": "API key not stored for task",
                                        "type":    "server_error",
                                },
                        })
                        return
                }</span>

                <span class="cov0" title="0">videoURL, err = getGeminiVideoURL(channel, task, apiKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to resolve Gemini video URL for task %s: %s", taskID, err.Error()))
                        c.JSON(http.StatusBadGateway, gin.H{
                                "error": gin.H{
                                        "message": "Failed to resolve Gemini video URL",
                                        "type":    "server_error",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">req.Header.Set("x-goog-api-key", apiKey)</span>
        case constant.ChannelTypeOpenAI, constant.ChannelTypeSora:<span class="cov0" title="0">
                videoURL = fmt.Sprintf("%s/v1/videos/%s/content", baseURL, task.TaskID)
                req.Header.Set("Authorization", "Bearer "+channel.Key)</span>
        default:<span class="cov0" title="0">
                // Video URL is directly in task.FailReason
                videoURL = task.FailReason</span>
        }

        <span class="cov0" title="0">req.URL, err = url.Parse(videoURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to parse URL %s: %s", videoURL, err.Error()))
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": gin.H{
                                "message": "Failed to create proxy request",
                                "type":    "server_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to fetch video from %s: %s", videoURL, err.Error()))
                c.JSON(http.StatusBadGateway, gin.H{
                        "error": gin.H{
                                "message": "Failed to fetch video content",
                                "type":    "server_error",
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Upstream returned status %d for %s", resp.StatusCode, videoURL))
                c.JSON(http.StatusBadGateway, gin.H{
                        "error": gin.H{
                                "message": fmt.Sprintf("Upstream service returned status %d", resp.StatusCode),
                                "type":    "server_error",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">for key, values := range resp.Header </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        c.Writer.Header().Add(key, value)
                }</span>
        }

        <span class="cov0" title="0">c.Writer.Header().Set("Cache-Control", "public, max-age=86400") // Cache for 24 hours
        c.Writer.WriteHeader(resp.StatusCode)
        _, err = io.Copy(c.Writer, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c.Request.Context(), fmt.Sprintf("Failed to stream video content: %s", err.Error()))
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package controller

import (
        "encoding/json"
        "fmt"
        "io"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/relay"
)

func getGeminiVideoURL(channel *model.Channel, task *model.Task, apiKey string) (string, error) <span class="cov0" title="0">{
        if channel == nil || task == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid channel or task")
        }</span>

        <span class="cov0" title="0">if url := extractGeminiVideoURLFromTaskData(task); url != "" </span><span class="cov0" title="0">{
                return ensureAPIKey(url, apiKey), nil
        }</span>

        <span class="cov0" title="0">baseURL := constant.ChannelBaseURLs[channel.Type]
        if channel.GetBaseURL() != "" </span><span class="cov0" title="0">{
                baseURL = channel.GetBaseURL()
        }</span>

        <span class="cov0" title="0">adaptor := relay.GetTaskAdaptor(constant.TaskPlatform(strconv.Itoa(channel.Type)))
        if adaptor == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("gemini task adaptor not found")
        }</span>

        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("api key not available for task")
        }</span>

        <span class="cov0" title="0">resp, err := adaptor.FetchTask(baseURL, apiKey, map[string]any{
                "task_id": task.TaskID,
                "action":  task.Action,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("fetch task failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("read task response failed: %w", err)
        }</span>

        <span class="cov0" title="0">taskInfo, parseErr := adaptor.ParseTaskResult(body)
        if parseErr == nil &amp;&amp; taskInfo != nil &amp;&amp; taskInfo.RemoteUrl != "" </span><span class="cov0" title="0">{
                return ensureAPIKey(taskInfo.RemoteUrl, apiKey), nil
        }</span>

        <span class="cov0" title="0">if url := extractGeminiVideoURLFromPayload(body); url != "" </span><span class="cov0" title="0">{
                return ensureAPIKey(url, apiKey), nil
        }</span>

        <span class="cov0" title="0">if parseErr != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("parse task result failed: %w", parseErr)
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("gemini video url not found")</span>
}

func extractGeminiVideoURLFromTaskData(task *model.Task) string <span class="cov0" title="0">{
        if task == nil || len(task.Data) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var payload map[string]any
        if err := json.Unmarshal(task.Data, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return extractGeminiVideoURLFromMap(payload)</span>
}

func extractGeminiVideoURLFromPayload(body []byte) string <span class="cov0" title="0">{
        var payload map[string]any
        if err := json.Unmarshal(body, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return extractGeminiVideoURLFromMap(payload)</span>
}

func extractGeminiVideoURLFromMap(payload map[string]any) string <span class="cov0" title="0">{
        if payload == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if uri, ok := payload["uri"].(string); ok &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                return uri
        }</span>
        <span class="cov0" title="0">if resp, ok := payload["response"].(map[string]any); ok </span><span class="cov0" title="0">{
                if uri := extractGeminiVideoURLFromResponse(resp); uri != "" </span><span class="cov0" title="0">{
                        return uri
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func extractGeminiVideoURLFromResponse(resp map[string]any) string <span class="cov0" title="0">{
        if resp == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if gvr, ok := resp["generateVideoResponse"].(map[string]any); ok </span><span class="cov0" title="0">{
                if uri := extractGeminiVideoURLFromGeneratedSamples(gvr); uri != "" </span><span class="cov0" title="0">{
                        return uri
                }</span>
        }
        <span class="cov0" title="0">if videos, ok := resp["videos"].([]any); ok </span><span class="cov0" title="0">{
                for _, video := range videos </span><span class="cov0" title="0">{
                        if vm, ok := video.(map[string]any); ok </span><span class="cov0" title="0">{
                                if uri, ok := vm["uri"].(string); ok &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                                        return uri
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if uri, ok := resp["video"].(string); ok &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                return uri
        }</span>
        <span class="cov0" title="0">if uri, ok := resp["uri"].(string); ok &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                return uri
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func extractGeminiVideoURLFromGeneratedSamples(gvr map[string]any) string <span class="cov0" title="0">{
        if gvr == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if samples, ok := gvr["generatedSamples"].([]any); ok </span><span class="cov0" title="0">{
                for _, sample := range samples </span><span class="cov0" title="0">{
                        if sm, ok := sample.(map[string]any); ok </span><span class="cov0" title="0">{
                                if video, ok := sm["video"].(map[string]any); ok </span><span class="cov0" title="0">{
                                        if uri, ok := video["uri"].(string); ok &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                                                return uri
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func ensureAPIKey(uri, key string) string <span class="cov0" title="0">{
        if key == "" || uri == "" </span><span class="cov0" title="0">{
                return uri
        }</span>
        <span class="cov0" title="0">if strings.Contains(uri, "key=") </span><span class="cov0" title="0">{
                return uri
        }</span>
        <span class="cov0" title="0">if strings.Contains(uri, "?") </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s&amp;key=%s", uri, key)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s?key=%s", uri, key)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/model"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type wechatLoginResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Data    string `json:"data"`
}

func getWeChatIdByCode(code string) (string, error) <span class="cov0" title="0">{
        if code == "" </span><span class="cov0" title="0">{
                return "", errors.New("无效的参数")
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest("GET", fmt.Sprintf("%s/api/wechat/user?code=%s", common.WeChatServerAddress, code), nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", common.WeChatServerToken)
        client := http.Client{
                Timeout: 5 * time.Second,
        }
        httpResponse, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer httpResponse.Body.Close()
        var res wechatLoginResponse
        err = json.NewDecoder(httpResponse.Body).Decode(&amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !res.Success </span><span class="cov0" title="0">{
                return "", errors.New(res.Message)
        }</span>
        <span class="cov0" title="0">if res.Data == "" </span><span class="cov0" title="0">{
                return "", errors.New("验证码错误或已过期")
        }</span>
        <span class="cov0" title="0">return res.Data, nil</span>
}

func WeChatAuth(c *gin.Context) <span class="cov0" title="0">{
        if !common.WeChatAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "管理员未开启通过微信登录以及注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        wechatId, err := getWeChatIdByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">user := model.User{
                WeChatId: wechatId,
        }
        if model.IsWeChatIdAlreadyTaken(wechatId) </span><span class="cov0" title="0">{
                err := user.FillUserByWeChatId()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if user.Id == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "用户已注销",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if common.RegisterEnabled </span><span class="cov0" title="0">{
                        user.Username = "wechat_" + strconv.Itoa(model.GetMaxUserId()+1)
                        user.DisplayName = "WeChat User"
                        user.Role = common.RoleCommonUser
                        user.Status = common.UserStatusEnabled

                        if err := user.Insert(0); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "success": false,
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusOK, gin.H{
                                "success": false,
                                "message": "管理员关闭了新用户注册",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">if user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "用户已被封禁",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">setupLogin(&amp;user, c)</span>
}

func WeChatBind(c *gin.Context) <span class="cov0" title="0">{
        if !common.WeChatAuthEnabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "管理员未开启通过微信登录以及注册",
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">code := c.Query("code")
        wechatId, err := getWeChatIdByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": err.Error(),
                        "success": false,
                })
                return
        }</span>
        <span class="cov0" title="0">if model.IsWeChatIdAlreadyTaken(wechatId) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": "该微信账号已被绑定",
                })
                return
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        id := session.Get("id")
        user := model.User{
                Id: id.(int),
        }
        err = user.FillUserById()
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">user.WeChatId = wechatId
        err = user.Update(false)
        if err != nil </span><span class="cov0" title="0">{
                common.ApiError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "",
        })
        return</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package model

import (
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/QuantumNous/new-api/common"

        "github.com/samber/lo"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type Ability struct {
        Group     string  `json:"group" gorm:"type:varchar(64);primaryKey;autoIncrement:false"`
        Model     string  `json:"model" gorm:"type:varchar(255);primaryKey;autoIncrement:false"`
        ChannelId int     `json:"channel_id" gorm:"primaryKey;autoIncrement:false;index"`
        Enabled   bool    `json:"enabled"`
        Priority  *int64  `json:"priority" gorm:"bigint;default:0;index"`
        Weight    uint    `json:"weight" gorm:"default:0;index"`
        Tag       *string `json:"tag" gorm:"index"`
}

type AbilityWithChannel struct {
        Ability
        ChannelType int `json:"channel_type"`
}

func GetAllEnableAbilityWithChannels() ([]AbilityWithChannel, error) <span class="cov0" title="0">{
        var abilities []AbilityWithChannel
        err := DB.Table("abilities").
                Select("abilities.*, channels.type as channel_type").
                Joins("left join channels on abilities.channel_id = channels.id").
                Where("abilities.enabled = ?", true).
                Scan(&amp;abilities).Error
        return abilities, err
}</span>

func GetGroupEnabledModels(group string) []string <span class="cov0" title="0">{
        var models []string
        // Find distinct models
        DB.Table("abilities").Where(commonGroupCol+" = ? and enabled = ?", group, true).Distinct("model").Pluck("model", &amp;models)
        return models
}</span>

func GetEnabledModels() []string <span class="cov0" title="0">{
        var models []string
        // Find distinct models
        DB.Table("abilities").Where("enabled = ?", true).Distinct("model").Pluck("model", &amp;models)
        return models
}</span>

func GetAllEnableAbilities() []Ability <span class="cov0" title="0">{
        var abilities []Ability
        DB.Find(&amp;abilities, "enabled = ?", true)
        return abilities
}</span>

func getPriority(group string, model string, retry int) (int, error) <span class="cov0" title="0">{

        var priorities []int
        err := DB.Model(&amp;Ability{}).
                Select("DISTINCT(priority)").
                Where(commonGroupCol+" = ? and model = ? and enabled = ?", group, model, true).
                Order("priority DESC").              // 按优先级降序排序
                Pluck("priority", &amp;priorities).Error // Pluck用于将查询的结果直接扫描到一个切片中

        if err != nil </span><span class="cov0" title="0">{
                // 处理错误
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(priorities) == 0 </span><span class="cov0" title="0">{
                // 如果没有查询到优先级，则返回错误
                return 0, errors.New("数据库一致性被破坏")
        }</span>

        // 确定要使用的优先级
        <span class="cov0" title="0">var priorityToUse int
        if retry &gt;= len(priorities) </span><span class="cov0" title="0">{
                // 如果重试次数大于优先级数，则使用最小的优先级
                priorityToUse = priorities[len(priorities)-1]
        }</span> else<span class="cov0" title="0"> {
                priorityToUse = priorities[retry]
        }</span>
        <span class="cov0" title="0">return priorityToUse, nil</span>
}

func getChannelQuery(group string, model string, retry int) (*gorm.DB, error) <span class="cov0" title="0">{
        maxPrioritySubQuery := DB.Model(&amp;Ability{}).Select("MAX(priority)").Where(commonGroupCol+" = ? and model = ? and enabled = ?", group, model, true)
        channelQuery := DB.Where(commonGroupCol+" = ? and model = ? and enabled = ? and priority = (?)", group, model, true, maxPrioritySubQuery)
        if retry != 0 </span><span class="cov0" title="0">{
                priority, err := getPriority(group, model, retry)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        channelQuery = DB.Where(commonGroupCol+" = ? and model = ? and enabled = ? and priority = ?", group, model, true, priority)
                }</span>
        }

        <span class="cov0" title="0">return channelQuery, nil</span>
}

func GetChannel(group string, model string, retry int) (*Channel, error) <span class="cov0" title="0">{
        var abilities []Ability

        var err error = nil
        channelQuery, err := getChannelQuery(group, model, retry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if common.UsingSQLite || common.UsingPostgreSQL </span><span class="cov0" title="0">{
                err = channelQuery.Order("weight DESC").Find(&amp;abilities).Error
        }</span> else<span class="cov0" title="0"> {
                err = channelQuery.Order("weight DESC").Find(&amp;abilities).Error
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">channel := Channel{}
        if len(abilities) &gt; 0 </span><span class="cov0" title="0">{
                // Randomly choose one
                weightSum := uint(0)
                for _, ability_ := range abilities </span><span class="cov0" title="0">{
                        weightSum += ability_.Weight + 10
                }</span>
                // Randomly choose one
                <span class="cov0" title="0">weight := common.GetRandomInt(int(weightSum))
                for _, ability_ := range abilities </span><span class="cov0" title="0">{
                        weight -= int(ability_.Weight) + 10
                        //log.Printf("weight: %d, ability weight: %d", weight, *ability_.Weight)
                        if weight &lt;= 0 </span><span class="cov0" title="0">{
                                channel.Id = ability_.ChannelId
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                return nil, nil
        }</span>
        <span class="cov0" title="0">err = DB.First(&amp;channel, "id = ?", channel.Id).Error
        return &amp;channel, err</span>
}

func (channel *Channel) AddAbilities(tx *gorm.DB) error <span class="cov0" title="0">{
        models_ := strings.Split(channel.Models, ",")
        groups_ := strings.Split(channel.Group, ",")
        abilitySet := make(map[string]struct{})
        abilities := make([]Ability, 0, len(models_))
        for _, model := range models_ </span><span class="cov0" title="0">{
                for _, group := range groups_ </span><span class="cov0" title="0">{
                        key := group + "|" + model
                        if _, exists := abilitySet[key]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">abilitySet[key] = struct{}{}
                        ability := Ability{
                                Group:     group,
                                Model:     model,
                                ChannelId: channel.Id,
                                Enabled:   channel.Status == common.ChannelStatusEnabled,
                                Priority:  channel.Priority,
                                Weight:    uint(channel.GetWeight()),
                                Tag:       channel.Tag,
                        }
                        abilities = append(abilities, ability)</span>
                }
        }
        <span class="cov0" title="0">if len(abilities) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // choose DB or provided tx
        <span class="cov0" title="0">useDB := DB
        if tx != nil </span><span class="cov0" title="0">{
                useDB = tx
        }</span>
        <span class="cov0" title="0">for _, chunk := range lo.Chunk(abilities, 50) </span><span class="cov0" title="0">{
                err := useDB.Clauses(clause.OnConflict{DoNothing: true}).Create(&amp;chunk).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (channel *Channel) DeleteAbilities() error <span class="cov0" title="0">{
        return DB.Where("channel_id = ?", channel.Id).Delete(&amp;Ability{}).Error
}</span>

// UpdateAbilities updates abilities of this channel.
// Make sure the channel is completed before calling this function.
func (channel *Channel) UpdateAbilities(tx *gorm.DB) error <span class="cov0" title="0">{
        isNewTx := false
        // 如果没有传入事务，创建新的事务
        if tx == nil </span><span class="cov0" title="0">{
                tx = DB.Begin()
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return tx.Error
                }</span>
                <span class="cov0" title="0">isNewTx = true
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                        }</span>
                }()
        }

        // First delete all abilities of this channel
        <span class="cov0" title="0">err := tx.Where("channel_id = ?", channel.Id).Delete(&amp;Ability{}).Error
        if err != nil </span><span class="cov0" title="0">{
                if isNewTx </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Then add new abilities
        <span class="cov0" title="0">models_ := strings.Split(channel.Models, ",")
        groups_ := strings.Split(channel.Group, ",")
        abilitySet := make(map[string]struct{})
        abilities := make([]Ability, 0, len(models_))
        for _, model := range models_ </span><span class="cov0" title="0">{
                for _, group := range groups_ </span><span class="cov0" title="0">{
                        key := group + "|" + model
                        if _, exists := abilitySet[key]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">abilitySet[key] = struct{}{}
                        ability := Ability{
                                Group:     group,
                                Model:     model,
                                ChannelId: channel.Id,
                                Enabled:   channel.Status == common.ChannelStatusEnabled,
                                Priority:  channel.Priority,
                                Weight:    uint(channel.GetWeight()),
                                Tag:       channel.Tag,
                        }
                        abilities = append(abilities, ability)</span>
                }
        }

        <span class="cov0" title="0">if len(abilities) &gt; 0 </span><span class="cov0" title="0">{
                for _, chunk := range lo.Chunk(abilities, 50) </span><span class="cov0" title="0">{
                        err = tx.Clauses(clause.OnConflict{DoNothing: true}).Create(&amp;chunk).Error
                        if err != nil </span><span class="cov0" title="0">{
                                if isNewTx </span><span class="cov0" title="0">{
                                        tx.Rollback()
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                }
        }

        // 如果是新创建的事务，需要提交
        <span class="cov0" title="0">if isNewTx </span><span class="cov0" title="0">{
                return tx.Commit().Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func UpdateAbilityStatus(channelId int, status bool) error <span class="cov0" title="0">{
        return DB.Model(&amp;Ability{}).Where("channel_id = ?", channelId).Select("enabled").Update("enabled", status).Error
}</span>

func UpdateAbilityStatusByTag(tag string, status bool) error <span class="cov0" title="0">{
        return DB.Model(&amp;Ability{}).Where("tag = ?", tag).Select("enabled").Update("enabled", status).Error
}</span>

func UpdateAbilityByTag(tag string, newTag *string, priority *int64, weight *uint) error <span class="cov0" title="0">{
        ability := Ability{}
        if newTag != nil </span><span class="cov0" title="0">{
                ability.Tag = newTag
        }</span>
        <span class="cov0" title="0">if priority != nil </span><span class="cov0" title="0">{
                ability.Priority = priority
        }</span>
        <span class="cov0" title="0">if weight != nil </span><span class="cov0" title="0">{
                ability.Weight = *weight
        }</span>
        <span class="cov0" title="0">return DB.Model(&amp;Ability{}).Where("tag = ?", tag).Updates(ability).Error</span>
}

var fixLock = sync.Mutex{}

func FixAbility() (int, int, error) <span class="cov0" title="0">{
        lock := fixLock.TryLock()
        if !lock </span><span class="cov0" title="0">{
                return 0, 0, errors.New("已经有一个修复任务在运行中，请稍后再试")
        }</span>
        <span class="cov0" title="0">defer fixLock.Unlock()

        // truncate abilities table
        if common.UsingSQLite </span><span class="cov0" title="0">{
                err := DB.Exec("DELETE FROM abilities").Error
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("Delete abilities failed: %s", err.Error()))
                        return 0, 0, err
                }</span>
        } else<span class="cov0" title="0"> {
                err := DB.Exec("TRUNCATE TABLE abilities").Error
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("Truncate abilities failed: %s", err.Error()))
                        return 0, 0, err
                }</span>
        }
        <span class="cov0" title="0">var channels []*Channel
        // Find all channels
        err := DB.Model(&amp;Channel{}).Find(&amp;channels).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">if len(channels) == 0 </span><span class="cov0" title="0">{
                return 0, 0, nil
        }</span>
        <span class="cov0" title="0">successCount := 0
        failCount := 0
        for _, chunk := range lo.Chunk(channels, 50) </span><span class="cov0" title="0">{
                ids := lo.Map(chunk, func(c *Channel, _ int) int </span><span class="cov0" title="0">{ return c.Id }</span>)
                // Delete all abilities of this channel
                <span class="cov0" title="0">err = DB.Where("channel_id IN ?", ids).Delete(&amp;Ability{}).Error
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("Delete abilities failed: %s", err.Error()))
                        failCount += len(chunk)
                        continue</span>
                }
                // Then add new abilities
                <span class="cov0" title="0">for _, channel := range chunk </span><span class="cov0" title="0">{
                        err = channel.AddAbilities(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog(fmt.Sprintf("Add abilities for channel %d failed: %s", channel.Id, err.Error()))
                                failCount++
                        }</span> else<span class="cov0" title="0"> {
                                successCount++
                        }</span>
                }
        }
        <span class="cov0" title="0">InitChannelCache()
        return successCount, failCount, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "math/rand"
        "strings"
        "sync"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/types"

        "github.com/samber/lo"
        "gorm.io/gorm"
)

type Channel struct {
        Id                 int     `json:"id"`
        Type               int     `json:"type" gorm:"default:0"`
        Key                string  `json:"key" gorm:"not null"`
        OpenAIOrganization *string `json:"openai_organization"`
        TestModel          *string `json:"test_model"`
        Status             int     `json:"status" gorm:"default:1"`
        Name               string  `json:"name" gorm:"index"`
        Weight             *uint   `json:"weight" gorm:"default:0"`
        CreatedTime        int64   `json:"created_time" gorm:"bigint"`
        TestTime           int64   `json:"test_time" gorm:"bigint"`
        ResponseTime       int     `json:"response_time"` // in milliseconds
        BaseURL            *string `json:"base_url" gorm:"column:base_url;default:''"`
        Other              string  `json:"other"`
        Balance            float64 `json:"balance"` // in USD
        BalanceUpdatedTime int64   `json:"balance_updated_time" gorm:"bigint"`
        Models             string  `json:"models"`
        Group              string  `json:"group" gorm:"type:varchar(64);default:'default'"`
        UsedQuota          int64   `json:"used_quota" gorm:"bigint;default:0"`
        ModelMapping       *string `json:"model_mapping" gorm:"type:text"`
        //MaxInputTokens     *int    `json:"max_input_tokens" gorm:"default:0"`
        StatusCodeMapping *string `json:"status_code_mapping" gorm:"type:varchar(1024);default:''"`
        Priority          *int64  `json:"priority" gorm:"bigint;default:0"`
        AutoBan           *int    `json:"auto_ban" gorm:"default:1"`
        OtherInfo         string  `json:"other_info"`
        Tag               *string `json:"tag" gorm:"index"`
        Setting           *string `json:"setting" gorm:"type:text"` // 渠道额外设置
        ParamOverride     *string `json:"param_override" gorm:"type:text"`
        HeaderOverride    *string `json:"header_override" gorm:"type:text"`
        Remark            *string `json:"remark" gorm:"type:varchar(255)" validate:"max=255"`
        // add after v0.8.5
        ChannelInfo ChannelInfo `json:"channel_info" gorm:"type:json"`

        OtherSettings string `json:"settings" gorm:"column:settings"` // 其他设置，存储azure版本等不需要检索的信息，详见dto.ChannelOtherSettings

        // cache info
        Keys []string `json:"-" gorm:"-"`
}

type ChannelInfo struct {
        IsMultiKey             bool                  `json:"is_multi_key"`                        // 是否多Key模式
        MultiKeySize           int                   `json:"multi_key_size"`                      // 多Key模式下的Key数量
        MultiKeyStatusList     map[int]int           `json:"multi_key_status_list"`               // key状态列表，key index -&gt; status
        MultiKeyDisabledReason map[int]string        `json:"multi_key_disabled_reason,omitempty"` // key禁用原因列表，key index -&gt; reason
        MultiKeyDisabledTime   map[int]int64         `json:"multi_key_disabled_time,omitempty"`   // key禁用时间列表，key index -&gt; time
        MultiKeyPollingIndex   int                   `json:"multi_key_polling_index"`             // 多Key模式下轮询的key索引
        MultiKeyMode           constant.MultiKeyMode `json:"multi_key_mode"`
}

// Value implements driver.Valuer interface
func (c ChannelInfo) Value() (driver.Value, error) <span class="cov0" title="0">{
        return common.Marshal(&amp;c)
}</span>

// Scan implements sql.Scanner interface
func (c *ChannelInfo) Scan(value interface{}) error <span class="cov0" title="0">{
        bytesValue, _ := value.([]byte)
        return common.Unmarshal(bytesValue, c)
}</span>

func (channel *Channel) GetKeys() []string <span class="cov0" title="0">{
        if channel.Key == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">if len(channel.Keys) &gt; 0 </span><span class="cov0" title="0">{
                return channel.Keys
        }</span>
        <span class="cov0" title="0">trimmed := strings.TrimSpace(channel.Key)
        // If the key starts with '[', try to parse it as a JSON array (e.g., for Vertex AI scenarios)
        if strings.HasPrefix(trimmed, "[") </span><span class="cov0" title="0">{
                var arr []json.RawMessage
                if err := common.Unmarshal([]byte(trimmed), &amp;arr); err == nil </span><span class="cov0" title="0">{
                        res := make([]string, len(arr))
                        for i, v := range arr </span><span class="cov0" title="0">{
                                res[i] = string(v)
                        }</span>
                        <span class="cov0" title="0">return res</span>
                }
        }
        // Otherwise, fall back to splitting by newline
        <span class="cov0" title="0">keys := strings.Split(strings.Trim(channel.Key, "\n"), "\n")
        return keys</span>
}

func (channel *Channel) GetNextEnabledKey() (string, int, *types.NewAPIError) <span class="cov0" title="0">{
        // If not in multi-key mode, return the original key string directly.
        if !channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                return channel.Key, 0, nil
        }</span>

        // Obtain all keys (split by \n)
        <span class="cov0" title="0">keys := channel.GetKeys()
        if len(keys) == 0 </span><span class="cov0" title="0">{
                // No keys available, return error, should disable the channel
                return "", 0, types.NewError(errors.New("no keys available"), types.ErrorCodeChannelNoAvailableKey)
        }</span>

        <span class="cov0" title="0">lock := GetChannelPollingLock(channel.Id)
        lock.Lock()
        defer lock.Unlock()

        statusList := channel.ChannelInfo.MultiKeyStatusList
        // helper to get key status, default to enabled when missing
        getStatus := func(idx int) int </span><span class="cov0" title="0">{
                if statusList == nil </span><span class="cov0" title="0">{
                        return common.ChannelStatusEnabled
                }</span>
                <span class="cov0" title="0">if status, ok := statusList[idx]; ok </span><span class="cov0" title="0">{
                        return status
                }</span>
                <span class="cov0" title="0">return common.ChannelStatusEnabled</span>
        }

        // Collect indexes of enabled keys
        <span class="cov0" title="0">enabledIdx := make([]int, 0, len(keys))
        for i := range keys </span><span class="cov0" title="0">{
                if getStatus(i) == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                        enabledIdx = append(enabledIdx, i)
                }</span>
        }
        // If no specific status list or none enabled, return an explicit error so caller can
        // properly handle a channel with no available keys (e.g. mark channel disabled).
        // Returning the first key here caused requests to keep using an already-disabled key.
        <span class="cov0" title="0">if len(enabledIdx) == 0 </span><span class="cov0" title="0">{
                return "", 0, types.NewError(errors.New("no enabled keys"), types.ErrorCodeChannelNoAvailableKey)
        }</span>

        <span class="cov0" title="0">switch channel.ChannelInfo.MultiKeyMode </span>{
        case constant.MultiKeyModeRandom:<span class="cov0" title="0">
                // Randomly pick one enabled key
                selectedIdx := enabledIdx[rand.Intn(len(enabledIdx))]
                return keys[selectedIdx], selectedIdx, nil</span>
        case constant.MultiKeyModePolling:<span class="cov0" title="0">
                // Use channel-specific lock to ensure thread-safe polling

                channelInfo, err := CacheGetChannelInfo(channel.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, types.NewError(err, types.ErrorCodeGetChannelFailed, types.ErrOptionWithSkipRetry())
                }</span>
                //println("before polling index:", channel.ChannelInfo.MultiKeyPollingIndex)
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if common.DebugEnabled </span><span class="cov0" title="0">{
                                println(fmt.Sprintf("channel %d polling index: %d", channel.Id, channel.ChannelInfo.MultiKeyPollingIndex))
                        }</span>
                        <span class="cov0" title="0">if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                                _ = channel.SaveChannelInfo()
                        }</span> else <span class="cov0" title="0">{
                                // CacheUpdateChannel(channel)
                        }</span>
                }()
                // Start from the saved polling index and look for the next enabled key
                <span class="cov0" title="0">start := channelInfo.MultiKeyPollingIndex
                if start &lt; 0 || start &gt;= len(keys) </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; len(keys); i++ </span><span class="cov0" title="0">{
                        idx := (start + i) % len(keys)
                        if getStatus(idx) == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                                // update polling index for next call (point to the next position)
                                channel.ChannelInfo.MultiKeyPollingIndex = (idx + 1) % len(keys)
                                return keys[idx], idx, nil
                        }</span>
                }
                // Fallback – should not happen, but return first enabled key
                <span class="cov0" title="0">return keys[enabledIdx[0]], enabledIdx[0], nil</span>
        default:<span class="cov0" title="0">
                // Unknown mode, default to first enabled key (or original key string)
                return keys[enabledIdx[0]], enabledIdx[0], nil</span>
        }
}

func (channel *Channel) SaveChannelInfo() error <span class="cov0" title="0">{
        return DB.Model(channel).Update("channel_info", channel.ChannelInfo).Error
}</span>

func (channel *Channel) GetModels() []string <span class="cov0" title="0">{
        if channel.Models == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">return strings.Split(strings.Trim(channel.Models, ","), ",")</span>
}

func (channel *Channel) GetGroups() []string <span class="cov0" title="0">{
        if channel.Group == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">groups := strings.Split(strings.Trim(channel.Group, ","), ",")
        for i, group := range groups </span><span class="cov0" title="0">{
                groups[i] = strings.TrimSpace(group)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

func (channel *Channel) GetOtherInfo() map[string]interface{} <span class="cov0" title="0">{
        otherInfo := make(map[string]interface{})
        if channel.OtherInfo != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(channel.OtherInfo), &amp;otherInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to unmarshal other info: channel_id=%d, tag=%s, name=%s, error=%v", channel.Id, channel.GetTag(), channel.Name, err))
                }</span>
        }
        <span class="cov0" title="0">return otherInfo</span>
}

func (channel *Channel) SetOtherInfo(otherInfo map[string]interface{}) <span class="cov0" title="0">{
        otherInfoBytes, err := json.Marshal(otherInfo)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to marshal other info: channel_id=%d, tag=%s, name=%s, error=%v", channel.Id, channel.GetTag(), channel.Name, err))
                return
        }</span>
        <span class="cov0" title="0">channel.OtherInfo = string(otherInfoBytes)</span>
}

func (channel *Channel) GetTag() string <span class="cov0" title="0">{
        if channel.Tag == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *channel.Tag</span>
}

func (channel *Channel) SetTag(tag string) <span class="cov0" title="0">{
        channel.Tag = &amp;tag
}</span>

func (channel *Channel) GetAutoBan() bool <span class="cov0" title="0">{
        if channel.AutoBan == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return *channel.AutoBan == 1</span>
}

func (channel *Channel) Save() error <span class="cov0" title="0">{
        return DB.Save(channel).Error
}</span>

func (channel *Channel) SaveWithoutKey() error <span class="cov0" title="0">{
        return DB.Omit("key").Save(channel).Error
}</span>

func GetAllChannels(startIdx int, num int, selectAll bool, idSort bool) ([]*Channel, error) <span class="cov0" title="0">{
        var channels []*Channel
        var err error
        order := "priority desc"
        if idSort </span><span class="cov0" title="0">{
                order = "id desc"
        }</span>
        <span class="cov0" title="0">if selectAll </span><span class="cov0" title="0">{
                err = DB.Order(order).Find(&amp;channels).Error
        }</span> else<span class="cov0" title="0"> {
                err = DB.Order(order).Limit(num).Offset(startIdx).Omit("key").Find(&amp;channels).Error
        }</span>
        <span class="cov0" title="0">return channels, err</span>
}

func GetChannelsByTag(tag string, idSort bool, selectAll bool) ([]*Channel, error) <span class="cov0" title="0">{
        var channels []*Channel
        order := "priority desc"
        if idSort </span><span class="cov0" title="0">{
                order = "id desc"
        }</span>
        <span class="cov0" title="0">query := DB.Where("tag = ?", tag).Order(order)
        if !selectAll </span><span class="cov0" title="0">{
                query = query.Omit("key")
        }</span>
        <span class="cov0" title="0">err := query.Find(&amp;channels).Error
        return channels, err</span>
}

func SearchChannels(keyword string, group string, model string, idSort bool) ([]*Channel, error) <span class="cov0" title="0">{
        var channels []*Channel
        modelsCol := "`models`"

        // 如果是 PostgreSQL，使用双引号
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                modelsCol = `"models"`
        }</span>

        <span class="cov0" title="0">baseURLCol := "`base_url`"
        // 如果是 PostgreSQL，使用双引号
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                baseURLCol = `"base_url"`
        }</span>

        <span class="cov0" title="0">order := "priority desc"
        if idSort </span><span class="cov0" title="0">{
                order = "id desc"
        }</span>

        // 构造基础查询
        <span class="cov0" title="0">baseQuery := DB.Model(&amp;Channel{}).Omit("key")

        // 构造WHERE子句
        var whereClause string
        var args []interface{}
        if group != "" &amp;&amp; group != "null" </span><span class="cov0" title="0">{
                var groupCondition string
                if common.UsingMySQL </span><span class="cov0" title="0">{
                        groupCondition = `CONCAT(',', ` + commonGroupCol + `, ',') LIKE ?`
                }</span> else<span class="cov0" title="0"> {
                        // sqlite, PostgreSQL
                        groupCondition = `(',' || ` + commonGroupCol + ` || ',') LIKE ?`
                }</span>
                <span class="cov0" title="0">whereClause = "(id = ? OR name LIKE ? OR " + commonKeyCol + " = ? OR " + baseURLCol + " LIKE ?) AND " + modelsCol + ` LIKE ? AND ` + groupCondition
                args = append(args, common.String2Int(keyword), "%"+keyword+"%", keyword, "%"+keyword+"%", "%"+model+"%", "%,"+group+",%")</span>
        } else<span class="cov0" title="0"> {
                whereClause = "(id = ? OR name LIKE ? OR " + commonKeyCol + " = ? OR " + baseURLCol + " LIKE ?) AND " + modelsCol + " LIKE ?"
                args = append(args, common.String2Int(keyword), "%"+keyword+"%", keyword, "%"+keyword+"%", "%"+model+"%")
        }</span>

        // 执行查询
        <span class="cov0" title="0">err := baseQuery.Where(whereClause, args...).Order(order).Find(&amp;channels).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return channels, nil</span>
}

func GetChannelById(id int, selectAll bool) (*Channel, error) <span class="cov0" title="0">{
        channel := &amp;Channel{Id: id}
        var err error = nil
        if selectAll </span><span class="cov0" title="0">{
                err = DB.First(channel, "id = ?", id).Error
        }</span> else<span class="cov0" title="0"> {
                err = DB.Omit("key").First(channel, "id = ?", id).Error
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if channel == nil </span><span class="cov0" title="0">{
                return nil, errors.New("channel not found")
        }</span>
        <span class="cov0" title="0">return channel, nil</span>
}

func BatchInsertChannels(channels []Channel) error <span class="cov0" title="0">{
        if len(channels) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">for _, chunk := range lo.Chunk(channels, 50) </span><span class="cov0" title="0">{
                if err := tx.Create(&amp;chunk).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
                <span class="cov0" title="0">for _, channel_ := range chunk </span><span class="cov0" title="0">{
                        if err := channel_.AddAbilities(tx); err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func BatchDeleteChannels(ids []int) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // 使用事务 分批删除channel表和abilities表
        <span class="cov0" title="0">tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">for _, chunk := range lo.Chunk(ids, 200) </span><span class="cov0" title="0">{
                if err := tx.Where("id in (?)", chunk).Delete(&amp;Channel{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
                <span class="cov0" title="0">if err := tx.Where("channel_id in (?)", chunk).Delete(&amp;Ability{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }
        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (channel *Channel) GetPriority() int64 <span class="cov0" title="0">{
        if channel.Priority == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *channel.Priority</span>
}

func (channel *Channel) GetWeight() int <span class="cov0" title="0">{
        if channel.Weight == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int(*channel.Weight)</span>
}

func (channel *Channel) GetBaseURL() string <span class="cov0" title="0">{
        if channel.BaseURL == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">url := *channel.BaseURL
        if url == "" </span><span class="cov0" title="0">{
                url = constant.ChannelBaseURLs[channel.Type]
        }</span>
        <span class="cov0" title="0">return url</span>
}

func (channel *Channel) GetModelMapping() string <span class="cov0" title="0">{
        if channel.ModelMapping == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *channel.ModelMapping</span>
}

func (channel *Channel) GetStatusCodeMapping() string <span class="cov0" title="0">{
        if channel.StatusCodeMapping == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *channel.StatusCodeMapping</span>
}

func (channel *Channel) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(channel).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = channel.AddAbilities(nil)
        return err</span>
}

func (channel *Channel) Update() error <span class="cov0" title="0">{
        // If this is a multi-key channel, recalculate MultiKeySize based on the current key list to avoid inconsistency after editing keys
        if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                var keyStr string
                if channel.Key != "" </span><span class="cov0" title="0">{
                        keyStr = channel.Key
                }</span> else<span class="cov0" title="0"> {
                        // If key is not provided, read the existing key from the database
                        if existing, err := GetChannelById(channel.Id, true); err == nil </span><span class="cov0" title="0">{
                                keyStr = existing.Key
                        }</span>
                }
                // Parse the key list (supports newline separation or JSON array)
                <span class="cov0" title="0">keys := []string{}
                if keyStr != "" </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(keyStr)
                        if strings.HasPrefix(trimmed, "[") </span><span class="cov0" title="0">{
                                var arr []json.RawMessage
                                if err := common.Unmarshal([]byte(trimmed), &amp;arr); err == nil </span><span class="cov0" title="0">{
                                        keys = make([]string, len(arr))
                                        for i, v := range arr </span><span class="cov0" title="0">{
                                                keys[i] = string(v)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if len(keys) == 0 </span><span class="cov0" title="0">{ // fallback to newline split
                                keys = strings.Split(strings.Trim(keyStr, "\n"), "\n")
                        }</span>
                }
                <span class="cov0" title="0">channel.ChannelInfo.MultiKeySize = len(keys)
                // Clean up status data that exceeds the new key count to prevent index out of range
                if channel.ChannelInfo.MultiKeyStatusList != nil </span><span class="cov0" title="0">{
                        for idx := range channel.ChannelInfo.MultiKeyStatusList </span><span class="cov0" title="0">{
                                if idx &gt;= channel.ChannelInfo.MultiKeySize </span><span class="cov0" title="0">{
                                        delete(channel.ChannelInfo.MultiKeyStatusList, idx)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">var err error
        err = DB.Model(channel).Updates(channel).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">DB.Model(channel).First(channel, "id = ?", channel.Id)
        err = channel.UpdateAbilities(nil)
        return err</span>
}

func (channel *Channel) UpdateResponseTime(responseTime int64) <span class="cov0" title="0">{
        err := DB.Model(channel).Select("response_time", "test_time").Updates(Channel{
                TestTime:     common.GetTimestamp(),
                ResponseTime: int(responseTime),
        }).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to update response time: channel_id=%d, error=%v", channel.Id, err))
        }</span>
}

func (channel *Channel) UpdateBalance(balance float64) <span class="cov0" title="0">{
        err := DB.Model(channel).Select("balance_updated_time", "balance").Updates(Channel{
                BalanceUpdatedTime: common.GetTimestamp(),
                Balance:            balance,
        }).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to update balance: channel_id=%d, error=%v", channel.Id, err))
        }</span>
}

func (channel *Channel) Delete() error <span class="cov0" title="0">{
        var err error
        err = DB.Delete(channel).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = channel.DeleteAbilities()
        return err</span>
}

var channelStatusLock sync.Mutex

// channelPollingLocks stores locks for each channel.id to ensure thread-safe polling
var channelPollingLocks sync.Map

// GetChannelPollingLock returns or creates a mutex for the given channel ID
func GetChannelPollingLock(channelId int) *sync.Mutex <span class="cov0" title="0">{
        if lock, exists := channelPollingLocks.Load(channelId); exists </span><span class="cov0" title="0">{
                return lock.(*sync.Mutex)
        }</span>
        // Create new lock for this channel
        <span class="cov0" title="0">newLock := &amp;sync.Mutex{}
        actual, _ := channelPollingLocks.LoadOrStore(channelId, newLock)
        return actual.(*sync.Mutex)</span>
}

// CleanupChannelPollingLocks removes locks for channels that no longer exist
// This is optional and can be called periodically to prevent memory leaks
func CleanupChannelPollingLocks() <span class="cov0" title="0">{
        var activeChannelIds []int
        DB.Model(&amp;Channel{}).Pluck("id", &amp;activeChannelIds)

        activeChannelSet := make(map[int]bool)
        for _, id := range activeChannelIds </span><span class="cov0" title="0">{
                activeChannelSet[id] = true
        }</span>

        <span class="cov0" title="0">channelPollingLocks.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                channelId := key.(int)
                if !activeChannelSet[channelId] </span><span class="cov0" title="0">{
                        channelPollingLocks.Delete(channelId)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
}

func handlerMultiKeyUpdate(channel *Channel, usingKey string, status int, reason string) <span class="cov0" title="0">{
        keys := channel.GetKeys()
        if len(keys) == 0 </span><span class="cov0" title="0">{
                channel.Status = status
        }</span> else<span class="cov0" title="0"> {
                var keyIndex int
                for i, key := range keys </span><span class="cov0" title="0">{
                        if key == usingKey </span><span class="cov0" title="0">{
                                keyIndex = i
                                break</span>
                        }
                }
                <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyStatusList == nil </span><span class="cov0" title="0">{
                        channel.ChannelInfo.MultiKeyStatusList = make(map[int]int)
                }</span>
                <span class="cov0" title="0">if status == common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                        delete(channel.ChannelInfo.MultiKeyStatusList, keyIndex)
                }</span> else<span class="cov0" title="0"> {
                        channel.ChannelInfo.MultiKeyStatusList[keyIndex] = status
                        if channel.ChannelInfo.MultiKeyDisabledReason == nil </span><span class="cov0" title="0">{
                                channel.ChannelInfo.MultiKeyDisabledReason = make(map[int]string)
                        }</span>
                        <span class="cov0" title="0">if channel.ChannelInfo.MultiKeyDisabledTime == nil </span><span class="cov0" title="0">{
                                channel.ChannelInfo.MultiKeyDisabledTime = make(map[int]int64)
                        }</span>
                        <span class="cov0" title="0">channel.ChannelInfo.MultiKeyDisabledReason[keyIndex] = reason
                        channel.ChannelInfo.MultiKeyDisabledTime[keyIndex] = common.GetTimestamp()</span>
                }
                <span class="cov0" title="0">if len(channel.ChannelInfo.MultiKeyStatusList) &gt;= channel.ChannelInfo.MultiKeySize </span><span class="cov0" title="0">{
                        channel.Status = common.ChannelStatusAutoDisabled
                        info := channel.GetOtherInfo()
                        info["status_reason"] = "All keys are disabled"
                        info["status_time"] = common.GetTimestamp()
                        channel.SetOtherInfo(info)
                }</span>
        }
}

func UpdateChannelStatus(channelId int, usingKey string, status int, reason string) bool <span class="cov0" title="0">{
        if common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                channelStatusLock.Lock()
                defer channelStatusLock.Unlock()

                channelCache, _ := CacheGetChannel(channelId)
                if channelCache == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if channelCache.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                        // Use per-channel lock to prevent concurrent map read/write with GetNextEnabledKey
                        pollingLock := GetChannelPollingLock(channelId)
                        pollingLock.Lock()
                        // 如果是多Key模式，更新缓存中的状态
                        handlerMultiKeyUpdate(channelCache, usingKey, status, reason)
                        pollingLock.Unlock()
                        //CacheUpdateChannel(channelCache)
                        //return true
                }</span> else<span class="cov0" title="0"> {
                        // 如果缓存渠道存在，且状态已是目标状态，直接返回
                        if channelCache.Status == status </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">CacheUpdateChannelStatus(channelId, status)</span>
                }
        }

        <span class="cov0" title="0">shouldUpdateAbilities := false
        defer func() </span><span class="cov0" title="0">{
                if shouldUpdateAbilities </span><span class="cov0" title="0">{
                        err := UpdateAbilityStatus(channelId, status == common.ChannelStatusEnabled)
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog(fmt.Sprintf("failed to update ability status: channel_id=%d, error=%v", channelId, err))
                        }</span>
                }
        }()
        <span class="cov0" title="0">channel, err := GetChannelById(channelId, true)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov0" title="0"> {
                if channel.Status == status </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                        beforeStatus := channel.Status
                        // Protect map writes with the same per-channel lock used by readers
                        pollingLock := GetChannelPollingLock(channelId)
                        pollingLock.Lock()
                        handlerMultiKeyUpdate(channel, usingKey, status, reason)
                        pollingLock.Unlock()
                        if beforeStatus != channel.Status </span><span class="cov0" title="0">{
                                shouldUpdateAbilities = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        info := channel.GetOtherInfo()
                        info["status_reason"] = reason
                        info["status_time"] = common.GetTimestamp()
                        channel.SetOtherInfo(info)
                        channel.Status = status
                        shouldUpdateAbilities = true
                }</span>
                <span class="cov0" title="0">err = channel.SaveWithoutKey()
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to update channel status: channel_id=%d, status=%d, error=%v", channel.Id, status, err))
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func EnableChannelByTag(tag string) error <span class="cov0" title="0">{
        err := DB.Model(&amp;Channel{}).Where("tag = ?", tag).Update("status", common.ChannelStatusEnabled).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = UpdateAbilityStatusByTag(tag, true)
        return err</span>
}

func DisableChannelByTag(tag string) error <span class="cov0" title="0">{
        err := DB.Model(&amp;Channel{}).Where("tag = ?", tag).Update("status", common.ChannelStatusManuallyDisabled).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = UpdateAbilityStatusByTag(tag, false)
        return err</span>
}

func EditChannelByTag(tag string, newTag *string, modelMapping *string, models *string, group *string, priority *int64, weight *uint, paramOverride *string, headerOverride *string) error <span class="cov0" title="0">{
        updateData := Channel{}
        shouldReCreateAbilities := false
        updatedTag := tag
        // 如果 newTag 不为空且不等于 tag，则更新 tag
        if newTag != nil &amp;&amp; *newTag != tag </span><span class="cov0" title="0">{
                updateData.Tag = newTag
                updatedTag = *newTag
        }</span>
        <span class="cov0" title="0">if modelMapping != nil &amp;&amp; *modelMapping != "" </span><span class="cov0" title="0">{
                updateData.ModelMapping = modelMapping
        }</span>
        <span class="cov0" title="0">if models != nil &amp;&amp; *models != "" </span><span class="cov0" title="0">{
                shouldReCreateAbilities = true
                updateData.Models = *models
        }</span>
        <span class="cov0" title="0">if group != nil &amp;&amp; *group != "" </span><span class="cov0" title="0">{
                shouldReCreateAbilities = true
                updateData.Group = *group
        }</span>
        <span class="cov0" title="0">if priority != nil </span><span class="cov0" title="0">{
                updateData.Priority = priority
        }</span>
        <span class="cov0" title="0">if weight != nil </span><span class="cov0" title="0">{
                updateData.Weight = weight
        }</span>
        <span class="cov0" title="0">if paramOverride != nil </span><span class="cov0" title="0">{
                updateData.ParamOverride = paramOverride
        }</span>
        <span class="cov0" title="0">if headerOverride != nil </span><span class="cov0" title="0">{
                updateData.HeaderOverride = headerOverride
        }</span>

        <span class="cov0" title="0">err := DB.Model(&amp;Channel{}).Where("tag = ?", tag).Updates(updateData).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if shouldReCreateAbilities </span><span class="cov0" title="0">{
                channels, err := GetChannelsByTag(updatedTag, false, false)
                if err == nil </span><span class="cov0" title="0">{
                        for _, channel := range channels </span><span class="cov0" title="0">{
                                err = channel.UpdateAbilities(nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog(fmt.Sprintf("failed to update abilities: channel_id=%d, tag=%s, error=%v", channel.Id, channel.GetTag(), err))
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                err := UpdateAbilityByTag(tag, newTag, priority, weight)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func UpdateChannelUsedQuota(id int, quota int) <span class="cov0" title="0">{
        if common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeChannelUsedQuota, id, quota)
                return
        }</span>
        <span class="cov0" title="0">updateChannelUsedQuota(id, quota)</span>
}

func updateChannelUsedQuota(id int, quota int) <span class="cov0" title="0">{
        err := DB.Model(&amp;Channel{}).Where("id = ?", id).Update("used_quota", gorm.Expr("used_quota + ?", quota)).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to update channel used quota: channel_id=%d, delta_quota=%d, error=%v", id, quota, err))
        }</span>
}

func DeleteChannelByStatus(status int64) (int64, error) <span class="cov0" title="0">{
        result := DB.Where("status = ?", status).Delete(&amp;Channel{})
        return result.RowsAffected, result.Error
}</span>

func DeleteDisabledChannel() (int64, error) <span class="cov0" title="0">{
        result := DB.Where("status = ? or status = ?", common.ChannelStatusAutoDisabled, common.ChannelStatusManuallyDisabled).Delete(&amp;Channel{})
        return result.RowsAffected, result.Error
}</span>

func GetPaginatedTags(offset int, limit int) ([]*string, error) <span class="cov0" title="0">{
        var tags []*string
        err := DB.Model(&amp;Channel{}).Select("DISTINCT tag").Where("tag != ''").Offset(offset).Limit(limit).Find(&amp;tags).Error
        return tags, err
}</span>

func SearchTags(keyword string, group string, model string, idSort bool) ([]*string, error) <span class="cov0" title="0">{
        var tags []*string
        modelsCol := "`models`"

        // 如果是 PostgreSQL，使用双引号
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                modelsCol = `"models"`
        }</span>

        <span class="cov0" title="0">baseURLCol := "`base_url`"
        // 如果是 PostgreSQL，使用双引号
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                baseURLCol = `"base_url"`
        }</span>

        <span class="cov0" title="0">order := "priority desc"
        if idSort </span><span class="cov0" title="0">{
                order = "id desc"
        }</span>

        // 构造基础查询
        <span class="cov0" title="0">baseQuery := DB.Model(&amp;Channel{}).Omit("key")

        // 构造WHERE子句
        var whereClause string
        var args []interface{}
        if group != "" &amp;&amp; group != "null" </span><span class="cov0" title="0">{
                var groupCondition string
                if common.UsingMySQL </span><span class="cov0" title="0">{
                        groupCondition = `CONCAT(',', ` + commonGroupCol + `, ',') LIKE ?`
                }</span> else<span class="cov0" title="0"> {
                        // sqlite, PostgreSQL
                        groupCondition = `(',' || ` + commonGroupCol + ` || ',') LIKE ?`
                }</span>
                <span class="cov0" title="0">whereClause = "(id = ? OR name LIKE ? OR " + commonKeyCol + " = ? OR " + baseURLCol + " LIKE ?) AND " + modelsCol + ` LIKE ? AND ` + groupCondition
                args = append(args, common.String2Int(keyword), "%"+keyword+"%", keyword, "%"+keyword+"%", "%"+model+"%", "%,"+group+",%")</span>
        } else<span class="cov0" title="0"> {
                whereClause = "(id = ? OR name LIKE ? OR " + commonKeyCol + " = ? OR " + baseURLCol + " LIKE ?) AND " + modelsCol + " LIKE ?"
                args = append(args, common.String2Int(keyword), "%"+keyword+"%", keyword, "%"+keyword+"%", "%"+model+"%")
        }</span>

        <span class="cov0" title="0">subQuery := baseQuery.Where(whereClause, args...).
                Select("tag").
                Where("tag != ''").
                Order(order)

        err := DB.Table("(?) as sub", subQuery).
                Select("DISTINCT tag").
                Find(&amp;tags).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tags, nil</span>
}

func (channel *Channel) ValidateSettings() error <span class="cov0" title="0">{
        channelParams := &amp;dto.ChannelSettings{}
        if channel.Setting != nil &amp;&amp; *channel.Setting != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(*channel.Setting), channelParams)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (channel *Channel) GetSetting() dto.ChannelSettings <span class="cov0" title="0">{
        setting := dto.ChannelSettings{}
        if channel.Setting != nil &amp;&amp; *channel.Setting != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(*channel.Setting), &amp;setting)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to unmarshal setting: channel_id=%d, error=%v", channel.Id, err))
                        channel.Setting = nil // 清空设置以避免后续错误
                        _ = channel.Save()    // 保存修改
                }</span>
        }
        <span class="cov0" title="0">return setting</span>
}

func (channel *Channel) SetSetting(setting dto.ChannelSettings) <span class="cov0" title="0">{
        settingBytes, err := common.Marshal(setting)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to marshal setting: channel_id=%d, error=%v", channel.Id, err))
                return
        }</span>
        <span class="cov0" title="0">channel.Setting = common.GetPointer[string](string(settingBytes))</span>
}

func (channel *Channel) GetOtherSettings() dto.ChannelOtherSettings <span class="cov0" title="0">{
        setting := dto.ChannelOtherSettings{}
        if channel.OtherSettings != "" </span><span class="cov0" title="0">{
                err := common.UnmarshalJsonStr(channel.OtherSettings, &amp;setting)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to unmarshal setting: channel_id=%d, error=%v", channel.Id, err))
                        channel.OtherSettings = "{}" // 清空设置以避免后续错误
                        _ = channel.Save()           // 保存修改
                }</span>
        }
        <span class="cov0" title="0">return setting</span>
}

func (channel *Channel) SetOtherSettings(setting dto.ChannelOtherSettings) <span class="cov0" title="0">{
        settingBytes, err := common.Marshal(setting)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to marshal setting: channel_id=%d, error=%v", channel.Id, err))
                return
        }</span>
        <span class="cov0" title="0">channel.OtherSettings = string(settingBytes)</span>
}

func (channel *Channel) GetParamOverride() map[string]interface{} <span class="cov0" title="0">{
        paramOverride := make(map[string]interface{})
        if channel.ParamOverride != nil &amp;&amp; *channel.ParamOverride != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(*channel.ParamOverride), &amp;paramOverride)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to unmarshal param override: channel_id=%d, error=%v", channel.Id, err))
                }</span>
        }
        <span class="cov0" title="0">return paramOverride</span>
}

func (channel *Channel) GetHeaderOverride() map[string]interface{} <span class="cov0" title="0">{
        headerOverride := make(map[string]interface{})
        if channel.HeaderOverride != nil &amp;&amp; *channel.HeaderOverride != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(*channel.HeaderOverride), &amp;headerOverride)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("failed to unmarshal header override: channel_id=%d, error=%v", channel.Id, err))
                }</span>
        }
        <span class="cov0" title="0">return headerOverride</span>
}

func GetChannelsByIds(ids []int) ([]*Channel, error) <span class="cov0" title="0">{
        var channels []*Channel
        err := DB.Where("id in (?)", ids).Find(&amp;channels).Error
        return channels, err
}</span>

func BatchSetChannelTag(ids []int, tag *string) error <span class="cov0" title="0">{
        // 开启事务
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>

        // 更新标签
        <span class="cov0" title="0">err := tx.Model(&amp;Channel{}).Where("id in (?)", ids).Update("tag", tag).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // update ability status
        <span class="cov0" title="0">channels, err := GetChannelsByIds(ids)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">for _, channel := range channels </span><span class="cov0" title="0">{
                err = channel.UpdateAbilities(tx)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        // 提交事务
        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// CountAllChannels returns total channels in DB
func CountAllChannels() (int64, error) <span class="cov0" title="0">{
        var total int64
        err := DB.Model(&amp;Channel{}).Count(&amp;total).Error
        return total, err
}</span>

// CountAllTags returns number of non-empty distinct tags
func CountAllTags() (int64, error) <span class="cov0" title="0">{
        var total int64
        err := DB.Model(&amp;Channel{}).Where("tag is not null AND tag != ''").Distinct("tag").Count(&amp;total).Error
        return total, err
}</span>

// Get channels of specified type with pagination
func GetChannelsByType(startIdx int, num int, idSort bool, channelType int) ([]*Channel, error) <span class="cov0" title="0">{
        var channels []*Channel
        order := "priority desc"
        if idSort </span><span class="cov0" title="0">{
                order = "id desc"
        }</span>
        <span class="cov0" title="0">err := DB.Where("type = ?", channelType).Order(order).Limit(num).Offset(startIdx).Omit("key").Find(&amp;channels).Error
        return channels, err</span>
}

// Count channels of specific type
func CountChannelsByType(channelType int) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := DB.Model(&amp;Channel{}).Where("type = ?", channelType).Count(&amp;count).Error
        return count, err
}</span>

// Return map[type]count for all channels
func CountChannelsGroupByType() (map[int64]int64, error) <span class="cov0" title="0">{
        type result struct {
                Type  int64 `gorm:"column:type"`
                Count int64 `gorm:"column:count"`
        }
        var results []result
        err := DB.Model(&amp;Channel{}).Select("type, count(*) as count").Group("type").Find(&amp;results).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">counts := make(map[int64]int64)
        for _, r := range results </span><span class="cov0" title="0">{
                counts[r.Type] = r.Count
        }</span>
        <span class="cov0" title="0">return counts, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package model

import (
        "errors"
        "fmt"
        "math/rand"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
)

var group2model2channels map[string]map[string][]int // enabled channel
var channelsIDM map[int]*Channel                     // all channels include disabled
var channelSyncLock sync.RWMutex

func InitChannelCache() <span class="cov0" title="0">{
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">newChannelId2channel := make(map[int]*Channel)
        var channels []*Channel
        DB.Find(&amp;channels)
        for _, channel := range channels </span><span class="cov0" title="0">{
                newChannelId2channel[channel.Id] = channel
        }</span>
        <span class="cov0" title="0">var abilities []*Ability
        DB.Find(&amp;abilities)
        groups := make(map[string]bool)
        for _, ability := range abilities </span><span class="cov0" title="0">{
                groups[ability.Group] = true
        }</span>
        <span class="cov0" title="0">newGroup2model2channels := make(map[string]map[string][]int)
        for group := range groups </span><span class="cov0" title="0">{
                newGroup2model2channels[group] = make(map[string][]int)
        }</span>
        <span class="cov0" title="0">for _, channel := range channels </span><span class="cov0" title="0">{
                if channel.Status != common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                        continue</span> // skip disabled channels
                }
                <span class="cov0" title="0">groups := strings.Split(channel.Group, ",")
                for _, group := range groups </span><span class="cov0" title="0">{
                        models := strings.Split(channel.Models, ",")
                        for _, model := range models </span><span class="cov0" title="0">{
                                if _, ok := newGroup2model2channels[group][model]; !ok </span><span class="cov0" title="0">{
                                        newGroup2model2channels[group][model] = make([]int, 0)
                                }</span>
                                <span class="cov0" title="0">newGroup2model2channels[group][model] = append(newGroup2model2channels[group][model], channel.Id)</span>
                        }
                }
        }

        // sort by priority
        <span class="cov0" title="0">for group, model2channels := range newGroup2model2channels </span><span class="cov0" title="0">{
                for model, channels := range model2channels </span><span class="cov0" title="0">{
                        sort.Slice(channels, func(i, j int) bool </span><span class="cov0" title="0">{
                                return newChannelId2channel[channels[i]].GetPriority() &gt; newChannelId2channel[channels[j]].GetPriority()
                        }</span>)
                        <span class="cov0" title="0">newGroup2model2channels[group][model] = channels</span>
                }
        }

        <span class="cov0" title="0">channelSyncLock.Lock()
        group2model2channels = newGroup2model2channels
        //channelsIDM = newChannelId2channel
        for i, channel := range newChannelId2channel </span><span class="cov0" title="0">{
                if channel.ChannelInfo.IsMultiKey </span><span class="cov0" title="0">{
                        channel.Keys = channel.GetKeys()
                        if channel.ChannelInfo.MultiKeyMode == constant.MultiKeyModePolling </span><span class="cov0" title="0">{
                                if oldChannel, ok := channelsIDM[i]; ok </span><span class="cov0" title="0">{
                                        // 存在旧的渠道，如果是多key且轮询，保留轮询索引信息
                                        if oldChannel.ChannelInfo.IsMultiKey &amp;&amp; oldChannel.ChannelInfo.MultiKeyMode == constant.MultiKeyModePolling </span><span class="cov0" title="0">{
                                                channel.ChannelInfo.MultiKeyPollingIndex = oldChannel.ChannelInfo.MultiKeyPollingIndex
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">channelsIDM = newChannelId2channel
        channelSyncLock.Unlock()
        common.SysLog("channels synced from database")</span>
}

func SyncChannelCache(frequency int) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(frequency) * time.Second)
                common.SysLog("syncing channels from database")
                InitChannelCache()
        }</span>
}

func GetRandomSatisfiedChannel(group string, model string, retry int) (*Channel, error) <span class="cov0" title="0">{
        // if memory cache is disabled, get channel directly from database
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                return GetChannel(group, model, retry)
        }</span>

        <span class="cov0" title="0">channelSyncLock.RLock()
        defer channelSyncLock.RUnlock()

        // First, try to find channels with the exact model name.
        channels := group2model2channels[group][model]

        // If no channels found, try to find channels with the normalized model name.
        if len(channels) == 0 </span><span class="cov0" title="0">{
                normalizedModel := ratio_setting.FormatMatchingModelName(model)
                channels = group2model2channels[group][normalizedModel]
        }</span>

        <span class="cov0" title="0">if len(channels) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(channels) == 1 </span><span class="cov0" title="0">{
                if channel, ok := channelsIDM[channels[0]]; ok </span><span class="cov0" title="0">{
                        return channel, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("数据库一致性错误，渠道# %d 不存在，请联系管理员修复", channels[0])</span>
        }

        <span class="cov0" title="0">uniquePriorities := make(map[int]bool)
        for _, channelId := range channels </span><span class="cov0" title="0">{
                if channel, ok := channelsIDM[channelId]; ok </span><span class="cov0" title="0">{
                        uniquePriorities[int(channel.GetPriority())] = true
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("数据库一致性错误，渠道# %d 不存在，请联系管理员修复", channelId)
                }</span>
        }
        <span class="cov0" title="0">var sortedUniquePriorities []int
        for priority := range uniquePriorities </span><span class="cov0" title="0">{
                sortedUniquePriorities = append(sortedUniquePriorities, priority)
        }</span>
        <span class="cov0" title="0">sort.Sort(sort.Reverse(sort.IntSlice(sortedUniquePriorities)))

        if retry &gt;= len(uniquePriorities) </span><span class="cov0" title="0">{
                retry = len(uniquePriorities) - 1
        }</span>
        <span class="cov0" title="0">targetPriority := int64(sortedUniquePriorities[retry])

        // get the priority for the given retry number
        var sumWeight = 0
        var targetChannels []*Channel
        for _, channelId := range channels </span><span class="cov0" title="0">{
                if channel, ok := channelsIDM[channelId]; ok </span><span class="cov0" title="0">{
                        if channel.GetPriority() == targetPriority </span><span class="cov0" title="0">{
                                sumWeight += channel.GetWeight()
                                targetChannels = append(targetChannels, channel)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("数据库一致性错误，渠道# %d 不存在，请联系管理员修复", channelId)
                }</span>
        }

        <span class="cov0" title="0">if len(targetChannels) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no channel found, group: %s, model: %s, priority: %d", group, model, targetPriority))
        }</span>

        // smoothing factor and adjustment
        <span class="cov0" title="0">smoothingFactor := 1
        smoothingAdjustment := 0

        if sumWeight == 0 </span><span class="cov0" title="0">{
                // when all channels have weight 0, set sumWeight to the number of channels and set smoothing adjustment to 100
                // each channel's effective weight = 100
                sumWeight = len(targetChannels) * 100
                smoothingAdjustment = 100
        }</span> else<span class="cov0" title="0"> if sumWeight/len(targetChannels) &lt; 10 </span><span class="cov0" title="0">{
                // when the average weight is less than 10, set smoothing factor to 100
                smoothingFactor = 100
        }</span>

        // Calculate the total weight of all channels up to endIdx
        <span class="cov0" title="0">totalWeight := sumWeight * smoothingFactor

        // Generate a random value in the range [0, totalWeight)
        randomWeight := rand.Intn(totalWeight)

        // Find a channel based on its weight
        for _, channel := range targetChannels </span><span class="cov0" title="0">{
                randomWeight -= channel.GetWeight()*smoothingFactor + smoothingAdjustment
                if randomWeight &lt; 0 </span><span class="cov0" title="0">{
                        return channel, nil
                }</span>
        }
        // return null if no channel is not found
        <span class="cov0" title="0">return nil, errors.New("channel not found")</span>
}

func CacheGetChannel(id int) (*Channel, error) <span class="cov0" title="0">{
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                return GetChannelById(id, true)
        }</span>
        <span class="cov0" title="0">channelSyncLock.RLock()
        defer channelSyncLock.RUnlock()

        c, ok := channelsIDM[id]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("渠道# %d，已不存在", id)
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

func CacheGetChannelInfo(id int) (*ChannelInfo, error) <span class="cov0" title="0">{
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                channel, err := GetChannelById(id, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;channel.ChannelInfo, nil</span>
        }
        <span class="cov0" title="0">channelSyncLock.RLock()
        defer channelSyncLock.RUnlock()

        c, ok := channelsIDM[id]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("渠道# %d，已不存在", id)
        }</span>
        <span class="cov0" title="0">return &amp;c.ChannelInfo, nil</span>
}

func CacheUpdateChannelStatus(id int, status int) <span class="cov0" title="0">{
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">channelSyncLock.Lock()
        defer channelSyncLock.Unlock()
        if channel, ok := channelsIDM[id]; ok </span><span class="cov0" title="0">{
                channel.Status = status
        }</span>
        <span class="cov0" title="0">if status != common.ChannelStatusEnabled </span><span class="cov0" title="0">{
                // delete the channel from group2model2channels
                for group, model2channels := range group2model2channels </span><span class="cov0" title="0">{
                        for model, channels := range model2channels </span><span class="cov0" title="0">{
                                for i, channelId := range channels </span><span class="cov0" title="0">{
                                        if channelId == id </span><span class="cov0" title="0">{
                                                // remove the channel from the slice
                                                group2model2channels[group][model] = append(channels[:i], channels[i+1:]...)
                                                break</span>
                                        }
                                }
                        }
                }
        }
}

func CacheUpdateChannel(channel *Channel) <span class="cov0" title="0">{
        if !common.MemoryCacheEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">channelSyncLock.Lock()
        defer channelSyncLock.Unlock()
        if channel == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">println("CacheUpdateChannel:", channel.Id, channel.Name, channel.Status, channel.ChannelInfo.MultiKeyPollingIndex)

        println("before:", channelsIDM[channel.Id].ChannelInfo.MultiKeyPollingIndex)
        channelsIDM[channel.Id] = channel
        println("after :", channelsIDM[channel.Id].ChannelInfo.MultiKeyPollingIndex)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package model

import (
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/types"

        "github.com/gin-gonic/gin"

        "github.com/bytedance/gopkg/util/gopool"
        "gorm.io/gorm"
)

type Log struct {
        Id               int    `json:"id" gorm:"index:idx_created_at_id,priority:1"`
        UserId           int    `json:"user_id" gorm:"index"`
        CreatedAt        int64  `json:"created_at" gorm:"bigint;index:idx_created_at_id,priority:2;index:idx_created_at_type"`
        Type             int    `json:"type" gorm:"index:idx_created_at_type"`
        Content          string `json:"content"`
        Username         string `json:"username" gorm:"index;index:index_username_model_name,priority:2;default:''"`
        TokenName        string `json:"token_name" gorm:"index;default:''"`
        ModelName        string `json:"model_name" gorm:"index;index:index_username_model_name,priority:1;default:''"`
        Quota            int    `json:"quota" gorm:"default:0"`
        PromptTokens     int    `json:"prompt_tokens" gorm:"default:0"`
        CompletionTokens int    `json:"completion_tokens" gorm:"default:0"`
        UseTime          int    `json:"use_time" gorm:"default:0"`
        IsStream         bool   `json:"is_stream"`
        ChannelId        int    `json:"channel" gorm:"index"`
        ChannelName      string `json:"channel_name" gorm:"-&gt;"`
        TokenId          int    `json:"token_id" gorm:"default:0;index"`
        Group            string `json:"group" gorm:"index"`
        Ip               string `json:"ip" gorm:"index;default:''"`
        Other            string `json:"other"`
}

// don't use iota, avoid change log type value
const (
        LogTypeUnknown = 0
        LogTypeTopup   = 1
        LogTypeConsume = 2
        LogTypeManage  = 3
        LogTypeSystem  = 4
        LogTypeError   = 5
        LogTypeRefund  = 6
)

func formatUserLogs(logs []*Log) <span class="cov0" title="0">{
        for i := range logs </span><span class="cov0" title="0">{
                logs[i].ChannelName = ""
                var otherMap map[string]interface{}
                otherMap, _ = common.StrToMap(logs[i].Other)
                if otherMap != nil </span><span class="cov0" title="0">{
                        // delete admin
                        delete(otherMap, "admin_info")
                }</span>
                <span class="cov0" title="0">logs[i].Other = common.MapToJsonStr(otherMap)
                logs[i].Id = logs[i].Id % 1024</span>
        }
}

func GetLogByKey(key string) (logs []*Log, err error) <span class="cov0" title="0">{
        if os.Getenv("LOG_SQL_DSN") != "" </span><span class="cov0" title="0">{
                var tk Token
                if err = DB.Model(&amp;Token{}).Where(logKeyCol+"=?", strings.TrimPrefix(key, "sk-")).First(&amp;tk).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = LOG_DB.Model(&amp;Log{}).Where("token_id=?", tk.Id).Find(&amp;logs).Error</span>
        } else<span class="cov0" title="0"> {
                err = LOG_DB.Joins("left join tokens on tokens.id = logs.token_id").Where("tokens.key = ?", strings.TrimPrefix(key, "sk-")).Find(&amp;logs).Error
        }</span>
        <span class="cov0" title="0">formatUserLogs(logs)
        return logs, err</span>
}

func RecordLog(userId int, logType int, content string) <span class="cov0" title="0">{
        if logType == LogTypeConsume &amp;&amp; !common.LogConsumeEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">username, _ := GetUsernameById(userId, false)
        log := &amp;Log{
                UserId:    userId,
                Username:  username,
                CreatedAt: common.GetTimestamp(),
                Type:      logType,
                Content:   content,
        }
        err := LOG_DB.Create(log).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("failed to record log: " + err.Error())
        }</span>
}

func RecordErrorLog(c *gin.Context, userId int, channelId int, modelName string, tokenName string, content string, tokenId int, useTimeSeconds int,
        isStream bool, group string, other map[string]interface{}) <span class="cov0" title="0">{
        logger.LogInfo(c, fmt.Sprintf("record error log: userId=%d, channelId=%d, modelName=%s, tokenName=%s, content=%s", userId, channelId, modelName, tokenName, content))
        username := c.GetString("username")
        otherStr := common.MapToJsonStr(other)
        // 判断是否需要记录 IP
        needRecordIp := false
        if settingMap, err := GetUserSetting(userId, false); err == nil </span><span class="cov0" title="0">{
                if settingMap.RecordIpLog </span><span class="cov0" title="0">{
                        needRecordIp = true
                }</span>
        }
        <span class="cov0" title="0">log := &amp;Log{
                UserId:           userId,
                Username:         username,
                CreatedAt:        common.GetTimestamp(),
                Type:             LogTypeError,
                Content:          content,
                PromptTokens:     0,
                CompletionTokens: 0,
                TokenName:        tokenName,
                ModelName:        modelName,
                Quota:            0,
                ChannelId:        channelId,
                TokenId:          tokenId,
                UseTime:          useTimeSeconds,
                IsStream:         isStream,
                Group:            group,
                Ip: func() string </span><span class="cov0" title="0">{
                        if needRecordIp </span><span class="cov0" title="0">{
                                return c.ClientIP()
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
                Other: otherStr,
        }
        <span class="cov0" title="0">err := LOG_DB.Create(log).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c, "failed to record log: "+err.Error())
        }</span>
}

type RecordConsumeLogParams struct {
        ChannelId        int                    `json:"channel_id"`
        PromptTokens     int                    `json:"prompt_tokens"`
        CompletionTokens int                    `json:"completion_tokens"`
        ModelName        string                 `json:"model_name"`
        TokenName        string                 `json:"token_name"`
        Quota            int                    `json:"quota"`
        Content          string                 `json:"content"`
        TokenId          int                    `json:"token_id"`
        UseTimeSeconds   int                    `json:"use_time_seconds"`
        IsStream         bool                   `json:"is_stream"`
        Group            string                 `json:"group"`
        Other            map[string]interface{} `json:"other"`
}

func RecordConsumeLog(c *gin.Context, userId int, params RecordConsumeLogParams) <span class="cov0" title="0">{
        if !common.LogConsumeEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">logger.LogInfo(c, fmt.Sprintf("record consume log: userId=%d, params=%s", userId, common.GetJsonString(params)))
        username := c.GetString("username")
        otherStr := common.MapToJsonStr(params.Other)
        // 判断是否需要记录 IP
        needRecordIp := false
        if settingMap, err := GetUserSetting(userId, false); err == nil </span><span class="cov0" title="0">{
                if settingMap.RecordIpLog </span><span class="cov0" title="0">{
                        needRecordIp = true
                }</span>
        }
        <span class="cov0" title="0">log := &amp;Log{
                UserId:           userId,
                Username:         username,
                CreatedAt:        common.GetTimestamp(),
                Type:             LogTypeConsume,
                Content:          params.Content,
                PromptTokens:     params.PromptTokens,
                CompletionTokens: params.CompletionTokens,
                TokenName:        params.TokenName,
                ModelName:        params.ModelName,
                Quota:            params.Quota,
                ChannelId:        params.ChannelId,
                TokenId:          params.TokenId,
                UseTime:          params.UseTimeSeconds,
                IsStream:         params.IsStream,
                Group:            params.Group,
                Ip: func() string </span><span class="cov0" title="0">{
                        if needRecordIp </span><span class="cov0" title="0">{
                                return c.ClientIP()
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
                Other: otherStr,
        }
        <span class="cov0" title="0">err := LOG_DB.Create(log).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c, "failed to record log: "+err.Error())
        }</span>
        <span class="cov0" title="0">if common.DataExportEnabled </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        LogQuotaData(userId, username, params.ModelName, params.Quota, common.GetTimestamp(), params.PromptTokens+params.CompletionTokens)
                }</span>)
        }
}

func GetAllLogs(logType int, startTimestamp int64, endTimestamp int64, modelName string, username string, tokenName string, startIdx int, num int, channel int, group string) (logs []*Log, total int64, err error) <span class="cov0" title="0">{
        var tx *gorm.DB
        if logType == LogTypeUnknown </span><span class="cov0" title="0">{
                tx = LOG_DB
        }</span> else<span class="cov0" title="0"> {
                tx = LOG_DB.Where("logs.type = ?", logType)
        }</span>

        <span class="cov0" title="0">if modelName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs.model_name like ?", modelName)
        }</span>
        <span class="cov0" title="0">if username != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs.username = ?", username)
        }</span>
        <span class="cov0" title="0">if tokenName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs.token_name = ?", tokenName)
        }</span>
        <span class="cov0" title="0">if startTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("logs.created_at &gt;= ?", startTimestamp)
        }</span>
        <span class="cov0" title="0">if endTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("logs.created_at &lt;= ?", endTimestamp)
        }</span>
        <span class="cov0" title="0">if channel != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("logs.channel_id = ?", channel)
        }</span>
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs."+logGroupCol+" = ?", group)
        }</span>
        <span class="cov0" title="0">err = tx.Model(&amp;Log{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">err = tx.Order("logs.id desc").Limit(num).Offset(startIdx).Find(&amp;logs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">channelIds := types.NewSet[int]()
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.ChannelId != 0 </span><span class="cov0" title="0">{
                        channelIds.Add(log.ChannelId)
                }</span>
        }

        <span class="cov0" title="0">if channelIds.Len() &gt; 0 </span><span class="cov0" title="0">{
                var channels []struct {
                        Id   int    `gorm:"column:id"`
                        Name string `gorm:"column:name"`
                }
                if err = DB.Table("channels").Select("id, name").Where("id IN ?", channelIds.Items()).Find(&amp;channels).Error; err != nil </span><span class="cov0" title="0">{
                        return logs, total, err
                }</span>
                <span class="cov0" title="0">channelMap := make(map[int]string, len(channels))
                for _, channel := range channels </span><span class="cov0" title="0">{
                        channelMap[channel.Id] = channel.Name
                }</span>
                <span class="cov0" title="0">for i := range logs </span><span class="cov0" title="0">{
                        logs[i].ChannelName = channelMap[logs[i].ChannelId]
                }</span>
        }

        <span class="cov0" title="0">return logs, total, err</span>
}

func GetUserLogs(userId int, logType int, startTimestamp int64, endTimestamp int64, modelName string, tokenName string, startIdx int, num int, group string) (logs []*Log, total int64, err error) <span class="cov0" title="0">{
        var tx *gorm.DB
        if logType == LogTypeUnknown </span><span class="cov0" title="0">{
                tx = LOG_DB.Where("logs.user_id = ?", userId)
        }</span> else<span class="cov0" title="0"> {
                tx = LOG_DB.Where("logs.user_id = ? and logs.type = ?", userId, logType)
        }</span>

        <span class="cov0" title="0">if modelName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs.model_name like ?", modelName)
        }</span>
        <span class="cov0" title="0">if tokenName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs.token_name = ?", tokenName)
        }</span>
        <span class="cov0" title="0">if startTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("logs.created_at &gt;= ?", startTimestamp)
        }</span>
        <span class="cov0" title="0">if endTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("logs.created_at &lt;= ?", endTimestamp)
        }</span>
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                tx = tx.Where("logs."+logGroupCol+" = ?", group)
        }</span>
        <span class="cov0" title="0">err = tx.Model(&amp;Log{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">err = tx.Order("logs.id desc").Limit(num).Offset(startIdx).Find(&amp;logs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">formatUserLogs(logs)
        return logs, total, err</span>
}

func SearchAllLogs(keyword string) (logs []*Log, err error) <span class="cov0" title="0">{
        err = LOG_DB.Where("type = ? or content LIKE ?", keyword, keyword+"%").Order("id desc").Limit(common.MaxRecentItems).Find(&amp;logs).Error
        return logs, err
}</span>

func SearchUserLogs(userId int, keyword string) (logs []*Log, err error) <span class="cov0" title="0">{
        err = LOG_DB.Where("user_id = ? and type = ?", userId, keyword).Order("id desc").Limit(common.MaxRecentItems).Find(&amp;logs).Error
        formatUserLogs(logs)
        return logs, err
}</span>

type Stat struct {
        Quota int `json:"quota"`
        Rpm   int `json:"rpm"`
        Tpm   int `json:"tpm"`
}

func SumUsedQuota(logType int, startTimestamp int64, endTimestamp int64, modelName string, username string, tokenName string, channel int, group string) (stat Stat) <span class="cov0" title="0">{
        tx := LOG_DB.Table("logs").Select("sum(quota) quota")

        // 为rpm和tpm创建单独的查询
        rpmTpmQuery := LOG_DB.Table("logs").Select("count(*) rpm, sum(prompt_tokens) + sum(completion_tokens) tpm")

        if username != "" </span><span class="cov0" title="0">{
                tx = tx.Where("username = ?", username)
                rpmTpmQuery = rpmTpmQuery.Where("username = ?", username)
        }</span>
        <span class="cov0" title="0">if tokenName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("token_name = ?", tokenName)
                rpmTpmQuery = rpmTpmQuery.Where("token_name = ?", tokenName)
        }</span>
        <span class="cov0" title="0">if startTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("created_at &gt;= ?", startTimestamp)
        }</span>
        <span class="cov0" title="0">if endTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("created_at &lt;= ?", endTimestamp)
        }</span>
        <span class="cov0" title="0">if modelName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("model_name like ?", modelName)
                rpmTpmQuery = rpmTpmQuery.Where("model_name like ?", modelName)
        }</span>
        <span class="cov0" title="0">if channel != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("channel_id = ?", channel)
                rpmTpmQuery = rpmTpmQuery.Where("channel_id = ?", channel)
        }</span>
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                tx = tx.Where(logGroupCol+" = ?", group)
                rpmTpmQuery = rpmTpmQuery.Where(logGroupCol+" = ?", group)
        }</span>

        <span class="cov0" title="0">tx = tx.Where("type = ?", LogTypeConsume)
        rpmTpmQuery = rpmTpmQuery.Where("type = ?", LogTypeConsume)

        // 只统计最近60秒的rpm和tpm
        rpmTpmQuery = rpmTpmQuery.Where("created_at &gt;= ?", time.Now().Add(-60*time.Second).Unix())

        // 执行查询
        tx.Scan(&amp;stat)
        rpmTpmQuery.Scan(&amp;stat)

        return stat</span>
}

func SumUsedToken(logType int, startTimestamp int64, endTimestamp int64, modelName string, username string, tokenName string) (token int) <span class="cov0" title="0">{
        tx := LOG_DB.Table("logs").Select("ifnull(sum(prompt_tokens),0) + ifnull(sum(completion_tokens),0)")
        if username != "" </span><span class="cov0" title="0">{
                tx = tx.Where("username = ?", username)
        }</span>
        <span class="cov0" title="0">if tokenName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("token_name = ?", tokenName)
        }</span>
        <span class="cov0" title="0">if startTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("created_at &gt;= ?", startTimestamp)
        }</span>
        <span class="cov0" title="0">if endTimestamp != 0 </span><span class="cov0" title="0">{
                tx = tx.Where("created_at &lt;= ?", endTimestamp)
        }</span>
        <span class="cov0" title="0">if modelName != "" </span><span class="cov0" title="0">{
                tx = tx.Where("model_name = ?", modelName)
        }</span>
        <span class="cov0" title="0">tx.Where("type = ?", LogTypeConsume).Scan(&amp;token)
        return token</span>
}

func DeleteOldLog(ctx context.Context, targetTimestamp int64, limit int) (int64, error) <span class="cov0" title="0">{
        var total int64 = 0

        for </span><span class="cov0" title="0">{
                if nil != ctx.Err() </span><span class="cov0" title="0">{
                        return total, ctx.Err()
                }</span>

                <span class="cov0" title="0">result := LOG_DB.Where("created_at &lt; ?", targetTimestamp).Limit(limit).Delete(&amp;Log{})
                if nil != result.Error </span><span class="cov0" title="0">{
                        return total, result.Error
                }</span>

                <span class="cov0" title="0">total += result.RowsAffected

                if result.RowsAffected &lt; int64(limit) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package model

import (
        "fmt"
        "log"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"

        "github.com/glebarez/sqlite"
        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var commonGroupCol string
var commonKeyCol string
var commonTrueVal string
var commonFalseVal string

var logKeyCol string
var logGroupCol string

func initCol() <span class="cov0" title="0">{
        // init common column names
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                commonGroupCol = `"group"`
                commonKeyCol = `"key"`
                commonTrueVal = "true"
                commonFalseVal = "false"
        }</span> else<span class="cov0" title="0"> {
                commonGroupCol = "`group`"
                commonKeyCol = "`key`"
                commonTrueVal = "1"
                commonFalseVal = "0"
        }</span>
        <span class="cov0" title="0">if os.Getenv("LOG_SQL_DSN") != "" </span><span class="cov0" title="0">{
                switch common.LogSqlType </span>{
                case common.DatabaseTypePostgreSQL:<span class="cov0" title="0">
                        logGroupCol = `"group"`
                        logKeyCol = `"key"`</span>
                default:<span class="cov0" title="0">
                        logGroupCol = commonGroupCol
                        logKeyCol = commonKeyCol</span>
                }
        } else<span class="cov0" title="0"> {
                // LOG_SQL_DSN 为空时，日志数据库与主数据库相同
                if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                        logGroupCol = `"group"`
                        logKeyCol = `"key"`
                }</span> else<span class="cov0" title="0"> {
                        logGroupCol = commonGroupCol
                        logKeyCol = commonKeyCol
                }</span>
        }
        // log sql type and database type
        //common.SysLog("Using Log SQL Type: " + common.LogSqlType)
}

var DB *gorm.DB

var LOG_DB *gorm.DB

func createRootAccountIfNeed() error <span class="cov0" title="0">{
        var user User
        //if user.Status != common.UserStatusEnabled {
        if err := DB.First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                common.SysLog("no user exists, create a root user for you: username is root, password is 123456")
                hashedPassword, err := common.Password2Hash("123456")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rootUser := User{
                        Username:    "root",
                        Password:    hashedPassword,
                        Role:        common.RoleRootUser,
                        Status:      common.UserStatusEnabled,
                        DisplayName: "Root User",
                        AccessToken: nil,
                        Quota:       100000000,
                }
                DB.Create(&amp;rootUser)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func CheckSetup() <span class="cov0" title="0">{
        setup := GetSetup()
        if setup == nil </span><span class="cov0" title="0">{
                // No setup record exists, check if we have a root user
                if RootUserExists() </span><span class="cov0" title="0">{
                        common.SysLog("system is not initialized, but root user exists")
                        // Create setup record
                        newSetup := Setup{
                                Version:       common.Version,
                                InitializedAt: time.Now().Unix(),
                        }
                        err := DB.Create(&amp;newSetup).Error
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog("failed to create setup record: " + err.Error())
                        }</span>
                        <span class="cov0" title="0">constant.Setup = true</span>
                } else<span class="cov0" title="0"> {
                        common.SysLog("system is not initialized and no root user exists")
                        constant.Setup = false
                }</span>
        } else<span class="cov0" title="0"> {
                // Setup record exists, system is initialized
                common.SysLog("system is already initialized at: " + time.Unix(setup.InitializedAt, 0).String())
                constant.Setup = true
        }</span>
}

func chooseDB(envName string, isLog bool) (*gorm.DB, error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                initCol()
        }</span>()
        <span class="cov0" title="0">dsn := os.Getenv(envName)
        if dsn != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(dsn, "postgres://") || strings.HasPrefix(dsn, "postgresql://") </span><span class="cov0" title="0">{
                        // Use PostgreSQL
                        common.SysLog("using PostgreSQL as database")
                        if !isLog </span><span class="cov0" title="0">{
                                common.UsingPostgreSQL = true
                        }</span> else<span class="cov0" title="0"> {
                                common.LogSqlType = common.DatabaseTypePostgreSQL
                        }</span>
                        <span class="cov0" title="0">return gorm.Open(postgres.New(postgres.Config{
                                DSN:                  dsn,
                                PreferSimpleProtocol: true, // disables implicit prepared statement usage
                        }), &amp;gorm.Config{
                                PrepareStmt: true, // precompile SQL
                        })</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(dsn, "local") </span><span class="cov0" title="0">{
                        common.SysLog("SQL_DSN not set, using SQLite as database")
                        if !isLog </span><span class="cov0" title="0">{
                                common.UsingSQLite = true
                        }</span> else<span class="cov0" title="0"> {
                                common.LogSqlType = common.DatabaseTypeSQLite
                        }</span>
                        <span class="cov0" title="0">return gorm.Open(sqlite.Open(common.SQLitePath), &amp;gorm.Config{
                                PrepareStmt: true, // precompile SQL
                        })</span>
                }
                // Use MySQL
                <span class="cov0" title="0">common.SysLog("using MySQL as database")
                // check parseTime
                if !strings.Contains(dsn, "parseTime") </span><span class="cov0" title="0">{
                        if strings.Contains(dsn, "?") </span><span class="cov0" title="0">{
                                dsn += "&amp;parseTime=true"
                        }</span> else<span class="cov0" title="0"> {
                                dsn += "?parseTime=true"
                        }</span>
                }
                <span class="cov0" title="0">if !isLog </span><span class="cov0" title="0">{
                        common.UsingMySQL = true
                }</span> else<span class="cov0" title="0"> {
                        common.LogSqlType = common.DatabaseTypeMySQL
                }</span>
                <span class="cov0" title="0">return gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
                        PrepareStmt: true, // precompile SQL
                })</span>
        }
        // Use SQLite
        <span class="cov0" title="0">common.SysLog("SQL_DSN not set, using SQLite as database")
        common.UsingSQLite = true
        return gorm.Open(sqlite.Open(common.SQLitePath), &amp;gorm.Config{
                PrepareStmt: true, // precompile SQL
        })</span>
}

func InitDB() (err error) <span class="cov0" title="0">{
        db, err := chooseDB("SQL_DSN", false)
        if err == nil </span><span class="cov0" title="0">{
                if common.DebugEnabled </span><span class="cov0" title="0">{
                        db = db.Debug()
                }</span>
                <span class="cov0" title="0">DB = db
                // MySQL charset/collation startup check: ensure Chinese-capable charset
                if common.UsingMySQL </span><span class="cov0" title="0">{
                        if err := checkMySQLChineseSupport(DB); err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
                <span class="cov0" title="0">sqlDB, err := DB.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(common.GetEnvOrDefault("SQL_MAX_IDLE_CONNS", 100))
                sqlDB.SetMaxOpenConns(common.GetEnvOrDefault("SQL_MAX_OPEN_CONNS", 1000))
                sqlDB.SetConnMaxLifetime(time.Second * time.Duration(common.GetEnvOrDefault("SQL_MAX_LIFETIME", 60)))

                if !common.IsMasterNode </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if common.UsingMySQL </span>{<span class="cov0" title="0">
                        //_, _ = sqlDB.Exec("ALTER TABLE channels MODIFY model_mapping TEXT;") // TODO: delete this line when most users have upgraded
                }</span>
                <span class="cov0" title="0">common.SysLog("database migration started")
                err = migrateDB()
                return err</span>
        } else<span class="cov0" title="0"> {
                common.FatalLog(err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func InitLogDB() (err error) <span class="cov0" title="0">{
        if os.Getenv("LOG_SQL_DSN") == "" </span><span class="cov0" title="0">{
                LOG_DB = DB
                return
        }</span>
        <span class="cov0" title="0">db, err := chooseDB("LOG_SQL_DSN", true)
        if err == nil </span><span class="cov0" title="0">{
                if common.DebugEnabled </span><span class="cov0" title="0">{
                        db = db.Debug()
                }</span>
                <span class="cov0" title="0">LOG_DB = db
                // If log DB is MySQL, also ensure Chinese-capable charset
                if common.LogSqlType == common.DatabaseTypeMySQL </span><span class="cov0" title="0">{
                        if err := checkMySQLChineseSupport(LOG_DB); err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
                <span class="cov0" title="0">sqlDB, err := LOG_DB.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(common.GetEnvOrDefault("SQL_MAX_IDLE_CONNS", 100))
                sqlDB.SetMaxOpenConns(common.GetEnvOrDefault("SQL_MAX_OPEN_CONNS", 1000))
                sqlDB.SetConnMaxLifetime(time.Second * time.Duration(common.GetEnvOrDefault("SQL_MAX_LIFETIME", 60)))

                if !common.IsMasterNode </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">common.SysLog("database migration started")
                err = migrateLOGDB()
                return err</span>
        } else<span class="cov0" title="0"> {
                common.FatalLog(err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func migrateDB() error <span class="cov0" title="0">{
        err := DB.AutoMigrate(
                &amp;Channel{},
                &amp;Token{},
                &amp;User{},
                &amp;PasskeyCredential{},
                &amp;Option{},
                &amp;Redemption{},
                &amp;Ability{},
                &amp;Log{},
                &amp;Midjourney{},
                &amp;TopUp{},
                &amp;QuotaData{},
                &amp;Task{},
                &amp;Model{},
                &amp;Vendor{},
                &amp;PrefillGroup{},
                &amp;Setup{},
                &amp;TwoFA{},
                &amp;TwoFABackupCode{},
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func migrateDBFast() error <span class="cov0" title="0">{

        var wg sync.WaitGroup

        migrations := []struct {
                model interface{}
                name  string
        }{
                {&amp;Channel{}, "Channel"},
                {&amp;Token{}, "Token"},
                {&amp;User{}, "User"},
                {&amp;PasskeyCredential{}, "PasskeyCredential"},
                {&amp;Option{}, "Option"},
                {&amp;Redemption{}, "Redemption"},
                {&amp;Ability{}, "Ability"},
                {&amp;Log{}, "Log"},
                {&amp;Midjourney{}, "Midjourney"},
                {&amp;TopUp{}, "TopUp"},
                {&amp;QuotaData{}, "QuotaData"},
                {&amp;Task{}, "Task"},
                {&amp;Model{}, "Model"},
                {&amp;Vendor{}, "Vendor"},
                {&amp;PrefillGroup{}, "PrefillGroup"},
                {&amp;Setup{}, "Setup"},
                {&amp;TwoFA{}, "TwoFA"},
                {&amp;TwoFABackupCode{}, "TwoFABackupCode"},
        }
        // 动态计算migration数量，确保errChan缓冲区足够大
        errChan := make(chan error, len(migrations))

        for _, m := range migrations </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(model interface{}, name string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := DB.AutoMigrate(model); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("failed to migrate %s: %v", name, err)
                        }</span>
                }(m.model, m.name)
        }

        // Wait for all migrations to complete
        <span class="cov0" title="0">wg.Wait()
        close(errChan)

        // Check for any errors
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">common.SysLog("database migrated")
        return nil</span>
}

func migrateLOGDB() error <span class="cov0" title="0">{
        var err error
        if err = LOG_DB.AutoMigrate(&amp;Log{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func closeDB(db *gorm.DB) error <span class="cov0" title="0">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = sqlDB.Close()
        return err</span>
}

func CloseDB() error <span class="cov0" title="0">{
        if LOG_DB != DB </span><span class="cov0" title="0">{
                err := closeDB(LOG_DB)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return closeDB(DB)</span>
}

// checkMySQLChineseSupport ensures the MySQL connection and current schema
// default charset/collation can store Chinese characters. It allows common
// Chinese-capable charsets (utf8mb4, utf8, gbk, big5, gb18030) and panics otherwise.
func checkMySQLChineseSupport(db *gorm.DB) error <span class="cov0" title="0">{
        // 仅检测：当前库默认字符集/排序规则 + 各表的排序规则（隐含字符集）

        // Read current schema defaults
        var schemaCharset, schemaCollation string
        err := db.Raw("SELECT DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME FROM information_schema.SCHEMATA WHERE SCHEMA_NAME = DATABASE()").Row().Scan(&amp;schemaCharset, &amp;schemaCollation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取当前库默认字符集/排序规则失败 / Failed to read schema default charset/collation: %v", err)
        }</span>

        <span class="cov0" title="0">toLower := func(s string) string </span><span class="cov0" title="0">{ return strings.ToLower(s) }</span>
        // Allowed charsets that can store Chinese text
        <span class="cov0" title="0">allowedCharsets := map[string]string{
                "utf8mb4": "utf8mb4_",
                "utf8":    "utf8_",
                "gbk":     "gbk_",
                "big5":    "big5_",
                "gb18030": "gb18030_",
        }
        isChineseCapable := func(cs, cl string) bool </span><span class="cov0" title="0">{
                csLower := toLower(cs)
                clLower := toLower(cl)
                if prefix, ok := allowedCharsets[csLower]; ok </span><span class="cov0" title="0">{
                        if clLower == "" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">return strings.HasPrefix(clLower, prefix)</span>
                }
                // 如果仅提供了排序规则，尝试按排序规则前缀判断
                <span class="cov0" title="0">for _, prefix := range allowedCharsets </span><span class="cov0" title="0">{
                        if strings.HasPrefix(clLower, prefix) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }

        // 1) 当前库默认值必须支持中文
        <span class="cov0" title="0">if !isChineseCapable(schemaCharset, schemaCollation) </span><span class="cov0" title="0">{
                return fmt.Errorf("当前库默认字符集/排序规则不支持中文：schema(%s/%s)。请将库设置为 utf8mb4/utf8/gbk/big5/gb18030 / Schema default charset/collation is not Chinese-capable: schema(%s/%s). Please set to utf8mb4/utf8/gbk/big5/gb18030",
                        schemaCharset, schemaCollation, schemaCharset, schemaCollation)
        }</span>

        // 2) 所有物理表的排序规则（隐含字符集）必须支持中文
        <span class="cov0" title="0">type tableInfo struct {
                Name      string
                Collation *string
        }
        var tables []tableInfo
        if err := db.Raw("SELECT TABLE_NAME, TABLE_COLLATION FROM information_schema.TABLES WHERE TABLE_SCHEMA = DATABASE() AND TABLE_TYPE = 'BASE TABLE'").Scan(&amp;tables).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取表排序规则失败 / Failed to read table collations: %v", err)
        }</span>

        <span class="cov0" title="0">var badTables []string
        for _, t := range tables </span><span class="cov0" title="0">{
                // NULL 或空表示继承库默认设置，已在上面校验库默认，视为通过
                if t.Collation == nil || *t.Collation == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">cl := *t.Collation
                // 仅凭排序规则判断是否中文可用
                ok := false
                lower := strings.ToLower(cl)
                for _, prefix := range allowedCharsets </span><span class="cov0" title="0">{
                        if strings.HasPrefix(lower, prefix) </span><span class="cov0" title="0">{
                                ok = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        badTables = append(badTables, fmt.Sprintf("%s(%s)", t.Name, cl))
                }</span>
        }

        <span class="cov0" title="0">if len(badTables) &gt; 0 </span><span class="cov0" title="0">{
                // 限制输出数量以避免日志过长
                maxShow := 20
                shown := badTables
                if len(shown) &gt; maxShow </span><span class="cov0" title="0">{
                        shown = shown[:maxShow]
                }</span>
                <span class="cov0" title="0">return fmt.Errorf(
                        "存在不支持中文的表，请修复其排序规则/字符集。示例（最多展示 %d 项）：%v / Found tables not Chinese-capable. Please fix their collation/charset. Examples (showing up to %d): %v",
                        maxShow, shown, maxShow, shown,
                )</span>
        }
        <span class="cov0" title="0">return nil</span>
}

var (
        lastPingTime time.Time
        pingMutex    sync.Mutex
)

func PingDB() error <span class="cov0" title="0">{
        pingMutex.Lock()
        defer pingMutex.Unlock()

        if time.Since(lastPingTime) &lt; time.Second*10 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting sql.DB from GORM: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">err = sqlDB.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error pinging DB: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">lastPingTime = time.Now()
        common.SysLog("Database pinged successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package model

type Midjourney struct {
        Id          int    `json:"id"`
        Code        int    `json:"code"`
        UserId      int    `json:"user_id" gorm:"index"`
        Action      string `json:"action" gorm:"type:varchar(40);index"`
        MjId        string `json:"mj_id" gorm:"index"`
        Prompt      string `json:"prompt"`
        PromptEn    string `json:"prompt_en"`
        Description string `json:"description"`
        State       string `json:"state"`
        SubmitTime  int64  `json:"submit_time" gorm:"index"`
        StartTime   int64  `json:"start_time" gorm:"index"`
        FinishTime  int64  `json:"finish_time" gorm:"index"`
        ImageUrl    string `json:"image_url"`
        VideoUrl    string `json:"video_url"`
        VideoUrls   string `json:"video_urls"`
        Status      string `json:"status" gorm:"type:varchar(20);index"`
        Progress    string `json:"progress" gorm:"type:varchar(30);index"`
        FailReason  string `json:"fail_reason"`
        ChannelId   int    `json:"channel_id"`
        Quota       int    `json:"quota"`
        Buttons     string `json:"buttons"`
        Properties  string `json:"properties"`
}

// TaskQueryParams 用于包含所有搜索条件的结构体，可以根据需求添加更多字段
type TaskQueryParams struct {
        ChannelID      string
        MjID           string
        StartTimestamp string
        EndTimestamp   string
}

func GetAllUserTask(userId int, startIdx int, num int, queryParams TaskQueryParams) []*Midjourney <span class="cov0" title="0">{
        var tasks []*Midjourney
        var err error

        // 初始化查询构建器
        query := DB.Where("user_id = ?", userId)

        if queryParams.MjID != "" </span><span class="cov0" title="0">{
                query = query.Where("mj_id = ?", queryParams.MjID)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != "" </span><span class="cov0" title="0">{
                // 假设您已将前端传来的时间戳转换为数据库所需的时间格式，并处理了时间戳的验证和解析
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>

        // 获取数据
        <span class="cov0" title="0">err = query.Order("id desc").Limit(num).Offset(startIdx).Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

func GetAllTasks(startIdx int, num int, queryParams TaskQueryParams) []*Midjourney <span class="cov0" title="0">{
        var tasks []*Midjourney
        var err error

        // 初始化查询构建器
        query := DB

        // 添加过滤条件
        if queryParams.ChannelID != "" </span><span class="cov0" title="0">{
                query = query.Where("channel_id = ?", queryParams.ChannelID)
        }</span>
        <span class="cov0" title="0">if queryParams.MjID != "" </span><span class="cov0" title="0">{
                query = query.Where("mj_id = ?", queryParams.MjID)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>

        // 获取数据
        <span class="cov0" title="0">err = query.Order("id desc").Limit(num).Offset(startIdx).Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

func GetAllUnFinishTasks() []*Midjourney <span class="cov0" title="0">{
        var tasks []*Midjourney
        var err error
        // get all tasks progress is not 100%
        err = DB.Where("progress != ?", "100%").Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tasks</span>
}

func GetByOnlyMJId(mjId string) *Midjourney <span class="cov0" title="0">{
        var mj *Midjourney
        var err error
        err = DB.Where("mj_id = ?", mjId).First(&amp;mj).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return mj</span>
}

func GetByMJId(userId int, mjId string) *Midjourney <span class="cov0" title="0">{
        var mj *Midjourney
        var err error
        err = DB.Where("user_id = ? and mj_id = ?", userId, mjId).First(&amp;mj).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return mj</span>
}

func GetByMJIds(userId int, mjIds []string) []*Midjourney <span class="cov0" title="0">{
        var mj []*Midjourney
        var err error
        err = DB.Where("user_id = ? and mj_id in (?)", userId, mjIds).Find(&amp;mj).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return mj</span>
}

func GetMjByuId(id int) *Midjourney <span class="cov0" title="0">{
        var mj *Midjourney
        var err error
        err = DB.Where("id = ?", id).First(&amp;mj).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return mj</span>
}

func UpdateProgress(id int, progress string) error <span class="cov0" title="0">{
        return DB.Model(&amp;Midjourney{}).Where("id = ?", id).Update("progress", progress).Error
}</span>

func (midjourney *Midjourney) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(midjourney).Error
        return err
}</span>

func (midjourney *Midjourney) Update() error <span class="cov0" title="0">{
        var err error
        err = DB.Save(midjourney).Error
        return err
}</span>

func MjBulkUpdate(mjIds []string, params map[string]any) error <span class="cov0" title="0">{
        return DB.Model(&amp;Midjourney{}).
                Where("mj_id in (?)", mjIds).
                Updates(params).Error
}</span>

func MjBulkUpdateByTaskIds(taskIDs []int, params map[string]any) error <span class="cov0" title="0">{
        return DB.Model(&amp;Midjourney{}).
                Where("id in (?)", taskIDs).
                Updates(params).Error
}</span>

// CountAllTasks returns total midjourney tasks for admin query
func CountAllTasks(queryParams TaskQueryParams) int64 <span class="cov0" title="0">{
        var total int64
        query := DB.Model(&amp;Midjourney{})
        if queryParams.ChannelID != "" </span><span class="cov0" title="0">{
                query = query.Where("channel_id = ?", queryParams.ChannelID)
        }</span>
        <span class="cov0" title="0">if queryParams.MjID != "" </span><span class="cov0" title="0">{
                query = query.Where("mj_id = ?", queryParams.MjID)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>
        <span class="cov0" title="0">_ = query.Count(&amp;total).Error
        return total</span>
}

// CountAllUserTask returns total midjourney tasks for user
func CountAllUserTask(userId int, queryParams TaskQueryParams) int64 <span class="cov0" title="0">{
        var total int64
        query := DB.Model(&amp;Midjourney{}).Where("user_id = ?", userId)
        if queryParams.MjID != "" </span><span class="cov0" title="0">{
                query = query.Where("mj_id = ?", queryParams.MjID)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != "" </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>
        <span class="cov0" title="0">_ = query.Count(&amp;total).Error
        return total</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package model

// GetMissingModels returns model names that are referenced in the system
func GetMissingModels() ([]string, error) <span class="cov0" title="0">{
        // 1. 获取所有已启用模型（去重）
        models := GetEnabledModels()
        if len(models) == 0 </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>

        // 2. 查询已有的元数据模型名
        <span class="cov0" title="0">var existing []string
        if err := DB.Model(&amp;Model{}).Where("model_name IN ?", models).Pluck("model_name", &amp;existing).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">existingSet := make(map[string]struct{}, len(existing))
        for _, e := range existing </span><span class="cov0" title="0">{
                existingSet[e] = struct{}{}
        }</span>

        // 3. 收集缺失模型
        <span class="cov0" title="0">var missing []string
        for _, name := range models </span><span class="cov0" title="0">{
                if _, ok := existingSet[name]; !ok </span><span class="cov0" title="0">{
                        missing = append(missing, name)
                }</span>
        }
        <span class="cov0" title="0">return missing, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package model

func GetModelEnableGroups(modelName string) []string <span class="cov0" title="0">{
        // 确保缓存最新
        GetPricing()

        if modelName == "" </span><span class="cov0" title="0">{
                return make([]string, 0)
        }</span>

        <span class="cov0" title="0">modelEnableGroupsLock.RLock()
        groups, ok := modelEnableGroups[modelName]
        modelEnableGroupsLock.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return make([]string, 0)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

// GetModelQuotaTypes 返回指定模型的计费类型集合（来自缓存）
func GetModelQuotaTypes(modelName string) []int <span class="cov0" title="0">{
        GetPricing()

        modelEnableGroupsLock.RLock()
        quota, ok := modelQuotaTypeMap[modelName]
        modelEnableGroupsLock.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return []int{}
        }</span>
        <span class="cov0" title="0">return []int{quota}</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package model

import (
        "strconv"

        "github.com/QuantumNous/new-api/common"

        "gorm.io/gorm"
)

const (
        NameRuleExact = iota
        NameRulePrefix
        NameRuleContains
        NameRuleSuffix
)

type BoundChannel struct {
        Name string `json:"name"`
        Type int    `json:"type"`
}

type Model struct {
        Id           int            `json:"id"`
        ModelName    string         `json:"model_name" gorm:"size:128;not null;uniqueIndex:uk_model_name_delete_at,priority:1"`
        Description  string         `json:"description,omitempty" gorm:"type:text"`
        Icon         string         `json:"icon,omitempty" gorm:"type:varchar(128)"`
        Tags         string         `json:"tags,omitempty" gorm:"type:varchar(255)"`
        VendorID     int            `json:"vendor_id,omitempty" gorm:"index"`
        Endpoints    string         `json:"endpoints,omitempty" gorm:"type:text"`
        Status       int            `json:"status" gorm:"default:1"`
        SyncOfficial int            `json:"sync_official" gorm:"default:1"`
        CreatedTime  int64          `json:"created_time" gorm:"bigint"`
        UpdatedTime  int64          `json:"updated_time" gorm:"bigint"`
        DeletedAt    gorm.DeletedAt `json:"-" gorm:"index;uniqueIndex:uk_model_name_delete_at,priority:2"`

        BoundChannels []BoundChannel `json:"bound_channels,omitempty" gorm:"-"`
        EnableGroups  []string       `json:"enable_groups,omitempty" gorm:"-"`
        QuotaTypes    []int          `json:"quota_types,omitempty" gorm:"-"`
        NameRule      int            `json:"name_rule" gorm:"default:0"`

        MatchedModels []string `json:"matched_models,omitempty" gorm:"-"`
        MatchedCount  int      `json:"matched_count,omitempty" gorm:"-"`
}

func (mi *Model) Insert() error <span class="cov0" title="0">{
        now := common.GetTimestamp()
        mi.CreatedTime = now
        mi.UpdatedTime = now
        return DB.Create(mi).Error
}</span>

func IsModelNameDuplicated(id int, name string) (bool, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">var cnt int64
        err := DB.Model(&amp;Model{}).Where("model_name = ? AND id &lt;&gt; ?", name, id).Count(&amp;cnt).Error
        return cnt &gt; 0, err</span>
}

func (mi *Model) Update() error <span class="cov0" title="0">{
        mi.UpdatedTime = common.GetTimestamp()
        return DB.Session(&amp;gorm.Session{AllowGlobalUpdate: false, FullSaveAssociations: false}).
                Model(&amp;Model{}).
                Where("id = ?", mi.Id).
                Omit("created_time").
                Select("*").
                Updates(mi).Error
}</span>

func (mi *Model) Delete() error <span class="cov0" title="0">{
        return DB.Delete(mi).Error
}</span>

func GetVendorModelCounts() (map[int64]int64, error) <span class="cov0" title="0">{
        var stats []struct {
                VendorID int64
                Count    int64
        }
        if err := DB.Model(&amp;Model{}).
                Select("vendor_id as vendor_id, count(*) as count").
                Group("vendor_id").
                Scan(&amp;stats).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">m := make(map[int64]int64, len(stats))
        for _, s := range stats </span><span class="cov0" title="0">{
                m[s.VendorID] = s.Count
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func GetAllModels(offset int, limit int) ([]*Model, error) <span class="cov0" title="0">{
        var models []*Model
        err := DB.Order("id DESC").Offset(offset).Limit(limit).Find(&amp;models).Error
        return models, err
}</span>

func GetBoundChannelsByModelsMap(modelNames []string) (map[string][]BoundChannel, error) <span class="cov0" title="0">{
        result := make(map[string][]BoundChannel)
        if len(modelNames) == 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>
        <span class="cov0" title="0">type row struct {
                Model string
                Name  string
                Type  int
        }
        var rows []row
        err := DB.Table("channels").
                Select("abilities.model as model, channels.name as name, channels.type as type").
                Joins("JOIN abilities ON abilities.channel_id = channels.id").
                Where("abilities.model IN ? AND abilities.enabled = ?", modelNames, true).
                Distinct().
                Scan(&amp;rows).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, r := range rows </span><span class="cov0" title="0">{
                result[r.Model] = append(result[r.Model], BoundChannel{Name: r.Name, Type: r.Type})
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func SearchModels(keyword string, vendor string, offset int, limit int) ([]*Model, int64, error) <span class="cov0" title="0">{
        var models []*Model
        db := DB.Model(&amp;Model{})
        if keyword != "" </span><span class="cov0" title="0">{
                like := "%" + keyword + "%"
                db = db.Where("model_name LIKE ? OR description LIKE ? OR tags LIKE ?", like, like, like)
        }</span>
        <span class="cov0" title="0">if vendor != "" </span><span class="cov0" title="0">{
                if vid, err := strconv.Atoi(vendor); err == nil </span><span class="cov0" title="0">{
                        db = db.Where("models.vendor_id = ?", vid)
                }</span> else<span class="cov0" title="0"> {
                        db = db.Joins("JOIN vendors ON vendors.id = models.vendor_id").Where("vendors.name LIKE ?", "%"+vendor+"%")
                }</span>
        }
        <span class="cov0" title="0">var total int64
        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if err := db.Order("models.id DESC").Offset(offset).Limit(limit).Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return models, total, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package model

import (
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/config"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"
)

type Option struct {
        Key   string `json:"key" gorm:"primaryKey"`
        Value string `json:"value"`
}

func AllOption() ([]*Option, error) <span class="cov0" title="0">{
        var options []*Option
        var err error
        err = DB.Find(&amp;options).Error
        return options, err
}</span>

func InitOptionMap() <span class="cov0" title="0">{
        common.OptionMapRWMutex.Lock()
        common.OptionMap = make(map[string]string)

        // 添加原有的系统配置
        common.OptionMap["FileUploadPermission"] = strconv.Itoa(common.FileUploadPermission)
        common.OptionMap["FileDownloadPermission"] = strconv.Itoa(common.FileDownloadPermission)
        common.OptionMap["ImageUploadPermission"] = strconv.Itoa(common.ImageUploadPermission)
        common.OptionMap["ImageDownloadPermission"] = strconv.Itoa(common.ImageDownloadPermission)
        common.OptionMap["PasswordLoginEnabled"] = strconv.FormatBool(common.PasswordLoginEnabled)
        common.OptionMap["PasswordRegisterEnabled"] = strconv.FormatBool(common.PasswordRegisterEnabled)
        common.OptionMap["EmailVerificationEnabled"] = strconv.FormatBool(common.EmailVerificationEnabled)
        common.OptionMap["GitHubOAuthEnabled"] = strconv.FormatBool(common.GitHubOAuthEnabled)
        common.OptionMap["LinuxDOOAuthEnabled"] = strconv.FormatBool(common.LinuxDOOAuthEnabled)
        common.OptionMap["TelegramOAuthEnabled"] = strconv.FormatBool(common.TelegramOAuthEnabled)
        common.OptionMap["WeChatAuthEnabled"] = strconv.FormatBool(common.WeChatAuthEnabled)
        common.OptionMap["TurnstileCheckEnabled"] = strconv.FormatBool(common.TurnstileCheckEnabled)
        common.OptionMap["RegisterEnabled"] = strconv.FormatBool(common.RegisterEnabled)
        common.OptionMap["AutomaticDisableChannelEnabled"] = strconv.FormatBool(common.AutomaticDisableChannelEnabled)
        common.OptionMap["AutomaticEnableChannelEnabled"] = strconv.FormatBool(common.AutomaticEnableChannelEnabled)
        common.OptionMap["LogConsumeEnabled"] = strconv.FormatBool(common.LogConsumeEnabled)
        common.OptionMap["DisplayInCurrencyEnabled"] = strconv.FormatBool(common.DisplayInCurrencyEnabled)
        common.OptionMap["DisplayTokenStatEnabled"] = strconv.FormatBool(common.DisplayTokenStatEnabled)
        common.OptionMap["DrawingEnabled"] = strconv.FormatBool(common.DrawingEnabled)
        common.OptionMap["TaskEnabled"] = strconv.FormatBool(common.TaskEnabled)
        common.OptionMap["DataExportEnabled"] = strconv.FormatBool(common.DataExportEnabled)
        common.OptionMap["ChannelDisableThreshold"] = strconv.FormatFloat(common.ChannelDisableThreshold, 'f', -1, 64)
        common.OptionMap["EmailDomainRestrictionEnabled"] = strconv.FormatBool(common.EmailDomainRestrictionEnabled)
        common.OptionMap["EmailAliasRestrictionEnabled"] = strconv.FormatBool(common.EmailAliasRestrictionEnabled)
        common.OptionMap["EmailDomainWhitelist"] = strings.Join(common.EmailDomainWhitelist, ",")
        common.OptionMap["SMTPServer"] = ""
        common.OptionMap["SMTPFrom"] = ""
        common.OptionMap["SMTPPort"] = strconv.Itoa(common.SMTPPort)
        common.OptionMap["SMTPAccount"] = ""
        common.OptionMap["SMTPToken"] = ""
        common.OptionMap["SMTPSSLEnabled"] = strconv.FormatBool(common.SMTPSSLEnabled)
        common.OptionMap["Notice"] = ""
        common.OptionMap["About"] = ""
        common.OptionMap["HomePageContent"] = ""
        common.OptionMap["Footer"] = common.Footer
        common.OptionMap["SystemName"] = common.SystemName
        common.OptionMap["Logo"] = common.Logo
        common.OptionMap["ServerAddress"] = ""
        common.OptionMap["WorkerUrl"] = system_setting.WorkerUrl
        common.OptionMap["WorkerValidKey"] = system_setting.WorkerValidKey
        common.OptionMap["WorkerAllowHttpImageRequestEnabled"] = strconv.FormatBool(system_setting.WorkerAllowHttpImageRequestEnabled)
        common.OptionMap["PayAddress"] = ""
        common.OptionMap["CustomCallbackAddress"] = ""
        common.OptionMap["EpayId"] = ""
        common.OptionMap["EpayKey"] = ""
        common.OptionMap["Price"] = strconv.FormatFloat(operation_setting.Price, 'f', -1, 64)
        common.OptionMap["USDExchangeRate"] = strconv.FormatFloat(operation_setting.USDExchangeRate, 'f', -1, 64)
        common.OptionMap["MinTopUp"] = strconv.Itoa(operation_setting.MinTopUp)
        common.OptionMap["StripeMinTopUp"] = strconv.Itoa(setting.StripeMinTopUp)
        common.OptionMap["StripeApiSecret"] = setting.StripeApiSecret
        common.OptionMap["StripeWebhookSecret"] = setting.StripeWebhookSecret
        common.OptionMap["StripePriceId"] = setting.StripePriceId
        common.OptionMap["StripeUnitPrice"] = strconv.FormatFloat(setting.StripeUnitPrice, 'f', -1, 64)
        common.OptionMap["StripePromotionCodesEnabled"] = strconv.FormatBool(setting.StripePromotionCodesEnabled)
        common.OptionMap["CreemApiKey"] = setting.CreemApiKey
        common.OptionMap["CreemProducts"] = setting.CreemProducts
        common.OptionMap["CreemTestMode"] = strconv.FormatBool(setting.CreemTestMode)
        common.OptionMap["CreemWebhookSecret"] = setting.CreemWebhookSecret
        common.OptionMap["TopupGroupRatio"] = common.TopupGroupRatio2JSONString()
        common.OptionMap["Chats"] = setting.Chats2JsonString()
        common.OptionMap["AutoGroups"] = setting.AutoGroups2JsonString()
        common.OptionMap["DefaultUseAutoGroup"] = strconv.FormatBool(setting.DefaultUseAutoGroup)
        common.OptionMap["PayMethods"] = operation_setting.PayMethods2JsonString()
        common.OptionMap["GitHubClientId"] = ""
        common.OptionMap["GitHubClientSecret"] = ""
        common.OptionMap["TelegramBotToken"] = ""
        common.OptionMap["TelegramBotName"] = ""
        common.OptionMap["WeChatServerAddress"] = ""
        common.OptionMap["WeChatServerToken"] = ""
        common.OptionMap["WeChatAccountQRCodeImageURL"] = ""
        common.OptionMap["TurnstileSiteKey"] = ""
        common.OptionMap["TurnstileSecretKey"] = ""
        common.OptionMap["QuotaForNewUser"] = strconv.Itoa(common.QuotaForNewUser)
        common.OptionMap["QuotaForInviter"] = strconv.Itoa(common.QuotaForInviter)
        common.OptionMap["QuotaForInvitee"] = strconv.Itoa(common.QuotaForInvitee)
        common.OptionMap["QuotaRemindThreshold"] = strconv.Itoa(common.QuotaRemindThreshold)
        common.OptionMap["PreConsumedQuota"] = strconv.Itoa(common.PreConsumedQuota)
        common.OptionMap["ModelRequestRateLimitCount"] = strconv.Itoa(setting.ModelRequestRateLimitCount)
        common.OptionMap["ModelRequestRateLimitDurationMinutes"] = strconv.Itoa(setting.ModelRequestRateLimitDurationMinutes)
        common.OptionMap["ModelRequestRateLimitSuccessCount"] = strconv.Itoa(setting.ModelRequestRateLimitSuccessCount)
        common.OptionMap["ModelRequestRateLimitGroup"] = setting.ModelRequestRateLimitGroup2JSONString()
        common.OptionMap["ModelRatio"] = ratio_setting.ModelRatio2JSONString()
        common.OptionMap["ModelPrice"] = ratio_setting.ModelPrice2JSONString()
        common.OptionMap["CacheRatio"] = ratio_setting.CacheRatio2JSONString()
        common.OptionMap["GroupRatio"] = ratio_setting.GroupRatio2JSONString()
        common.OptionMap["GroupGroupRatio"] = ratio_setting.GroupGroupRatio2JSONString()
        common.OptionMap["UserUsableGroups"] = setting.UserUsableGroups2JSONString()
        common.OptionMap["CompletionRatio"] = ratio_setting.CompletionRatio2JSONString()
        common.OptionMap["ImageRatio"] = ratio_setting.ImageRatio2JSONString()
        common.OptionMap["AudioRatio"] = ratio_setting.AudioRatio2JSONString()
        common.OptionMap["AudioCompletionRatio"] = ratio_setting.AudioCompletionRatio2JSONString()
        common.OptionMap["TopUpLink"] = common.TopUpLink
        //common.OptionMap["ChatLink"] = common.ChatLink
        //common.OptionMap["ChatLink2"] = common.ChatLink2
        common.OptionMap["QuotaPerUnit"] = strconv.FormatFloat(common.QuotaPerUnit, 'f', -1, 64)
        common.OptionMap["RetryTimes"] = strconv.Itoa(common.RetryTimes)
        common.OptionMap["DataExportInterval"] = strconv.Itoa(common.DataExportInterval)
        common.OptionMap["DataExportDefaultTime"] = common.DataExportDefaultTime
        common.OptionMap["DefaultCollapseSidebar"] = strconv.FormatBool(common.DefaultCollapseSidebar)
        common.OptionMap["MjNotifyEnabled"] = strconv.FormatBool(setting.MjNotifyEnabled)
        common.OptionMap["MjAccountFilterEnabled"] = strconv.FormatBool(setting.MjAccountFilterEnabled)
        common.OptionMap["MjModeClearEnabled"] = strconv.FormatBool(setting.MjModeClearEnabled)
        common.OptionMap["MjForwardUrlEnabled"] = strconv.FormatBool(setting.MjForwardUrlEnabled)
        common.OptionMap["MjActionCheckSuccessEnabled"] = strconv.FormatBool(setting.MjActionCheckSuccessEnabled)
        common.OptionMap["CheckSensitiveEnabled"] = strconv.FormatBool(setting.CheckSensitiveEnabled)
        common.OptionMap["DemoSiteEnabled"] = strconv.FormatBool(operation_setting.DemoSiteEnabled)
        common.OptionMap["SelfUseModeEnabled"] = strconv.FormatBool(operation_setting.SelfUseModeEnabled)
        common.OptionMap["ModelRequestRateLimitEnabled"] = strconv.FormatBool(setting.ModelRequestRateLimitEnabled)
        common.OptionMap["CheckSensitiveOnPromptEnabled"] = strconv.FormatBool(setting.CheckSensitiveOnPromptEnabled)
        common.OptionMap["StopOnSensitiveEnabled"] = strconv.FormatBool(setting.StopOnSensitiveEnabled)
        common.OptionMap["SensitiveWords"] = setting.SensitiveWordsToString()
        common.OptionMap["StreamCacheQueueLength"] = strconv.Itoa(setting.StreamCacheQueueLength)
        common.OptionMap["AutomaticDisableKeywords"] = operation_setting.AutomaticDisableKeywordsToString()
        common.OptionMap["ExposeRatioEnabled"] = strconv.FormatBool(ratio_setting.IsExposeRatioEnabled())

        // 自动添加所有注册的模型配置
        modelConfigs := config.GlobalConfig.ExportAllConfigs()
        for k, v := range modelConfigs </span><span class="cov0" title="0">{
                common.OptionMap[k] = v
        }</span>

        <span class="cov0" title="0">common.OptionMapRWMutex.Unlock()
        loadOptionsFromDatabase()</span>
}

func loadOptionsFromDatabase() <span class="cov0" title="0">{
        options, _ := AllOption()
        for _, option := range options </span><span class="cov0" title="0">{
                err := updateOptionMap(option.Key, option.Value)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("failed to update option map: " + err.Error())
                }</span>
        }
}

func SyncOptions(frequency int) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(frequency) * time.Second)
                common.SysLog("syncing options from database")
                loadOptionsFromDatabase()
        }</span>
}

func UpdateOption(key string, value string) error <span class="cov0" title="0">{
        // Save to database first
        option := Option{
                Key: key,
        }
        // https://gorm.io/docs/update.html#Save-All-Fields
        DB.FirstOrCreate(&amp;option, Option{Key: key})
        option.Value = value
        // Save is a combination function.
        // If save value does not contain primary key, it will execute Create,
        // otherwise it will execute Update (with all fields).
        DB.Save(&amp;option)
        // Update OptionMap
        return updateOptionMap(key, value)
}</span>

func updateOptionMap(key string, value string) (err error) <span class="cov0" title="0">{
        common.OptionMapRWMutex.Lock()
        defer common.OptionMapRWMutex.Unlock()
        common.OptionMap[key] = value

        // 检查是否是模型配置 - 使用更规范的方式处理
        if handleConfigUpdate(key, value) </span><span class="cov0" title="0">{
                return nil // 已由配置系统处理
        }</span>

        // 处理传统配置项...
        <span class="cov0" title="0">if strings.HasSuffix(key, "Permission") </span><span class="cov0" title="0">{
                intValue, _ := strconv.Atoi(value)
                switch key </span>{
                case "FileUploadPermission":<span class="cov0" title="0">
                        common.FileUploadPermission = intValue</span>
                case "FileDownloadPermission":<span class="cov0" title="0">
                        common.FileDownloadPermission = intValue</span>
                case "ImageUploadPermission":<span class="cov0" title="0">
                        common.ImageUploadPermission = intValue</span>
                case "ImageDownloadPermission":<span class="cov0" title="0">
                        common.ImageDownloadPermission = intValue</span>
                }
        }
        <span class="cov0" title="0">if strings.HasSuffix(key, "Enabled") || key == "DefaultCollapseSidebar" || key == "DefaultUseAutoGroup" </span><span class="cov0" title="0">{
                boolValue := value == "true"
                switch key </span>{
                case "PasswordRegisterEnabled":<span class="cov0" title="0">
                        common.PasswordRegisterEnabled = boolValue</span>
                case "PasswordLoginEnabled":<span class="cov0" title="0">
                        common.PasswordLoginEnabled = boolValue</span>
                case "EmailVerificationEnabled":<span class="cov0" title="0">
                        common.EmailVerificationEnabled = boolValue</span>
                case "GitHubOAuthEnabled":<span class="cov0" title="0">
                        common.GitHubOAuthEnabled = boolValue</span>
                case "LinuxDOOAuthEnabled":<span class="cov0" title="0">
                        common.LinuxDOOAuthEnabled = boolValue</span>
                case "WeChatAuthEnabled":<span class="cov0" title="0">
                        common.WeChatAuthEnabled = boolValue</span>
                case "TelegramOAuthEnabled":<span class="cov0" title="0">
                        common.TelegramOAuthEnabled = boolValue</span>
                case "TurnstileCheckEnabled":<span class="cov0" title="0">
                        common.TurnstileCheckEnabled = boolValue</span>
                case "RegisterEnabled":<span class="cov0" title="0">
                        common.RegisterEnabled = boolValue</span>
                case "EmailDomainRestrictionEnabled":<span class="cov0" title="0">
                        common.EmailDomainRestrictionEnabled = boolValue</span>
                case "EmailAliasRestrictionEnabled":<span class="cov0" title="0">
                        common.EmailAliasRestrictionEnabled = boolValue</span>
                case "AutomaticDisableChannelEnabled":<span class="cov0" title="0">
                        common.AutomaticDisableChannelEnabled = boolValue</span>
                case "AutomaticEnableChannelEnabled":<span class="cov0" title="0">
                        common.AutomaticEnableChannelEnabled = boolValue</span>
                case "LogConsumeEnabled":<span class="cov0" title="0">
                        common.LogConsumeEnabled = boolValue</span>
                case "DisplayInCurrencyEnabled":<span class="cov0" title="0">
                        // 兼容旧字段：同步到新配置 general_setting.quota_display_type（运行时生效）
                        // true -&gt; USD, false -&gt; TOKENS
                        newVal := "USD"
                        if !boolValue </span><span class="cov0" title="0">{
                                newVal = "TOKENS"
                        }</span>
                        <span class="cov0" title="0">if cfg := config.GlobalConfig.Get("general_setting"); cfg != nil </span><span class="cov0" title="0">{
                                _ = config.UpdateConfigFromMap(cfg, map[string]string{"quota_display_type": newVal})
                        }</span>
                case "DisplayTokenStatEnabled":<span class="cov0" title="0">
                        common.DisplayTokenStatEnabled = boolValue</span>
                case "DrawingEnabled":<span class="cov0" title="0">
                        common.DrawingEnabled = boolValue</span>
                case "TaskEnabled":<span class="cov0" title="0">
                        common.TaskEnabled = boolValue</span>
                case "DataExportEnabled":<span class="cov0" title="0">
                        common.DataExportEnabled = boolValue</span>
                case "DefaultCollapseSidebar":<span class="cov0" title="0">
                        common.DefaultCollapseSidebar = boolValue</span>
                case "MjNotifyEnabled":<span class="cov0" title="0">
                        setting.MjNotifyEnabled = boolValue</span>
                case "MjAccountFilterEnabled":<span class="cov0" title="0">
                        setting.MjAccountFilterEnabled = boolValue</span>
                case "MjModeClearEnabled":<span class="cov0" title="0">
                        setting.MjModeClearEnabled = boolValue</span>
                case "MjForwardUrlEnabled":<span class="cov0" title="0">
                        setting.MjForwardUrlEnabled = boolValue</span>
                case "MjActionCheckSuccessEnabled":<span class="cov0" title="0">
                        setting.MjActionCheckSuccessEnabled = boolValue</span>
                case "CheckSensitiveEnabled":<span class="cov0" title="0">
                        setting.CheckSensitiveEnabled = boolValue</span>
                case "DemoSiteEnabled":<span class="cov0" title="0">
                        operation_setting.DemoSiteEnabled = boolValue</span>
                case "SelfUseModeEnabled":<span class="cov0" title="0">
                        operation_setting.SelfUseModeEnabled = boolValue</span>
                case "CheckSensitiveOnPromptEnabled":<span class="cov0" title="0">
                        setting.CheckSensitiveOnPromptEnabled = boolValue</span>
                case "ModelRequestRateLimitEnabled":<span class="cov0" title="0">
                        setting.ModelRequestRateLimitEnabled = boolValue</span>
                case "StopOnSensitiveEnabled":<span class="cov0" title="0">
                        setting.StopOnSensitiveEnabled = boolValue</span>
                case "SMTPSSLEnabled":<span class="cov0" title="0">
                        common.SMTPSSLEnabled = boolValue</span>
                case "WorkerAllowHttpImageRequestEnabled":<span class="cov0" title="0">
                        system_setting.WorkerAllowHttpImageRequestEnabled = boolValue</span>
                case "DefaultUseAutoGroup":<span class="cov0" title="0">
                        setting.DefaultUseAutoGroup = boolValue</span>
                case "ExposeRatioEnabled":<span class="cov0" title="0">
                        ratio_setting.SetExposeRatioEnabled(boolValue)</span>
                }
        }
        <span class="cov0" title="0">switch key </span>{
        case "EmailDomainWhitelist":<span class="cov0" title="0">
                common.EmailDomainWhitelist = strings.Split(value, ",")</span>
        case "SMTPServer":<span class="cov0" title="0">
                common.SMTPServer = value</span>
        case "SMTPPort":<span class="cov0" title="0">
                intValue, _ := strconv.Atoi(value)
                common.SMTPPort = intValue</span>
        case "SMTPAccount":<span class="cov0" title="0">
                common.SMTPAccount = value</span>
        case "SMTPFrom":<span class="cov0" title="0">
                common.SMTPFrom = value</span>
        case "SMTPToken":<span class="cov0" title="0">
                common.SMTPToken = value</span>
        case "ServerAddress":<span class="cov0" title="0">
                system_setting.ServerAddress = value</span>
        case "WorkerUrl":<span class="cov0" title="0">
                system_setting.WorkerUrl = value</span>
        case "WorkerValidKey":<span class="cov0" title="0">
                system_setting.WorkerValidKey = value</span>
        case "PayAddress":<span class="cov0" title="0">
                operation_setting.PayAddress = value</span>
        case "Chats":<span class="cov0" title="0">
                err = setting.UpdateChatsByJsonString(value)</span>
        case "AutoGroups":<span class="cov0" title="0">
                err = setting.UpdateAutoGroupsByJsonString(value)</span>
        case "CustomCallbackAddress":<span class="cov0" title="0">
                operation_setting.CustomCallbackAddress = value</span>
        case "EpayId":<span class="cov0" title="0">
                operation_setting.EpayId = value</span>
        case "EpayKey":<span class="cov0" title="0">
                operation_setting.EpayKey = value</span>
        case "Price":<span class="cov0" title="0">
                operation_setting.Price, _ = strconv.ParseFloat(value, 64)</span>
        case "USDExchangeRate":<span class="cov0" title="0">
                operation_setting.USDExchangeRate, _ = strconv.ParseFloat(value, 64)</span>
        case "MinTopUp":<span class="cov0" title="0">
                operation_setting.MinTopUp, _ = strconv.Atoi(value)</span>
        case "StripeApiSecret":<span class="cov0" title="0">
                setting.StripeApiSecret = value</span>
        case "StripeWebhookSecret":<span class="cov0" title="0">
                setting.StripeWebhookSecret = value</span>
        case "StripePriceId":<span class="cov0" title="0">
                setting.StripePriceId = value</span>
        case "StripeUnitPrice":<span class="cov0" title="0">
                setting.StripeUnitPrice, _ = strconv.ParseFloat(value, 64)</span>
        case "StripeMinTopUp":<span class="cov0" title="0">
                setting.StripeMinTopUp, _ = strconv.Atoi(value)</span>
        case "StripePromotionCodesEnabled":<span class="cov0" title="0">
                setting.StripePromotionCodesEnabled = value == "true"</span>
        case "CreemApiKey":<span class="cov0" title="0">
                setting.CreemApiKey = value</span>
        case "CreemProducts":<span class="cov0" title="0">
                setting.CreemProducts = value</span>
        case "CreemTestMode":<span class="cov0" title="0">
                setting.CreemTestMode = value == "true"</span>
        case "CreemWebhookSecret":<span class="cov0" title="0">
                setting.CreemWebhookSecret = value</span>
        case "TopupGroupRatio":<span class="cov0" title="0">
                err = common.UpdateTopupGroupRatioByJSONString(value)</span>
        case "GitHubClientId":<span class="cov0" title="0">
                common.GitHubClientId = value</span>
        case "GitHubClientSecret":<span class="cov0" title="0">
                common.GitHubClientSecret = value</span>
        case "LinuxDOClientId":<span class="cov0" title="0">
                common.LinuxDOClientId = value</span>
        case "LinuxDOClientSecret":<span class="cov0" title="0">
                common.LinuxDOClientSecret = value</span>
        case "LinuxDOMinimumTrustLevel":<span class="cov0" title="0">
                common.LinuxDOMinimumTrustLevel, _ = strconv.Atoi(value)</span>
        case "Footer":<span class="cov0" title="0">
                common.Footer = value</span>
        case "SystemName":<span class="cov0" title="0">
                common.SystemName = value</span>
        case "Logo":<span class="cov0" title="0">
                common.Logo = value</span>
        case "WeChatServerAddress":<span class="cov0" title="0">
                common.WeChatServerAddress = value</span>
        case "WeChatServerToken":<span class="cov0" title="0">
                common.WeChatServerToken = value</span>
        case "WeChatAccountQRCodeImageURL":<span class="cov0" title="0">
                common.WeChatAccountQRCodeImageURL = value</span>
        case "TelegramBotToken":<span class="cov0" title="0">
                common.TelegramBotToken = value</span>
        case "TelegramBotName":<span class="cov0" title="0">
                common.TelegramBotName = value</span>
        case "TurnstileSiteKey":<span class="cov0" title="0">
                common.TurnstileSiteKey = value</span>
        case "TurnstileSecretKey":<span class="cov0" title="0">
                common.TurnstileSecretKey = value</span>
        case "QuotaForNewUser":<span class="cov0" title="0">
                common.QuotaForNewUser, _ = strconv.Atoi(value)</span>
        case "QuotaForInviter":<span class="cov0" title="0">
                common.QuotaForInviter, _ = strconv.Atoi(value)</span>
        case "QuotaForInvitee":<span class="cov0" title="0">
                common.QuotaForInvitee, _ = strconv.Atoi(value)</span>
        case "QuotaRemindThreshold":<span class="cov0" title="0">
                common.QuotaRemindThreshold, _ = strconv.Atoi(value)</span>
        case "PreConsumedQuota":<span class="cov0" title="0">
                common.PreConsumedQuota, _ = strconv.Atoi(value)</span>
        case "ModelRequestRateLimitCount":<span class="cov0" title="0">
                setting.ModelRequestRateLimitCount, _ = strconv.Atoi(value)</span>
        case "ModelRequestRateLimitDurationMinutes":<span class="cov0" title="0">
                setting.ModelRequestRateLimitDurationMinutes, _ = strconv.Atoi(value)</span>
        case "ModelRequestRateLimitSuccessCount":<span class="cov0" title="0">
                setting.ModelRequestRateLimitSuccessCount, _ = strconv.Atoi(value)</span>
        case "ModelRequestRateLimitGroup":<span class="cov0" title="0">
                err = setting.UpdateModelRequestRateLimitGroupByJSONString(value)</span>
        case "RetryTimes":<span class="cov0" title="0">
                common.RetryTimes, _ = strconv.Atoi(value)</span>
        case "DataExportInterval":<span class="cov0" title="0">
                common.DataExportInterval, _ = strconv.Atoi(value)</span>
        case "DataExportDefaultTime":<span class="cov0" title="0">
                common.DataExportDefaultTime = value</span>
        case "ModelRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateModelRatioByJSONString(value)</span>
        case "GroupRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateGroupRatioByJSONString(value)</span>
        case "GroupGroupRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateGroupGroupRatioByJSONString(value)</span>
        case "UserUsableGroups":<span class="cov0" title="0">
                err = setting.UpdateUserUsableGroupsByJSONString(value)</span>
        case "CompletionRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateCompletionRatioByJSONString(value)</span>
        case "ModelPrice":<span class="cov0" title="0">
                err = ratio_setting.UpdateModelPriceByJSONString(value)</span>
        case "CacheRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateCacheRatioByJSONString(value)</span>
        case "ImageRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateImageRatioByJSONString(value)</span>
        case "AudioRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateAudioRatioByJSONString(value)</span>
        case "AudioCompletionRatio":<span class="cov0" title="0">
                err = ratio_setting.UpdateAudioCompletionRatioByJSONString(value)</span>
        case "TopUpLink":<span class="cov0" title="0">
                common.TopUpLink = value</span>
        //case "ChatLink":
        //        common.ChatLink = value
        //case "ChatLink2":
        //        common.ChatLink2 = value
        case "ChannelDisableThreshold":<span class="cov0" title="0">
                common.ChannelDisableThreshold, _ = strconv.ParseFloat(value, 64)</span>
        case "QuotaPerUnit":<span class="cov0" title="0">
                common.QuotaPerUnit, _ = strconv.ParseFloat(value, 64)</span>
        case "SensitiveWords":<span class="cov0" title="0">
                setting.SensitiveWordsFromString(value)</span>
        case "AutomaticDisableKeywords":<span class="cov0" title="0">
                operation_setting.AutomaticDisableKeywordsFromString(value)</span>
        case "StreamCacheQueueLength":<span class="cov0" title="0">
                setting.StreamCacheQueueLength, _ = strconv.Atoi(value)</span>
        case "PayMethods":<span class="cov0" title="0">
                err = operation_setting.UpdatePayMethodsByJsonString(value)</span>
        }
        <span class="cov0" title="0">return err</span>
}

// handleConfigUpdate 处理分层配置更新，返回是否已处理
func handleConfigUpdate(key, value string) bool <span class="cov0" title="0">{
        parts := strings.SplitN(key, ".", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false // 不是分层配置
        }</span>

        <span class="cov0" title="0">configName := parts[0]
        configKey := parts[1]

        // 获取配置对象
        cfg := config.GlobalConfig.Get(configName)
        if cfg == nil </span><span class="cov0" title="0">{
                return false // 未注册的配置
        }</span>

        // 更新配置
        <span class="cov0" title="0">configMap := map[string]string{
                configKey: value,
        }
        config.UpdateConfigFromMap(cfg, configMap)

        return true</span> // 已处理
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package model

import (
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"

        "github.com/go-webauthn/webauthn/protocol"
        "github.com/go-webauthn/webauthn/webauthn"
        "gorm.io/gorm"
)

var (
        ErrPasskeyNotFound         = errors.New("passkey credential not found")
        ErrFriendlyPasskeyNotFound = errors.New("Passkey 验证失败，请重试或联系管理员")
)

type PasskeyCredential struct {
        ID              int            `json:"id" gorm:"primaryKey"`
        UserID          int            `json:"user_id" gorm:"uniqueIndex;not null"`
        CredentialID    string         `json:"credential_id" gorm:"type:varchar(512);uniqueIndex;not null"` // base64 encoded
        PublicKey       string         `json:"public_key" gorm:"type:text;not null"`                        // base64 encoded
        AttestationType string         `json:"attestation_type" gorm:"type:varchar(255)"`
        AAGUID          string         `json:"aaguid" gorm:"type:varchar(512)"` // base64 encoded
        SignCount       uint32         `json:"sign_count" gorm:"default:0"`
        CloneWarning    bool           `json:"clone_warning"`
        UserPresent     bool           `json:"user_present"`
        UserVerified    bool           `json:"user_verified"`
        BackupEligible  bool           `json:"backup_eligible"`
        BackupState     bool           `json:"backup_state"`
        Transports      string         `json:"transports" gorm:"type:text"`
        Attachment      string         `json:"attachment" gorm:"type:varchar(32)"`
        LastUsedAt      *time.Time     `json:"last_used_at"`
        CreatedAt       time.Time      `json:"created_at"`
        UpdatedAt       time.Time      `json:"updated_at"`
        DeletedAt       gorm.DeletedAt `json:"-" gorm:"index"`
}

func (p *PasskeyCredential) TransportList() []protocol.AuthenticatorTransport <span class="cov0" title="0">{
        if p == nil || strings.TrimSpace(p.Transports) == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var transports []string
        if err := json.Unmarshal([]byte(p.Transports), &amp;transports); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]protocol.AuthenticatorTransport, 0, len(transports))
        for _, transport := range transports </span><span class="cov0" title="0">{
                result = append(result, protocol.AuthenticatorTransport(transport))
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (p *PasskeyCredential) SetTransports(list []protocol.AuthenticatorTransport) <span class="cov0" title="0">{
        if len(list) == 0 </span><span class="cov0" title="0">{
                p.Transports = ""
                return
        }</span>
        <span class="cov0" title="0">stringList := make([]string, len(list))
        for i, transport := range list </span><span class="cov0" title="0">{
                stringList[i] = string(transport)
        }</span>
        <span class="cov0" title="0">encoded, err := json.Marshal(stringList)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">p.Transports = string(encoded)</span>
}

func (p *PasskeyCredential) ToWebAuthnCredential() webauthn.Credential <span class="cov0" title="0">{
        flags := webauthn.CredentialFlags{
                UserPresent:    p.UserPresent,
                UserVerified:   p.UserVerified,
                BackupEligible: p.BackupEligible,
                BackupState:    p.BackupState,
        }

        credID, _ := base64.StdEncoding.DecodeString(p.CredentialID)
        pubKey, _ := base64.StdEncoding.DecodeString(p.PublicKey)
        aaguid, _ := base64.StdEncoding.DecodeString(p.AAGUID)

        return webauthn.Credential{
                ID:              credID,
                PublicKey:       pubKey,
                AttestationType: p.AttestationType,
                Transport:       p.TransportList(),
                Flags:           flags,
                Authenticator: webauthn.Authenticator{
                        AAGUID:       aaguid,
                        SignCount:    p.SignCount,
                        CloneWarning: p.CloneWarning,
                        Attachment:   protocol.AuthenticatorAttachment(p.Attachment),
                },
        }
}</span>

func NewPasskeyCredentialFromWebAuthn(userID int, credential *webauthn.Credential) *PasskeyCredential <span class="cov0" title="0">{
        if credential == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">passkey := &amp;PasskeyCredential{
                UserID:          userID,
                CredentialID:    base64.StdEncoding.EncodeToString(credential.ID),
                PublicKey:       base64.StdEncoding.EncodeToString(credential.PublicKey),
                AttestationType: credential.AttestationType,
                AAGUID:          base64.StdEncoding.EncodeToString(credential.Authenticator.AAGUID),
                SignCount:       credential.Authenticator.SignCount,
                CloneWarning:    credential.Authenticator.CloneWarning,
                UserPresent:     credential.Flags.UserPresent,
                UserVerified:    credential.Flags.UserVerified,
                BackupEligible:  credential.Flags.BackupEligible,
                BackupState:     credential.Flags.BackupState,
                Attachment:      string(credential.Authenticator.Attachment),
        }
        passkey.SetTransports(credential.Transport)
        return passkey</span>
}

func (p *PasskeyCredential) ApplyValidatedCredential(credential *webauthn.Credential) <span class="cov0" title="0">{
        if credential == nil || p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">p.CredentialID = base64.StdEncoding.EncodeToString(credential.ID)
        p.PublicKey = base64.StdEncoding.EncodeToString(credential.PublicKey)
        p.AttestationType = credential.AttestationType
        p.AAGUID = base64.StdEncoding.EncodeToString(credential.Authenticator.AAGUID)
        p.SignCount = credential.Authenticator.SignCount
        p.CloneWarning = credential.Authenticator.CloneWarning
        p.UserPresent = credential.Flags.UserPresent
        p.UserVerified = credential.Flags.UserVerified
        p.BackupEligible = credential.Flags.BackupEligible
        p.BackupState = credential.Flags.BackupState
        p.Attachment = string(credential.Authenticator.Attachment)
        p.SetTransports(credential.Transport)</span>
}

func GetPasskeyByUserID(userID int) (*PasskeyCredential, error) <span class="cov0" title="0">{
        if userID == 0 </span><span class="cov0" title="0">{
                common.SysLog("GetPasskeyByUserID: empty user ID")
                return nil, ErrFriendlyPasskeyNotFound
        }</span>
        <span class="cov0" title="0">var credential PasskeyCredential
        if err := DB.Where("user_id = ?", userID).First(&amp;credential).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        // 未找到记录是正常情况（用户未绑定），返回 ErrPasskeyNotFound 而不记录日志
                        return nil, ErrPasskeyNotFound
                }</span>
                // 只有真正的数据库错误才记录日志
                <span class="cov0" title="0">common.SysLog(fmt.Sprintf("GetPasskeyByUserID: database error for user %d: %v", userID, err))
                return nil, ErrFriendlyPasskeyNotFound</span>
        }
        <span class="cov0" title="0">return &amp;credential, nil</span>
}

func GetPasskeyByCredentialID(credentialID []byte) (*PasskeyCredential, error) <span class="cov0" title="0">{
        if len(credentialID) == 0 </span><span class="cov0" title="0">{
                common.SysLog("GetPasskeyByCredentialID: empty credential ID")
                return nil, ErrFriendlyPasskeyNotFound
        }</span>

        <span class="cov0" title="0">credIDStr := base64.StdEncoding.EncodeToString(credentialID)
        var credential PasskeyCredential
        if err := DB.Where("credential_id = ?", credIDStr).First(&amp;credential).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("GetPasskeyByCredentialID: passkey not found for credential ID length %d", len(credentialID)))
                        return nil, ErrFriendlyPasskeyNotFound
                }</span>
                <span class="cov0" title="0">common.SysLog(fmt.Sprintf("GetPasskeyByCredentialID: database error for credential ID: %v", err))
                return nil, ErrFriendlyPasskeyNotFound</span>
        }

        <span class="cov0" title="0">return &amp;credential, nil</span>
}

func UpsertPasskeyCredential(credential *PasskeyCredential) error <span class="cov0" title="0">{
        if credential == nil </span><span class="cov0" title="0">{
                common.SysLog("UpsertPasskeyCredential: nil credential provided")
                return fmt.Errorf("Passkey 保存失败，请重试")
        }</span>
        <span class="cov0" title="0">return DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // 使用Unscoped()进行硬删除，避免唯一索引冲突
                if err := tx.Unscoped().Where("user_id = ?", credential.UserID).Delete(&amp;PasskeyCredential{}).Error; err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("UpsertPasskeyCredential: failed to delete existing credential for user %d: %v", credential.UserID, err))
                        return fmt.Errorf("Passkey 保存失败，请重试")
                }</span>
                <span class="cov0" title="0">if err := tx.Create(credential).Error; err != nil </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("UpsertPasskeyCredential: failed to create credential for user %d: %v", credential.UserID, err))
                        return fmt.Errorf("Passkey 保存失败，请重试")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

func DeletePasskeyByUserID(userID int) error <span class="cov0" title="0">{
        if userID == 0 </span><span class="cov0" title="0">{
                common.SysLog("DeletePasskeyByUserID: empty user ID")
                return fmt.Errorf("删除失败，请重试")
        }</span>
        // 使用Unscoped()进行硬删除，避免唯一索引冲突
        <span class="cov0" title="0">if err := DB.Unscoped().Where("user_id = ?", userID).Delete(&amp;PasskeyCredential{}).Error; err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("DeletePasskeyByUserID: failed to delete passkey for user %d: %v", userID, err))
                return fmt.Errorf("删除失败，请重试")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"

        "github.com/QuantumNous/new-api/common"

        "gorm.io/gorm"
)

// PrefillGroup 用于存储可复用的“组”信息，例如模型组、标签组、端点组等。
// Name 字段保持唯一，用于在前端下拉框中展示。
// Type 字段用于区分组的类别，可选值如：model、tag、endpoint。
// Items 字段使用 JSON 数组保存对应类型的字符串集合，示例：
// ["gpt-4o", "gpt-3.5-turbo"]
// 设计遵循 3NF，避免冗余，提供灵活扩展能力。

// JSONValue 基于 json.RawMessage 实现，支持从数据库的 []byte 和 string 两种类型读取
type JSONValue json.RawMessage

// Value 实现 driver.Valuer 接口，用于数据库写入
func (j JSONValue) Value() (driver.Value, error) <span class="cov0" title="0">{
        if j == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return []byte(j), nil</span>
}

// Scan 实现 sql.Scanner 接口，兼容不同驱动返回的类型
func (j *JSONValue) Scan(value interface{}) error <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                *j = nil
                return nil</span>
        case []byte:<span class="cov0" title="0">
                // 拷贝底层字节，避免保留底层缓冲区
                b := make([]byte, len(v))
                copy(b, v)
                *j = JSONValue(b)
                return nil</span>
        case string:<span class="cov0" title="0">
                *j = JSONValue([]byte(v))
                return nil</span>
        default:<span class="cov0" title="0">
                // 其他类型尝试序列化为 JSON
                b, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*j = JSONValue(b)
                return nil</span>
        }
}

// MarshalJSON 确保在对外编码时与 json.RawMessage 行为一致
func (j JSONValue) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if j == nil </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov0" title="0">return j, nil</span>
}

// UnmarshalJSON 确保在对外解码时与 json.RawMessage 行为一致
func (j *JSONValue) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                *j = nil
                return nil
        }</span>
        <span class="cov0" title="0">b := make([]byte, len(data))
        copy(b, data)
        *j = JSONValue(b)
        return nil</span>
}

type PrefillGroup struct {
        Id          int            `json:"id"`
        Name        string         `json:"name" gorm:"size:64;not null;uniqueIndex:uk_prefill_name,where:deleted_at IS NULL"`
        Type        string         `json:"type" gorm:"size:32;index;not null"`
        Items       JSONValue      `json:"items" gorm:"type:json"`
        Description string         `json:"description,omitempty" gorm:"type:varchar(255)"`
        CreatedTime int64          `json:"created_time" gorm:"bigint"`
        UpdatedTime int64          `json:"updated_time" gorm:"bigint"`
        DeletedAt   gorm.DeletedAt `json:"-" gorm:"index"`
}

// Insert 新建组
func (g *PrefillGroup) Insert() error <span class="cov0" title="0">{
        now := common.GetTimestamp()
        g.CreatedTime = now
        g.UpdatedTime = now
        return DB.Create(g).Error
}</span>

// IsPrefillGroupNameDuplicated 检查组名称是否重复（排除自身 ID）
func IsPrefillGroupNameDuplicated(id int, name string) (bool, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">var cnt int64
        err := DB.Model(&amp;PrefillGroup{}).Where("name = ? AND id &lt;&gt; ?", name, id).Count(&amp;cnt).Error
        return cnt &gt; 0, err</span>
}

// Update 更新组
func (g *PrefillGroup) Update() error <span class="cov0" title="0">{
        g.UpdatedTime = common.GetTimestamp()
        return DB.Save(g).Error
}</span>

// DeleteByID 根据 ID 删除组
func DeletePrefillGroupByID(id int) error <span class="cov0" title="0">{
        return DB.Delete(&amp;PrefillGroup{}, id).Error
}</span>

// GetAllPrefillGroups 获取全部组，可按类型过滤（为空则返回全部）
func GetAllPrefillGroups(groupType string) ([]*PrefillGroup, error) <span class="cov0" title="0">{
        var groups []*PrefillGroup
        query := DB.Model(&amp;PrefillGroup{})
        if groupType != "" </span><span class="cov0" title="0">{
                query = query.Where("type = ?", groupType)
        }</span>
        <span class="cov0" title="0">if err := query.Order("updated_time DESC").Find(&amp;groups).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return groups, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package model

import (
        "encoding/json"
        "fmt"
        "strings"

        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/QuantumNous/new-api/types"
)

type Pricing struct {
        ModelName              string                  `json:"model_name"`
        Description            string                  `json:"description,omitempty"`
        Icon                   string                  `json:"icon,omitempty"`
        Tags                   string                  `json:"tags,omitempty"`
        VendorID               int                     `json:"vendor_id,omitempty"`
        QuotaType              int                     `json:"quota_type"`
        ModelRatio             float64                 `json:"model_ratio"`
        ModelPrice             float64                 `json:"model_price"`
        OwnerBy                string                  `json:"owner_by"`
        CompletionRatio        float64                 `json:"completion_ratio"`
        EnableGroup            []string                `json:"enable_groups"`
        SupportedEndpointTypes []constant.EndpointType `json:"supported_endpoint_types"`
}

type PricingVendor struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        Icon        string `json:"icon,omitempty"`
}

var (
        pricingMap           []Pricing
        vendorsList          []PricingVendor
        supportedEndpointMap map[string]common.EndpointInfo
        lastGetPricingTime   time.Time
        updatePricingLock    sync.Mutex

        // 缓存映射：模型名 -&gt; 启用分组 / 计费类型
        modelEnableGroups     = make(map[string][]string)
        modelQuotaTypeMap     = make(map[string]int)
        modelEnableGroupsLock = sync.RWMutex{}
)

var (
        modelSupportEndpointTypes = make(map[string][]constant.EndpointType)
        modelSupportEndpointsLock = sync.RWMutex{}
)

func GetPricing() []Pricing <span class="cov0" title="0">{
        if time.Since(lastGetPricingTime) &gt; time.Minute*1 || len(pricingMap) == 0 </span><span class="cov0" title="0">{
                updatePricingLock.Lock()
                defer updatePricingLock.Unlock()
                // Double check after acquiring the lock
                if time.Since(lastGetPricingTime) &gt; time.Minute*1 || len(pricingMap) == 0 </span><span class="cov0" title="0">{
                        modelSupportEndpointsLock.Lock()
                        defer modelSupportEndpointsLock.Unlock()
                        updatePricing()
                }</span>
        }
        <span class="cov0" title="0">return pricingMap</span>
}

// GetVendors 返回当前定价接口使用到的供应商信息
func GetVendors() []PricingVendor <span class="cov0" title="0">{
        if time.Since(lastGetPricingTime) &gt; time.Minute*1 || len(pricingMap) == 0 </span><span class="cov0" title="0">{
                // 保证先刷新一次
                GetPricing()
        }</span>
        <span class="cov0" title="0">return vendorsList</span>
}

func GetModelSupportEndpointTypes(model string) []constant.EndpointType <span class="cov0" title="0">{
        if model == "" </span><span class="cov0" title="0">{
                return make([]constant.EndpointType, 0)
        }</span>
        <span class="cov0" title="0">modelSupportEndpointsLock.RLock()
        defer modelSupportEndpointsLock.RUnlock()
        if endpoints, ok := modelSupportEndpointTypes[model]; ok </span><span class="cov0" title="0">{
                return endpoints
        }</span>
        <span class="cov0" title="0">return make([]constant.EndpointType, 0)</span>
}

func updatePricing() <span class="cov0" title="0">{
        //modelRatios := common.GetModelRatios()
        enableAbilities, err := GetAllEnableAbilityWithChannels()
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("GetAllEnableAbilityWithChannels error: %v", err))
                return
        }</span>
        // 预加载模型元数据与供应商一次，避免循环查询
        <span class="cov0" title="0">var allMeta []Model
        _ = DB.Find(&amp;allMeta).Error
        metaMap := make(map[string]*Model)
        prefixList := make([]*Model, 0)
        suffixList := make([]*Model, 0)
        containsList := make([]*Model, 0)
        for i := range allMeta </span><span class="cov0" title="0">{
                m := &amp;allMeta[i]
                if m.NameRule == NameRuleExact </span><span class="cov0" title="0">{
                        metaMap[m.ModelName] = m
                }</span> else<span class="cov0" title="0"> {
                        switch m.NameRule </span>{
                        case NameRulePrefix:<span class="cov0" title="0">
                                prefixList = append(prefixList, m)</span>
                        case NameRuleSuffix:<span class="cov0" title="0">
                                suffixList = append(suffixList, m)</span>
                        case NameRuleContains:<span class="cov0" title="0">
                                containsList = append(containsList, m)</span>
                        }
                }
        }

        // 将非精确规则模型匹配到 metaMap
        <span class="cov0" title="0">for _, m := range prefixList </span><span class="cov0" title="0">{
                for _, pricingModel := range enableAbilities </span><span class="cov0" title="0">{
                        if strings.HasPrefix(pricingModel.Model, m.ModelName) </span><span class="cov0" title="0">{
                                if _, exists := metaMap[pricingModel.Model]; !exists </span><span class="cov0" title="0">{
                                        metaMap[pricingModel.Model] = m
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, m := range suffixList </span><span class="cov0" title="0">{
                for _, pricingModel := range enableAbilities </span><span class="cov0" title="0">{
                        if strings.HasSuffix(pricingModel.Model, m.ModelName) </span><span class="cov0" title="0">{
                                if _, exists := metaMap[pricingModel.Model]; !exists </span><span class="cov0" title="0">{
                                        metaMap[pricingModel.Model] = m
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, m := range containsList </span><span class="cov0" title="0">{
                for _, pricingModel := range enableAbilities </span><span class="cov0" title="0">{
                        if strings.Contains(pricingModel.Model, m.ModelName) </span><span class="cov0" title="0">{
                                if _, exists := metaMap[pricingModel.Model]; !exists </span><span class="cov0" title="0">{
                                        metaMap[pricingModel.Model] = m
                                }</span>
                        }
                }
        }

        // 预加载供应商
        <span class="cov0" title="0">var vendors []Vendor
        _ = DB.Find(&amp;vendors).Error
        vendorMap := make(map[int]*Vendor)
        for i := range vendors </span><span class="cov0" title="0">{
                vendorMap[vendors[i].Id] = &amp;vendors[i]
        }</span>

        // 初始化默认供应商映射
        <span class="cov0" title="0">initDefaultVendorMapping(metaMap, vendorMap, enableAbilities)

        // 构建对前端友好的供应商列表
        vendorsList = make([]PricingVendor, 0, len(vendorMap))
        for _, v := range vendorMap </span><span class="cov0" title="0">{
                vendorsList = append(vendorsList, PricingVendor{
                        ID:          v.Id,
                        Name:        v.Name,
                        Description: v.Description,
                        Icon:        v.Icon,
                })
        }</span>

        <span class="cov0" title="0">modelGroupsMap := make(map[string]*types.Set[string])

        for _, ability := range enableAbilities </span><span class="cov0" title="0">{
                groups, ok := modelGroupsMap[ability.Model]
                if !ok </span><span class="cov0" title="0">{
                        groups = types.NewSet[string]()
                        modelGroupsMap[ability.Model] = groups
                }</span>
                <span class="cov0" title="0">groups.Add(ability.Group)</span>
        }

        //这里使用切片而不是Set，因为一个模型可能支持多个端点类型，并且第一个端点是优先使用端点
        <span class="cov0" title="0">modelSupportEndpointsStr := make(map[string][]string)

        // 先根据已有能力填充原生端点
        for _, ability := range enableAbilities </span><span class="cov0" title="0">{
                endpoints := modelSupportEndpointsStr[ability.Model]
                channelTypes := common.GetEndpointTypesByChannelType(ability.ChannelType, ability.Model)
                for _, channelType := range channelTypes </span><span class="cov0" title="0">{
                        if !common.StringsContains(endpoints, string(channelType)) </span><span class="cov0" title="0">{
                                endpoints = append(endpoints, string(channelType))
                        }</span>
                }
                <span class="cov0" title="0">modelSupportEndpointsStr[ability.Model] = endpoints</span>
        }

        // 再补充模型自定义端点
        <span class="cov0" title="0">for modelName, meta := range metaMap </span><span class="cov0" title="0">{
                if strings.TrimSpace(meta.Endpoints) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var raw map[string]interface{}
                if err := json.Unmarshal([]byte(meta.Endpoints), &amp;raw); err == nil </span><span class="cov0" title="0">{
                        endpoints := modelSupportEndpointsStr[modelName]
                        for k := range raw </span><span class="cov0" title="0">{
                                if !common.StringsContains(endpoints, k) </span><span class="cov0" title="0">{
                                        endpoints = append(endpoints, k)
                                }</span>
                        }
                        <span class="cov0" title="0">modelSupportEndpointsStr[modelName] = endpoints</span>
                }
        }

        <span class="cov0" title="0">modelSupportEndpointTypes = make(map[string][]constant.EndpointType)
        for model, endpoints := range modelSupportEndpointsStr </span><span class="cov0" title="0">{
                supportedEndpoints := make([]constant.EndpointType, 0)
                for _, endpointStr := range endpoints </span><span class="cov0" title="0">{
                        endpointType := constant.EndpointType(endpointStr)
                        supportedEndpoints = append(supportedEndpoints, endpointType)
                }</span>
                <span class="cov0" title="0">modelSupportEndpointTypes[model] = supportedEndpoints</span>
        }

        // 构建全局 supportedEndpointMap（默认 + 自定义覆盖）
        <span class="cov0" title="0">supportedEndpointMap = make(map[string]common.EndpointInfo)
        // 1. 默认端点
        for _, endpoints := range modelSupportEndpointTypes </span><span class="cov0" title="0">{
                for _, et := range endpoints </span><span class="cov0" title="0">{
                        if info, ok := common.GetDefaultEndpointInfo(et); ok </span><span class="cov0" title="0">{
                                if _, exists := supportedEndpointMap[string(et)]; !exists </span><span class="cov0" title="0">{
                                        supportedEndpointMap[string(et)] = info
                                }</span>
                        }
                }
        }
        // 2. 自定义端点（models 表）覆盖默认
        <span class="cov0" title="0">for _, meta := range metaMap </span><span class="cov0" title="0">{
                if strings.TrimSpace(meta.Endpoints) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var raw map[string]interface{}
                if err := json.Unmarshal([]byte(meta.Endpoints), &amp;raw); err == nil </span><span class="cov0" title="0">{
                        for k, v := range raw </span><span class="cov0" title="0">{
                                switch val := v.(type) </span>{
                                case string:<span class="cov0" title="0">
                                        supportedEndpointMap[k] = common.EndpointInfo{Path: val, Method: "POST"}</span>
                                case map[string]interface{}:<span class="cov0" title="0">
                                        ep := common.EndpointInfo{Method: "POST"}
                                        if p, ok := val["path"].(string); ok </span><span class="cov0" title="0">{
                                                ep.Path = p
                                        }</span>
                                        <span class="cov0" title="0">if m, ok := val["method"].(string); ok </span><span class="cov0" title="0">{
                                                ep.Method = strings.ToUpper(m)
                                        }</span>
                                        <span class="cov0" title="0">supportedEndpointMap[k] = ep</span>
                                default:<span class="cov0" title="0"></span>
                                        // ignore unsupported types
                                }
                        }
                }
        }

        <span class="cov0" title="0">pricingMap = make([]Pricing, 0)
        for model, groups := range modelGroupsMap </span><span class="cov0" title="0">{
                pricing := Pricing{
                        ModelName:              model,
                        EnableGroup:            groups.Items(),
                        SupportedEndpointTypes: modelSupportEndpointTypes[model],
                }

                // 补充模型元数据（描述、标签、供应商、状态）
                if meta, ok := metaMap[model]; ok </span><span class="cov0" title="0">{
                        // 若模型被禁用(status!=1)，则直接跳过，不返回给前端
                        if meta.Status != 1 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">pricing.Description = meta.Description
                        pricing.Icon = meta.Icon
                        pricing.Tags = meta.Tags
                        pricing.VendorID = meta.VendorID</span>
                }
                <span class="cov0" title="0">modelPrice, findPrice := ratio_setting.GetModelPrice(model, false)
                if findPrice </span><span class="cov0" title="0">{
                        pricing.ModelPrice = modelPrice
                        pricing.QuotaType = 1
                }</span> else<span class="cov0" title="0"> {
                        modelRatio, _, _ := ratio_setting.GetModelRatio(model)
                        pricing.ModelRatio = modelRatio
                        pricing.CompletionRatio = ratio_setting.GetCompletionRatio(model)
                        pricing.QuotaType = 0
                }</span>
                <span class="cov0" title="0">pricingMap = append(pricingMap, pricing)</span>
        }

        // 刷新缓存映射，供高并发快速查询
        <span class="cov0" title="0">modelEnableGroupsLock.Lock()
        modelEnableGroups = make(map[string][]string)
        modelQuotaTypeMap = make(map[string]int)
        for _, p := range pricingMap </span><span class="cov0" title="0">{
                modelEnableGroups[p.ModelName] = p.EnableGroup
                modelQuotaTypeMap[p.ModelName] = p.QuotaType
        }</span>
        <span class="cov0" title="0">modelEnableGroupsLock.Unlock()

        lastGetPricingTime = time.Now()</span>
}

// GetSupportedEndpointMap 返回全局端点到路径的映射
func GetSupportedEndpointMap() map[string]common.EndpointInfo <span class="cov0" title="0">{
        return supportedEndpointMap
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package model

import (
        "strings"
)

// 简化的供应商映射规则
var defaultVendorRules = map[string]string{
        "gpt":      "OpenAI",
        "dall-e":   "OpenAI",
        "whisper":  "OpenAI",
        "o1":       "OpenAI",
        "o3":       "OpenAI",
        "claude":   "Anthropic",
        "gemini":   "Google",
        "moonshot": "Moonshot",
        "kimi":     "Moonshot",
        "chatglm":  "智谱",
        "glm-":     "智谱",
        "qwen":     "阿里巴巴",
        "deepseek": "DeepSeek",
        "abab":     "MiniMax",
        "ernie":    "百度",
        "spark":    "讯飞",
        "hunyuan":  "腾讯",
        "command":  "Cohere",
        "@cf/":     "Cloudflare",
        "360":      "360",
        "yi":       "零一万物",
        "jina":     "Jina",
        "mistral":  "Mistral",
        "grok":     "xAI",
        "llama":    "Meta",
        "doubao":   "字节跳动",
        "kling":    "快手",
        "jimeng":   "即梦",
        "vidu":     "Vidu",
}

// 供应商默认图标映射
var defaultVendorIcons = map[string]string{
        "OpenAI":     "OpenAI",
        "Anthropic":  "Claude.Color",
        "Google":     "Gemini.Color",
        "Moonshot":   "Moonshot",
        "智谱":         "Zhipu.Color",
        "阿里巴巴":       "Qwen.Color",
        "DeepSeek":   "DeepSeek.Color",
        "MiniMax":    "Minimax.Color",
        "百度":         "Wenxin.Color",
        "讯飞":         "Spark.Color",
        "腾讯":         "Hunyuan.Color",
        "Cohere":     "Cohere.Color",
        "Cloudflare": "Cloudflare.Color",
        "360":        "Ai360.Color",
        "零一万物":       "Yi.Color",
        "Jina":       "Jina",
        "Mistral":    "Mistral.Color",
        "xAI":        "XAI",
        "Meta":       "Ollama",
        "字节跳动":       "Doubao.Color",
        "快手":         "Kling.Color",
        "即梦":         "Jimeng.Color",
        "Vidu":       "Vidu",
        "微软":         "AzureAI",
        "Microsoft":  "AzureAI",
        "Azure":      "AzureAI",
}

// initDefaultVendorMapping 简化的默认供应商映射
func initDefaultVendorMapping(metaMap map[string]*Model, vendorMap map[int]*Vendor, enableAbilities []AbilityWithChannel) <span class="cov0" title="0">{
        for _, ability := range enableAbilities </span><span class="cov0" title="0">{
                modelName := ability.Model
                if _, exists := metaMap[modelName]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 匹配供应商
                <span class="cov0" title="0">vendorID := 0
                modelLower := strings.ToLower(modelName)
                for pattern, vendorName := range defaultVendorRules </span><span class="cov0" title="0">{
                        if strings.Contains(modelLower, pattern) </span><span class="cov0" title="0">{
                                vendorID = getOrCreateVendor(vendorName, vendorMap)
                                break</span>
                        }
                }

                // 创建模型元数据
                <span class="cov0" title="0">metaMap[modelName] = &amp;Model{
                        ModelName: modelName,
                        VendorID:  vendorID,
                        Status:    1,
                        NameRule:  NameRuleExact,
                }</span>
        }
}

// 查找或创建供应商
func getOrCreateVendor(vendorName string, vendorMap map[int]*Vendor) int <span class="cov0" title="0">{
        // 查找现有供应商
        for id, vendor := range vendorMap </span><span class="cov0" title="0">{
                if vendor.Name == vendorName </span><span class="cov0" title="0">{
                        return id
                }</span>
        }

        // 创建新供应商
        <span class="cov0" title="0">newVendor := &amp;Vendor{
                Name:   vendorName,
                Status: 1,
                Icon:   getDefaultVendorIcon(vendorName),
        }

        if err := newVendor.Insert(); err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">vendorMap[newVendor.Id] = newVendor
        return newVendor.Id</span>
}

// 获取供应商默认图标
func getDefaultVendorIcon(vendorName string) string <span class="cov0" title="0">{
        if icon, exists := defaultVendorIcons[vendorName]; exists </span><span class="cov0" title="0">{
                return icon
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package model

// RefreshPricing 强制立即重新计算与定价相关的缓存。
// 该方法用于需要最新数据的内部管理 API，
// 因此会绕过默认的 1 分钟延迟刷新。
func RefreshPricing() <span class="cov0" title="0">{
        updatePricingLock.Lock()
        defer updatePricingLock.Unlock()

        modelSupportEndpointsLock.Lock()
        defer modelSupportEndpointsLock.Unlock()

        updatePricing()
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package model

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"

        "gorm.io/gorm"
)

type Redemption struct {
        Id           int            `json:"id"`
        UserId       int            `json:"user_id"`
        Key          string         `json:"key" gorm:"type:char(32);uniqueIndex"`
        Status       int            `json:"status" gorm:"default:1"`
        Name         string         `json:"name" gorm:"index"`
        Quota        int            `json:"quota" gorm:"default:100"`
        CreatedTime  int64          `json:"created_time" gorm:"bigint"`
        RedeemedTime int64          `json:"redeemed_time" gorm:"bigint"`
        Count        int            `json:"count" gorm:"-:all"` // only for api request
        UsedUserId   int            `json:"used_user_id"`
        DeletedAt    gorm.DeletedAt `gorm:"index"`
        ExpiredTime  int64          `json:"expired_time" gorm:"bigint"` // 过期时间，0 表示不过期
}

func GetAllRedemptions(startIdx int, num int) (redemptions []*Redemption, total int64, err error) <span class="cov0" title="0">{
        // 开始事务
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // 获取总数
        <span class="cov0" title="0">err = tx.Model(&amp;Redemption{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // 获取分页数据
        <span class="cov0" title="0">err = tx.Order("id desc").Limit(num).Offset(startIdx).Find(&amp;redemptions).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return redemptions, total, nil</span>
}

func SearchRedemptions(keyword string, startIdx int, num int) (redemptions []*Redemption, total int64, err error) <span class="cov0" title="0">{
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Build query based on keyword type
        <span class="cov0" title="0">query := tx.Model(&amp;Redemption{})

        // Only try to convert to ID if the string represents a valid integer
        if id, err := strconv.Atoi(keyword); err == nil </span><span class="cov0" title="0">{
                query = query.Where("id = ? OR name LIKE ?", id, keyword+"%")
        }</span> else<span class="cov0" title="0"> {
                query = query.Where("name LIKE ?", keyword+"%")
        }</span>

        // Get total count
        <span class="cov0" title="0">err = query.Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // Get paginated data
        <span class="cov0" title="0">err = query.Order("id desc").Limit(num).Offset(startIdx).Find(&amp;redemptions).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return redemptions, total, nil</span>
}

func GetRedemptionById(id int) (*Redemption, error) <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">redemption := Redemption{Id: id}
        var err error = nil
        err = DB.First(&amp;redemption, "id = ?", id).Error
        return &amp;redemption, err</span>
}

func Redeem(key string, userId int) (quota int, err error) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return 0, errors.New("未提供兑换码")
        }</span>
        <span class="cov0" title="0">if userId == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("无效的 user id")
        }</span>
        <span class="cov0" title="0">redemption := &amp;Redemption{}

        keyCol := "`key`"
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                keyCol = `"key"`
        }</span>
        <span class="cov0" title="0">common.RandomSleep()
        err = DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                err := tx.Set("gorm:query_option", "FOR UPDATE").Where(keyCol+" = ?", key).First(redemption).Error
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("无效的兑换码")
                }</span>
                <span class="cov0" title="0">if redemption.Status != common.RedemptionCodeStatusEnabled </span><span class="cov0" title="0">{
                        return errors.New("该兑换码已被使用")
                }</span>
                <span class="cov0" title="0">if redemption.ExpiredTime != 0 &amp;&amp; redemption.ExpiredTime &lt; common.GetTimestamp() </span><span class="cov0" title="0">{
                        return errors.New("该兑换码已过期")
                }</span>
                <span class="cov0" title="0">err = tx.Model(&amp;User{}).Where("id = ?", userId).Update("quota", gorm.Expr("quota + ?", redemption.Quota)).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">redemption.RedeemedTime = common.GetTimestamp()
                redemption.Status = common.RedemptionCodeStatusUsed
                redemption.UsedUserId = userId
                err = tx.Save(redemption).Error
                return err</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("兑换失败，" + err.Error())
        }</span>
        <span class="cov0" title="0">RecordLog(userId, LogTypeTopup, fmt.Sprintf("通过兑换码充值 %s，兑换码ID %d", logger.LogQuota(redemption.Quota), redemption.Id))
        return redemption.Quota, nil</span>
}

func (redemption *Redemption) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(redemption).Error
        return err
}</span>

func (redemption *Redemption) SelectUpdate() error <span class="cov0" title="0">{
        // This can update zero values
        return DB.Model(redemption).Select("redeemed_time", "status").Updates(redemption).Error
}</span>

// Update Make sure your token's fields is completed, because this will update non-zero values
func (redemption *Redemption) Update() error <span class="cov0" title="0">{
        var err error
        err = DB.Model(redemption).Select("name", "status", "quota", "redeemed_time", "expired_time").Updates(redemption).Error
        return err
}</span>

func (redemption *Redemption) Delete() error <span class="cov0" title="0">{
        var err error
        err = DB.Delete(redemption).Error
        return err
}</span>

func DeleteRedemptionById(id int) (err error) <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">redemption := Redemption{Id: id}
        err = DB.Where(redemption).First(&amp;redemption).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return redemption.Delete()</span>
}

func DeleteInvalidRedemptions() (int64, error) <span class="cov0" title="0">{
        now := common.GetTimestamp()
        result := DB.Where("status IN ? OR (status = ? AND expired_time != 0 AND expired_time &lt; ?)", []int{common.RedemptionCodeStatusUsed, common.RedemptionCodeStatusDisabled}, common.RedemptionCodeStatusEnabled, now).Delete(&amp;Redemption{})
        return result.RowsAffected, result.Error
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package model

type Setup struct {
        ID            uint   `json:"id" gorm:"primaryKey"`
        Version       string `json:"version" gorm:"type:varchar(50);not null"`
        InitializedAt int64  `json:"initialized_at" gorm:"type:bigint;not null"`
}

func GetSetup() *Setup <span class="cov0" title="0">{
        var setup Setup
        err := DB.First(&amp;setup).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;setup</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"
        "time"

        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        commonRelay "github.com/QuantumNous/new-api/relay/common"
)

type TaskStatus string

func (t TaskStatus) ToVideoStatus() string <span class="cov0" title="0">{
        var status string
        switch t </span>{
        case TaskStatusQueued, TaskStatusSubmitted:<span class="cov0" title="0">
                status = dto.VideoStatusQueued</span>
        case TaskStatusInProgress:<span class="cov0" title="0">
                status = dto.VideoStatusInProgress</span>
        case TaskStatusSuccess:<span class="cov0" title="0">
                status = dto.VideoStatusCompleted</span>
        case TaskStatusFailure:<span class="cov0" title="0">
                status = dto.VideoStatusFailed</span>
        default:<span class="cov0" title="0">
                status = dto.VideoStatusUnknown</span> // Default fallback
        }
        <span class="cov0" title="0">return status</span>
}

const (
        TaskStatusNotStart   TaskStatus = "NOT_START"
        TaskStatusSubmitted             = "SUBMITTED"
        TaskStatusQueued                = "QUEUED"
        TaskStatusInProgress            = "IN_PROGRESS"
        TaskStatusFailure               = "FAILURE"
        TaskStatusSuccess               = "SUCCESS"
        TaskStatusUnknown               = "UNKNOWN"
)

type Task struct {
        ID         int64                 `json:"id" gorm:"primary_key;AUTO_INCREMENT"`
        CreatedAt  int64                 `json:"created_at" gorm:"index"`
        UpdatedAt  int64                 `json:"updated_at"`
        TaskID     string                `json:"task_id" gorm:"type:varchar(191);index"` // 第三方id，不一定有/ song id\ Task id
        Platform   constant.TaskPlatform `json:"platform" gorm:"type:varchar(30);index"` // 平台
        UserId     int                   `json:"user_id" gorm:"index"`
        Group      string                `json:"group" gorm:"type:varchar(50)"` // 修正计费用
        ChannelId  int                   `json:"channel_id" gorm:"index"`
        Quota      int                   `json:"quota"`
        Action     string                `json:"action" gorm:"type:varchar(40);index"` // 任务类型, song, lyrics, description-mode
        Status     TaskStatus            `json:"status" gorm:"type:varchar(20);index"` // 任务状态
        FailReason string                `json:"fail_reason"`
        SubmitTime int64                 `json:"submit_time" gorm:"index"`
        StartTime  int64                 `json:"start_time" gorm:"index"`
        FinishTime int64                 `json:"finish_time" gorm:"index"`
        Progress   string                `json:"progress" gorm:"type:varchar(20);index"`
        Properties Properties            `json:"properties" gorm:"type:json"`
        // 禁止返回给用户，内部可能包含key等隐私信息
        PrivateData TaskPrivateData `json:"-" gorm:"column:private_data;type:json"`
        Data        json.RawMessage `json:"data" gorm:"type:json"`
}

func (t *Task) SetData(data any) <span class="cov0" title="0">{
        b, _ := json.Marshal(data)
        t.Data = json.RawMessage(b)
}</span>

func (t *Task) GetData(v any) error <span class="cov0" title="0">{
        err := json.Unmarshal(t.Data, &amp;v)
        return err
}</span>

type Properties struct {
        Input             string `json:"input"`
        UpstreamModelName string `json:"upstream_model_name,omitempty"`
        OriginModelName   string `json:"origin_model_name,omitempty"`
}

func (m *Properties) Scan(val interface{}) error <span class="cov0" title="0">{
        bytesValue, _ := val.([]byte)
        if len(bytesValue) == 0 </span><span class="cov0" title="0">{
                *m = Properties{}
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(bytesValue, m)</span>
}

func (m Properties) Value() (driver.Value, error) <span class="cov0" title="0">{
        if m == (Properties{}) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(m)</span>
}

type TaskPrivateData struct {
        Key string `json:"key,omitempty"`
}

func (p *TaskPrivateData) Scan(val interface{}) error <span class="cov0" title="0">{
        bytesValue, _ := val.([]byte)
        if len(bytesValue) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(bytesValue, p)</span>
}

func (p TaskPrivateData) Value() (driver.Value, error) <span class="cov0" title="0">{
        if (p == TaskPrivateData{}) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(p)</span>
}

// SyncTaskQueryParams 用于包含所有搜索条件的结构体，可以根据需求添加更多字段
type SyncTaskQueryParams struct {
        Platform       constant.TaskPlatform
        ChannelID      string
        TaskID         string
        UserID         string
        Action         string
        Status         string
        StartTimestamp int64
        EndTimestamp   int64
        UserIDs        []int
}

func InitTask(platform constant.TaskPlatform, relayInfo *commonRelay.RelayInfo) *Task <span class="cov0" title="0">{
        properties := Properties{}
        privateData := TaskPrivateData{}
        if relayInfo != nil &amp;&amp; relayInfo.ChannelMeta != nil </span><span class="cov0" title="0">{
                if relayInfo.ChannelMeta.ChannelType == constant.ChannelTypeGemini </span><span class="cov0" title="0">{
                        privateData.Key = relayInfo.ChannelMeta.ApiKey
                }</span>
                <span class="cov0" title="0">if relayInfo.UpstreamModelName != "" </span><span class="cov0" title="0">{
                        properties.UpstreamModelName = relayInfo.UpstreamModelName
                }</span>
                <span class="cov0" title="0">if relayInfo.OriginModelName != "" </span><span class="cov0" title="0">{
                        properties.OriginModelName = relayInfo.OriginModelName
                }</span>
        }

        <span class="cov0" title="0">t := &amp;Task{
                UserId:      relayInfo.UserId,
                Group:       relayInfo.UsingGroup,
                SubmitTime:  time.Now().Unix(),
                Status:      TaskStatusNotStart,
                Progress:    "0%",
                ChannelId:   relayInfo.ChannelId,
                Platform:    platform,
                Properties:  properties,
                PrivateData: privateData,
        }
        return t</span>
}

func TaskGetAllUserTask(userId int, startIdx int, num int, queryParams SyncTaskQueryParams) []*Task <span class="cov0" title="0">{
        var tasks []*Task
        var err error

        // 初始化查询构建器
        query := DB.Where("user_id = ?", userId)

        if queryParams.TaskID != "" </span><span class="cov0" title="0">{
                query = query.Where("task_id = ?", queryParams.TaskID)
        }</span>
        <span class="cov0" title="0">if queryParams.Action != "" </span><span class="cov0" title="0">{
                query = query.Where("action = ?", queryParams.Action)
        }</span>
        <span class="cov0" title="0">if queryParams.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", queryParams.Status)
        }</span>
        <span class="cov0" title="0">if queryParams.Platform != "" </span><span class="cov0" title="0">{
                query = query.Where("platform = ?", queryParams.Platform)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != 0 </span><span class="cov0" title="0">{
                // 假设您已将前端传来的时间戳转换为数据库所需的时间格式，并处理了时间戳的验证和解析
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>

        // 获取数据
        <span class="cov0" title="0">err = query.Omit("channel_id").Order("id desc").Limit(num).Offset(startIdx).Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

func TaskGetAllTasks(startIdx int, num int, queryParams SyncTaskQueryParams) []*Task <span class="cov0" title="0">{
        var tasks []*Task
        var err error

        // 初始化查询构建器
        query := DB

        // 添加过滤条件
        if queryParams.ChannelID != "" </span><span class="cov0" title="0">{
                query = query.Where("channel_id = ?", queryParams.ChannelID)
        }</span>
        <span class="cov0" title="0">if queryParams.Platform != "" </span><span class="cov0" title="0">{
                query = query.Where("platform = ?", queryParams.Platform)
        }</span>
        <span class="cov0" title="0">if queryParams.UserID != "" </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", queryParams.UserID)
        }</span>
        <span class="cov0" title="0">if len(queryParams.UserIDs) != 0 </span><span class="cov0" title="0">{
                query = query.Where("user_id in (?)", queryParams.UserIDs)
        }</span>
        <span class="cov0" title="0">if queryParams.TaskID != "" </span><span class="cov0" title="0">{
                query = query.Where("task_id = ?", queryParams.TaskID)
        }</span>
        <span class="cov0" title="0">if queryParams.Action != "" </span><span class="cov0" title="0">{
                query = query.Where("action = ?", queryParams.Action)
        }</span>
        <span class="cov0" title="0">if queryParams.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", queryParams.Status)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>

        // 获取数据
        <span class="cov0" title="0">err = query.Order("id desc").Limit(num).Offset(startIdx).Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

func GetAllUnFinishSyncTasks(limit int) []*Task <span class="cov0" title="0">{
        var tasks []*Task
        var err error
        // get all tasks progress is not 100%
        err = DB.Where("progress != ?", "100%").Where("status != ?", TaskStatusFailure).Where("status != ?", TaskStatusSuccess).Limit(limit).Order("id").Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tasks</span>
}

func GetByOnlyTaskId(taskId string) (*Task, bool, error) <span class="cov0" title="0">{
        if taskId == "" </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>
        <span class="cov0" title="0">var task *Task
        var err error
        err = DB.Where("task_id = ?", taskId).First(&amp;task).Error
        exist, err := RecordExist(err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return task, exist, err</span>
}

func GetByTaskId(userId int, taskId string) (*Task, bool, error) <span class="cov0" title="0">{
        if taskId == "" </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>
        <span class="cov0" title="0">var task *Task
        var err error
        err = DB.Where("user_id = ? and task_id = ?", userId, taskId).
                First(&amp;task).Error
        exist, err := RecordExist(err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return task, exist, err</span>
}

func GetByTaskIds(userId int, taskIds []any) ([]*Task, error) <span class="cov0" title="0">{
        if len(taskIds) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var task []*Task
        var err error
        err = DB.Where("user_id = ? and task_id in (?)", userId, taskIds).
                Find(&amp;task).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func TaskUpdateProgress(id int64, progress string) error <span class="cov0" title="0">{
        return DB.Model(&amp;Task{}).Where("id = ?", id).Update("progress", progress).Error
}</span>

func (Task *Task) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(Task).Error
        return err
}</span>

func (Task *Task) Update() error <span class="cov0" title="0">{
        var err error
        err = DB.Save(Task).Error
        return err
}</span>

func TaskBulkUpdate(TaskIds []string, params map[string]any) error <span class="cov0" title="0">{
        if len(TaskIds) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return DB.Model(&amp;Task{}).
                Where("task_id in (?)", TaskIds).
                Updates(params).Error</span>
}

func TaskBulkUpdateByTaskIds(taskIDs []int64, params map[string]any) error <span class="cov0" title="0">{
        if len(taskIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return DB.Model(&amp;Task{}).
                Where("id in (?)", taskIDs).
                Updates(params).Error</span>
}

func TaskBulkUpdateByID(ids []int64, params map[string]any) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return DB.Model(&amp;Task{}).
                Where("id in (?)", ids).
                Updates(params).Error</span>
}

type TaskQuotaUsage struct {
        Mode  string  `json:"mode"`
        Count float64 `json:"count"`
}

func SumUsedTaskQuota(queryParams SyncTaskQueryParams) (stat []TaskQuotaUsage, err error) <span class="cov0" title="0">{
        query := DB.Model(Task{})
        // 添加过滤条件
        if queryParams.ChannelID != "" </span><span class="cov0" title="0">{
                query = query.Where("channel_id = ?", queryParams.ChannelID)
        }</span>
        <span class="cov0" title="0">if queryParams.UserID != "" </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", queryParams.UserID)
        }</span>
        <span class="cov0" title="0">if len(queryParams.UserIDs) != 0 </span><span class="cov0" title="0">{
                query = query.Where("user_id in (?)", queryParams.UserIDs)
        }</span>
        <span class="cov0" title="0">if queryParams.TaskID != "" </span><span class="cov0" title="0">{
                query = query.Where("task_id = ?", queryParams.TaskID)
        }</span>
        <span class="cov0" title="0">if queryParams.Action != "" </span><span class="cov0" title="0">{
                query = query.Where("action = ?", queryParams.Action)
        }</span>
        <span class="cov0" title="0">if queryParams.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", queryParams.Status)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>
        <span class="cov0" title="0">err = query.Select("mode, sum(quota) as count").Group("mode").Find(&amp;stat).Error
        return stat, err</span>
}

// TaskCountAllTasks returns total tasks that match the given query params (admin usage)
func TaskCountAllTasks(queryParams SyncTaskQueryParams) int64 <span class="cov0" title="0">{
        var total int64
        query := DB.Model(&amp;Task{})
        if queryParams.ChannelID != "" </span><span class="cov0" title="0">{
                query = query.Where("channel_id = ?", queryParams.ChannelID)
        }</span>
        <span class="cov0" title="0">if queryParams.Platform != "" </span><span class="cov0" title="0">{
                query = query.Where("platform = ?", queryParams.Platform)
        }</span>
        <span class="cov0" title="0">if queryParams.UserID != "" </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", queryParams.UserID)
        }</span>
        <span class="cov0" title="0">if len(queryParams.UserIDs) != 0 </span><span class="cov0" title="0">{
                query = query.Where("user_id in (?)", queryParams.UserIDs)
        }</span>
        <span class="cov0" title="0">if queryParams.TaskID != "" </span><span class="cov0" title="0">{
                query = query.Where("task_id = ?", queryParams.TaskID)
        }</span>
        <span class="cov0" title="0">if queryParams.Action != "" </span><span class="cov0" title="0">{
                query = query.Where("action = ?", queryParams.Action)
        }</span>
        <span class="cov0" title="0">if queryParams.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", queryParams.Status)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>
        <span class="cov0" title="0">_ = query.Count(&amp;total).Error
        return total</span>
}

// TaskCountAllUserTask returns total tasks for given user
func TaskCountAllUserTask(userId int, queryParams SyncTaskQueryParams) int64 <span class="cov0" title="0">{
        var total int64
        query := DB.Model(&amp;Task{}).Where("user_id = ?", userId)
        if queryParams.TaskID != "" </span><span class="cov0" title="0">{
                query = query.Where("task_id = ?", queryParams.TaskID)
        }</span>
        <span class="cov0" title="0">if queryParams.Action != "" </span><span class="cov0" title="0">{
                query = query.Where("action = ?", queryParams.Action)
        }</span>
        <span class="cov0" title="0">if queryParams.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", queryParams.Status)
        }</span>
        <span class="cov0" title="0">if queryParams.Platform != "" </span><span class="cov0" title="0">{
                query = query.Where("platform = ?", queryParams.Platform)
        }</span>
        <span class="cov0" title="0">if queryParams.StartTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &gt;= ?", queryParams.StartTimestamp)
        }</span>
        <span class="cov0" title="0">if queryParams.EndTimestamp != 0 </span><span class="cov0" title="0">{
                query = query.Where("submit_time &lt;= ?", queryParams.EndTimestamp)
        }</span>
        <span class="cov0" title="0">_ = query.Count(&amp;total).Error
        return total</span>
}
func (t *Task) ToOpenAIVideo() *dto.OpenAIVideo <span class="cov0" title="0">{
        openAIVideo := dto.NewOpenAIVideo()
        openAIVideo.ID = t.TaskID
        openAIVideo.Status = t.Status.ToVideoStatus()
        openAIVideo.Model = t.Properties.OriginModelName
        openAIVideo.SetProgressStr(t.Progress)
        openAIVideo.CreatedAt = t.CreatedAt
        openAIVideo.CompletedAt = t.UpdatedAt
        openAIVideo.SetMetadata("url", t.FailReason)
        return openAIVideo
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/QuantumNous/new-api/common"

        "github.com/bytedance/gopkg/util/gopool"
        "gorm.io/gorm"
)

type Token struct {
        Id                 int            `json:"id"`
        UserId             int            `json:"user_id" gorm:"index"`
        Key                string         `json:"key" gorm:"type:char(48);uniqueIndex"`
        Status             int            `json:"status" gorm:"default:1"`
        Name               string         `json:"name" gorm:"index" `
        CreatedTime        int64          `json:"created_time" gorm:"bigint"`
        AccessedTime       int64          `json:"accessed_time" gorm:"bigint"`
        ExpiredTime        int64          `json:"expired_time" gorm:"bigint;default:-1"` // -1 means never expired
        RemainQuota        int            `json:"remain_quota" gorm:"default:0"`
        UnlimitedQuota     bool           `json:"unlimited_quota"`
        ModelLimitsEnabled bool           `json:"model_limits_enabled"`
        ModelLimits        string         `json:"model_limits" gorm:"type:varchar(1024);default:''"`
        AllowIps           *string        `json:"allow_ips" gorm:"default:''"`
        UsedQuota          int            `json:"used_quota" gorm:"default:0"` // used quota
        Group              string         `json:"group" gorm:"default:''"`     // 单分组(向后兼容)
        GroupPriorities    string         `json:"group_priorities" gorm:"type:varchar(2048);default:''"` // 多分组优先级(JSON)
        AutoSmartGroup     bool           `json:"auto_smart_group" gorm:"default:false"`                 // 自动智能分组
        DeletedAt          gorm.DeletedAt `gorm:"index"`
}

// GroupPriority 分组优先级结构
type GroupPriority struct {
        Group    string `json:"group"`
        Priority int    `json:"priority"`
}

func (token *Token) Clean() <span class="cov0" title="0">{
        token.Key = ""
}</span>

// GetGroupPriorities 获取分组优先级列表
func (token *Token) GetGroupPriorities() ([]GroupPriority, error) <span class="cov8" title="1">{
        if token.GroupPriorities == "" </span><span class="cov8" title="1">{
                // 向后兼容：如果没有配置多分组，使用 Group 字段
                if token.Group != "" </span><span class="cov8" title="1">{
                        return []GroupPriority{{Group: token.Group, Priority: 1}}, nil
                }</span>
                <span class="cov8" title="1">return []GroupPriority{}, nil</span>
        }

        <span class="cov8" title="1">var priorities []GroupPriority
        err := json.Unmarshal([]byte(token.GroupPriorities), &amp;priorities)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 按优先级排序
        <span class="cov8" title="1">sort.Slice(priorities, func(i, j int) bool </span><span class="cov8" title="1">{
                return priorities[i].Priority &lt; priorities[j].Priority
        }</span>)

        <span class="cov8" title="1">return priorities, nil</span>
}

// SetGroupPriorities 设置分组优先级列表
func (token *Token) SetGroupPriorities(priorities []GroupPriority) error <span class="cov8" title="1">{
        if len(priorities) == 0 </span><span class="cov8" title="1">{
                token.GroupPriorities = ""
                return nil
        }</span>

        // 验证优先级
        <span class="cov8" title="1">for i, p := range priorities </span><span class="cov8" title="1">{
                if p.Group == "" </span><span class="cov8" title="1">{
                        return errors.New("分组名称不能为空")
                }</span>
                <span class="cov8" title="1">if p.Priority &lt; 1 </span><span class="cov8" title="1">{
                        return errors.New("优先级必须大于0")
                }</span>
                // 检查重复
                <span class="cov8" title="1">for j := i + 1; j &lt; len(priorities); j++ </span><span class="cov8" title="1">{
                        if priorities[j].Group == p.Group </span><span class="cov8" title="1">{
                                return errors.New("分组不能重复")
                        }</span>
                }
        }

        <span class="cov8" title="1">data, err := json.Marshal(priorities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">token.GroupPriorities = string(data)

        // 同步更新 Group 字段为第一个分组（向后兼容）
        if len(priorities) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(priorities, func(i, j int) bool </span><span class="cov8" title="1">{
                        return priorities[i].Priority &lt; priorities[j].Priority
                }</span>)
                <span class="cov8" title="1">token.Group = priorities[0].Group</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (token *Token) GetIpLimitsMap() map[string]any <span class="cov0" title="0">{
        // delete empty spaces
        //split with \n
        ipLimitsMap := make(map[string]any)
        if token.AllowIps == nil </span><span class="cov0" title="0">{
                return ipLimitsMap
        }</span>
        <span class="cov0" title="0">cleanIps := strings.ReplaceAll(*token.AllowIps, " ", "")
        if cleanIps == "" </span><span class="cov0" title="0">{
                return ipLimitsMap
        }</span>
        <span class="cov0" title="0">ips := strings.Split(cleanIps, "\n")
        for _, ip := range ips </span><span class="cov0" title="0">{
                ip = strings.TrimSpace(ip)
                ip = strings.ReplaceAll(ip, ",", "")
                if common.IsIP(ip) </span><span class="cov0" title="0">{
                        ipLimitsMap[ip] = true
                }</span>
        }
        <span class="cov0" title="0">return ipLimitsMap</span>
}

func GetAllUserTokens(userId int, startIdx int, num int) ([]*Token, error) <span class="cov0" title="0">{
        var tokens []*Token
        var err error
        err = DB.Where("user_id = ?", userId).Order("id desc").Limit(num).Offset(startIdx).Find(&amp;tokens).Error
        return tokens, err
}</span>

func SearchUserTokens(userId int, keyword string, token string) (tokens []*Token, err error) <span class="cov0" title="0">{
        if token != "" </span><span class="cov0" title="0">{
                token = strings.Trim(token, "sk-")
        }</span>
        <span class="cov0" title="0">err = DB.Where("user_id = ?", userId).Where("name LIKE ?", "%"+keyword+"%").Where(commonKeyCol+" LIKE ?", "%"+token+"%").Find(&amp;tokens).Error
        return tokens, err</span>
}

func ValidateUserToken(key string) (token *Token, err error) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return nil, errors.New("未提供令牌")
        }</span>
        <span class="cov0" title="0">token, err = GetTokenByKey(key, false)
        if err == nil </span><span class="cov0" title="0">{
                if token.Status == common.TokenStatusExhausted </span><span class="cov0" title="0">{
                        keyPrefix := key[:3]
                        keySuffix := key[len(key)-3:]
                        return token, errors.New("该令牌额度已用尽 TokenStatusExhausted[sk-" + keyPrefix + "***" + keySuffix + "]")
                }</span> else<span class="cov0" title="0"> if token.Status == common.TokenStatusExpired </span><span class="cov0" title="0">{
                        return token, errors.New("该令牌已过期")
                }</span>
                <span class="cov0" title="0">if token.Status != common.TokenStatusEnabled </span><span class="cov0" title="0">{
                        return token, errors.New("该令牌状态不可用")
                }</span>
                <span class="cov0" title="0">if token.ExpiredTime != -1 &amp;&amp; token.ExpiredTime &lt; common.GetTimestamp() </span><span class="cov0" title="0">{
                        if !common.RedisEnabled </span><span class="cov0" title="0">{
                                token.Status = common.TokenStatusExpired
                                err := token.SelectUpdate()
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update token status" + err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">return token, errors.New("该令牌已过期")</span>
                }
                <span class="cov0" title="0">if !token.UnlimitedQuota &amp;&amp; token.RemainQuota &lt;= 0 </span><span class="cov0" title="0">{
                        if !common.RedisEnabled </span><span class="cov0" title="0">{
                                // in this case, we can make sure the token is exhausted
                                token.Status = common.TokenStatusExhausted
                                err := token.SelectUpdate()
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update token status" + err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">keyPrefix := key[:3]
                        keySuffix := key[len(key)-3:]
                        return token, errors.New(fmt.Sprintf("[sk-%s***%s] 该令牌额度已用尽 !token.UnlimitedQuota &amp;&amp; token.RemainQuota = %d", keyPrefix, keySuffix, token.RemainQuota))</span>
                }
                <span class="cov0" title="0">return token, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("无效的令牌")</span>
}

func GetTokenByIds(id int, userId int) (*Token, error) <span class="cov0" title="0">{
        if id == 0 || userId == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("id 或 userId 为空！")
        }</span>
        <span class="cov0" title="0">token := Token{Id: id, UserId: userId}
        var err error = nil
        err = DB.First(&amp;token, "id = ? and user_id = ?", id, userId).Error
        return &amp;token, err</span>
}

func GetTokenById(id int) (*Token, error) <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">token := Token{Id: id}
        var err error = nil
        err = DB.First(&amp;token, "id = ?", id).Error
        if shouldUpdateRedis(true, err) </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        if err := cacheSetToken(token); err != nil </span><span class="cov0" title="0">{
                                common.SysLog("failed to update user status cache: " + err.Error())
                        }</span>
                })
        }
        <span class="cov0" title="0">return &amp;token, err</span>
}

func GetTokenByKey(key string, fromDB bool) (token *Token, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) &amp;&amp; token != nil </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := cacheSetToken(*token); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user status cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">if !fromDB &amp;&amp; common.RedisEnabled </span><span class="cov0" title="0">{
                // Try Redis first
                token, err := cacheGetTokenByKey(key)
                if err == nil </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
                // Don't return error - fall through to DB
        }
        <span class="cov0" title="0">fromDB = true
        err = DB.Where(commonKeyCol+" = ?", key).First(&amp;token).Error
        return token, err</span>
}

func (token *Token) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(token).Error
        return err
}</span>

// Update Make sure your token's fields is completed, because this will update non-zero values
func (token *Token) Update() (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if shouldUpdateRedis(true, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                err := cacheSetToken(*token)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update token cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">err = DB.Model(token).Select("name", "status", "expired_time", "remain_quota", "unlimited_quota",
                "model_limits_enabled", "model_limits", "allow_ips", "group", "group_priorities", "auto_smart_group").Updates(token).Error
        return err</span>
}

func (token *Token) SelectUpdate() (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if shouldUpdateRedis(true, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                err := cacheSetToken(*token)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update token cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        // This can update zero values
        <span class="cov0" title="0">return DB.Model(token).Select("accessed_time", "status").Updates(token).Error</span>
}

func (token *Token) Delete() (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if shouldUpdateRedis(true, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                err := cacheDeleteToken(token.Key)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to delete token cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">err = DB.Delete(token).Error
        return err</span>
}

func (token *Token) IsModelLimitsEnabled() bool <span class="cov0" title="0">{
        return token.ModelLimitsEnabled
}</span>

func (token *Token) GetModelLimits() []string <span class="cov0" title="0">{
        if token.ModelLimits == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">return strings.Split(token.ModelLimits, ",")</span>
}

func (token *Token) GetModelLimitsMap() map[string]bool <span class="cov0" title="0">{
        limits := token.GetModelLimits()
        limitsMap := make(map[string]bool)
        for _, limit := range limits </span><span class="cov0" title="0">{
                limitsMap[limit] = true
        }</span>
        <span class="cov0" title="0">return limitsMap</span>
}

func DisableModelLimits(tokenId int) error <span class="cov0" title="0">{
        token, err := GetTokenById(tokenId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">token.ModelLimitsEnabled = false
        token.ModelLimits = ""
        return token.Update()</span>
}

func DeleteTokenById(id int, userId int) (err error) <span class="cov0" title="0">{
        // Why we need userId here? In case user want to delete other's token.
        if id == 0 || userId == 0 </span><span class="cov0" title="0">{
                return errors.New("id 或 userId 为空！")
        }</span>
        <span class="cov0" title="0">token := Token{Id: id, UserId: userId}
        err = DB.Where(token).First(&amp;token).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return token.Delete()</span>
}

func IncreaseTokenQuota(id int, key string, quota int) (err error) <span class="cov0" title="0">{
        if quota &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("quota 不能为负数！")
        }</span>
        <span class="cov0" title="0">if common.RedisEnabled </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        err := cacheIncrTokenQuota(key, int64(quota))
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog("failed to increase token quota: " + err.Error())
                        }</span>
                })
        }
        <span class="cov0" title="0">if common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeTokenQuota, id, quota)
                return nil
        }</span>
        <span class="cov0" title="0">return increaseTokenQuota(id, quota)</span>
}

func increaseTokenQuota(id int, quota int) (err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;Token{}).Where("id = ?", id).Updates(
                map[string]interface{}{
                        "remain_quota":  gorm.Expr("remain_quota + ?", quota),
                        "used_quota":    gorm.Expr("used_quota - ?", quota),
                        "accessed_time": common.GetTimestamp(),
                },
        ).Error
        return err
}</span>

func DecreaseTokenQuota(id int, key string, quota int) (err error) <span class="cov0" title="0">{
        if quota &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("quota 不能为负数！")
        }</span>
        <span class="cov0" title="0">if common.RedisEnabled </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        err := cacheDecrTokenQuota(key, int64(quota))
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog("failed to decrease token quota: " + err.Error())
                        }</span>
                })
        }
        <span class="cov0" title="0">if common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeTokenQuota, id, -quota)
                return nil
        }</span>
        <span class="cov0" title="0">return decreaseTokenQuota(id, quota)</span>
}

func decreaseTokenQuota(id int, quota int) (err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;Token{}).Where("id = ?", id).Updates(
                map[string]interface{}{
                        "remain_quota":  gorm.Expr("remain_quota - ?", quota),
                        "used_quota":    gorm.Expr("used_quota + ?", quota),
                        "accessed_time": common.GetTimestamp(),
                },
        ).Error
        return err
}</span>

// CountUserTokens returns total number of tokens for the given user, used for pagination
func CountUserTokens(userId int) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := DB.Model(&amp;Token{}).Where("user_id = ?", userId).Count(&amp;total).Error
        return total, err
}</span>

// BatchDeleteTokens 删除指定用户的一组令牌，返回成功删除数量
func BatchDeleteTokens(ids []int, userId int) (int, error) <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("ids 不能为空！")
        }</span>

        <span class="cov0" title="0">tx := DB.Begin()

        var tokens []Token
        if err := tx.Where("user_id = ? AND id IN (?)", userId, ids).Find(&amp;tokens).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return 0, err
        }</span>

        <span class="cov0" title="0">if err := tx.Where("user_id = ? AND id IN (?)", userId, ids).Delete(&amp;Token{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return 0, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if common.RedisEnabled </span><span class="cov0" title="0">{
                gopool.Go(func() </span><span class="cov0" title="0">{
                        for _, t := range tokens </span><span class="cov0" title="0">{
                                _ = cacheDeleteToken(t.Key)
                        }</span>
                })
        }

        <span class="cov0" title="0">return len(tokens), nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package model

import (
        "fmt"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
)

func cacheSetToken(token Token) error <span class="cov0" title="0">{
        key := common.GenerateHMAC(token.Key)
        token.Clean()
        err := common.RedisHSetObj(fmt.Sprintf("token:%s", key), &amp;token, time.Duration(common.RedisKeyCacheSeconds())*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func cacheDeleteToken(key string) error <span class="cov0" title="0">{
        key = common.GenerateHMAC(key)
        err := common.RedisDelKey(fmt.Sprintf("token:%s", key))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func cacheIncrTokenQuota(key string, increment int64) error <span class="cov0" title="0">{
        key = common.GenerateHMAC(key)
        err := common.RedisHIncrBy(fmt.Sprintf("token:%s", key), constant.TokenFiledRemainQuota, increment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func cacheDecrTokenQuota(key string, decrement int64) error <span class="cov0" title="0">{
        return cacheIncrTokenQuota(key, -decrement)
}</span>

func cacheSetTokenField(key string, field string, value string) error <span class="cov0" title="0">{
        key = common.GenerateHMAC(key)
        err := common.RedisHSetField(fmt.Sprintf("token:%s", key), field, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CacheGetTokenByKey 从缓存中获取 token，如果缓存中不存在，则从数据库中获取
func cacheGetTokenByKey(key string) (*Token, error) <span class="cov0" title="0">{
        hmacKey := common.GenerateHMAC(key)
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis is not enabled")
        }</span>
        <span class="cov0" title="0">var token Token
        err := common.RedisHGetObj(fmt.Sprintf("token:%s", hmacKey), &amp;token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">token.Key = key
        return &amp;token, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package model

import (
        "errors"
        "fmt"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"

        "github.com/shopspring/decimal"
        "gorm.io/gorm"
)

type TopUp struct {
        Id            int     `json:"id"`
        UserId        int     `json:"user_id" gorm:"index"`
        Amount        int64   `json:"amount"`
        Money         float64 `json:"money"`
        TradeNo       string  `json:"trade_no" gorm:"unique;type:varchar(255);index"`
        PaymentMethod string  `json:"payment_method" gorm:"type:varchar(50)"`
        CreateTime    int64   `json:"create_time"`
        CompleteTime  int64   `json:"complete_time"`
        Status        string  `json:"status"`
}

func (topUp *TopUp) Insert() error <span class="cov0" title="0">{
        var err error
        err = DB.Create(topUp).Error
        return err
}</span>

func (topUp *TopUp) Update() error <span class="cov0" title="0">{
        var err error
        err = DB.Save(topUp).Error
        return err
}</span>

func GetTopUpById(id int) *TopUp <span class="cov0" title="0">{
        var topUp *TopUp
        var err error
        err = DB.Where("id = ?", id).First(&amp;topUp).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return topUp</span>
}

func GetTopUpByTradeNo(tradeNo string) *TopUp <span class="cov0" title="0">{
        var topUp *TopUp
        var err error
        err = DB.Where("trade_no = ?", tradeNo).First(&amp;topUp).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return topUp</span>
}

func Recharge(referenceId string, customerId string) (err error) <span class="cov0" title="0">{
        if referenceId == "" </span><span class="cov0" title="0">{
                return errors.New("未提供支付单号")
        }</span>

        <span class="cov0" title="0">var quota float64
        topUp := &amp;TopUp{}

        refCol := "`trade_no`"
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                refCol = `"trade_no"`
        }</span>

        <span class="cov0" title="0">err = DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                err := tx.Set("gorm:query_option", "FOR UPDATE").Where(refCol+" = ?", referenceId).First(topUp).Error
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("充值订单不存在")
                }</span>

                <span class="cov0" title="0">if topUp.Status != common.TopUpStatusPending </span><span class="cov0" title="0">{
                        return errors.New("充值订单状态错误")
                }</span>

                <span class="cov0" title="0">topUp.CompleteTime = common.GetTimestamp()
                topUp.Status = common.TopUpStatusSuccess
                err = tx.Save(topUp).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">quota = topUp.Money * common.QuotaPerUnit
                err = tx.Model(&amp;User{}).Where("id = ?", topUp.UserId).Updates(map[string]interface{}{"stripe_customer": customerId, "quota": gorm.Expr("quota + ?", quota)}).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.New("充值失败，" + err.Error())
        }</span>

        <span class="cov0" title="0">RecordLog(topUp.UserId, LogTypeTopup, fmt.Sprintf("使用在线充值成功，充值金额: %v，支付金额：%d", logger.FormatQuota(int(quota)), topUp.Amount))

        return nil</span>
}

func GetUserTopUps(userId int, pageInfo *common.PageInfo) (topups []*TopUp, total int64, err error) <span class="cov0" title="0">{
        // Start transaction
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Get total count within transaction
        <span class="cov0" title="0">err = tx.Model(&amp;TopUp{}).Where("user_id = ?", userId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // Get paginated topups within same transaction
        <span class="cov0" title="0">err = tx.Where("user_id = ?", userId).Order("id desc").Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Find(&amp;topups).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return topups, total, nil</span>
}

// GetAllTopUps 获取全平台的充值记录（管理员使用）
func GetAllTopUps(pageInfo *common.PageInfo) (topups []*TopUp, total int64, err error) <span class="cov0" title="0">{
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">if err = tx.Model(&amp;TopUp{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = tx.Order("id desc").Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Find(&amp;topups).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return topups, total, nil</span>
}

// SearchUserTopUps 按订单号搜索某用户的充值记录
func SearchUserTopUps(userId int, keyword string, pageInfo *common.PageInfo) (topups []*TopUp, total int64, err error) <span class="cov0" title="0">{
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">query := tx.Model(&amp;TopUp{}).Where("user_id = ?", userId)
        if keyword != "" </span><span class="cov0" title="0">{
                like := "%%" + keyword + "%%"
                query = query.Where("trade_no LIKE ?", like)
        }</span>

        <span class="cov0" title="0">if err = query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = query.Order("id desc").Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Find(&amp;topups).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return topups, total, nil</span>
}

// SearchAllTopUps 按订单号搜索全平台充值记录（管理员使用）
func SearchAllTopUps(keyword string, pageInfo *common.PageInfo) (topups []*TopUp, total int64, err error) <span class="cov0" title="0">{
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">query := tx.Model(&amp;TopUp{})
        if keyword != "" </span><span class="cov0" title="0">{
                like := "%%" + keyword + "%%"
                query = query.Where("trade_no LIKE ?", like)
        }</span>

        <span class="cov0" title="0">if err = query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = query.Order("id desc").Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Find(&amp;topups).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return topups, total, nil</span>
}

// ManualCompleteTopUp 管理员手动完成订单并给用户充值
func ManualCompleteTopUp(tradeNo string) error <span class="cov0" title="0">{
        if tradeNo == "" </span><span class="cov0" title="0">{
                return errors.New("未提供订单号")
        }</span>

        <span class="cov0" title="0">refCol := "`trade_no`"
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                refCol = `"trade_no"`
        }</span>

        <span class="cov0" title="0">var userId int
        var quotaToAdd int
        var payMoney float64

        err := DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                topUp := &amp;TopUp{}
                // 行级锁，避免并发补单
                if err := tx.Set("gorm:query_option", "FOR UPDATE").Where(refCol+" = ?", tradeNo).First(topUp).Error; err != nil </span><span class="cov0" title="0">{
                        return errors.New("充值订单不存在")
                }</span>

                // 幂等处理：已成功直接返回
                <span class="cov0" title="0">if topUp.Status == common.TopUpStatusSuccess </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if topUp.Status != common.TopUpStatusPending </span><span class="cov0" title="0">{
                        return errors.New("订单状态不是待支付，无法补单")
                }</span>

                // 计算应充值额度：
                // - Stripe 订单：Money 代表经分组倍率换算后的美元数量，直接 * QuotaPerUnit
                // - 其他订单（如易支付）：Amount 为美元数量，* QuotaPerUnit
                <span class="cov0" title="0">if topUp.PaymentMethod == "stripe" </span><span class="cov0" title="0">{
                        dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                        quotaToAdd = int(decimal.NewFromFloat(topUp.Money).Mul(dQuotaPerUnit).IntPart())
                }</span> else<span class="cov0" title="0"> {
                        dAmount := decimal.NewFromInt(topUp.Amount)
                        dQuotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                        quotaToAdd = int(dAmount.Mul(dQuotaPerUnit).IntPart())
                }</span>
                <span class="cov0" title="0">if quotaToAdd &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("无效的充值额度")
                }</span>

                // 标记完成
                <span class="cov0" title="0">topUp.CompleteTime = common.GetTimestamp()
                topUp.Status = common.TopUpStatusSuccess
                if err := tx.Save(topUp).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 增加用户额度（立即写库，保持一致性）
                <span class="cov0" title="0">if err := tx.Model(&amp;User{}).Where("id = ?", topUp.UserId).Update("quota", gorm.Expr("quota + ?", quotaToAdd)).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">userId = topUp.UserId
                payMoney = topUp.Money
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 事务外记录日志，避免阻塞
        <span class="cov0" title="0">RecordLog(userId, LogTypeTopup, fmt.Sprintf("管理员补单成功，充值金额: %v，支付金额：%f", logger.FormatQuota(quotaToAdd), payMoney))
        return nil</span>
}
func RechargeCreem(referenceId string, customerEmail string, customerName string) (err error) <span class="cov0" title="0">{
        if referenceId == "" </span><span class="cov0" title="0">{
                return errors.New("未提供支付单号")
        }</span>

        <span class="cov0" title="0">var quota int64
        topUp := &amp;TopUp{}

        refCol := "`trade_no`"
        if common.UsingPostgreSQL </span><span class="cov0" title="0">{
                refCol = `"trade_no"`
        }</span>

        <span class="cov0" title="0">err = DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                err := tx.Set("gorm:query_option", "FOR UPDATE").Where(refCol+" = ?", referenceId).First(topUp).Error
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("充值订单不存在")
                }</span>

                <span class="cov0" title="0">if topUp.Status != common.TopUpStatusPending </span><span class="cov0" title="0">{
                        return errors.New("充值订单状态错误")
                }</span>

                <span class="cov0" title="0">topUp.CompleteTime = common.GetTimestamp()
                topUp.Status = common.TopUpStatusSuccess
                err = tx.Save(topUp).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Creem 直接使用 Amount 作为充值额度（整数）
                <span class="cov0" title="0">quota = topUp.Amount

                // 构建更新字段，优先使用邮箱，如果邮箱为空则使用用户名
                updateFields := map[string]interface{}{
                        "quota": gorm.Expr("quota + ?", quota),
                }

                // 如果有客户邮箱，尝试更新用户邮箱（仅当用户邮箱为空时）
                if customerEmail != "" </span><span class="cov0" title="0">{
                        // 先检查用户当前邮箱是否为空
                        var user User
                        err = tx.Where("id = ?", topUp.UserId).First(&amp;user).Error
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // 如果用户邮箱为空，则更新为支付时使用的邮箱
                        <span class="cov0" title="0">if user.Email == "" </span><span class="cov0" title="0">{
                                updateFields["email"] = customerEmail
                        }</span>
                }

                <span class="cov0" title="0">err = tx.Model(&amp;User{}).Where("id = ?", topUp.UserId).Updates(updateFields).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.New("充值失败，" + err.Error())
        }</span>

        <span class="cov0" title="0">RecordLog(topUp.UserId, LogTypeTopup, fmt.Sprintf("使用Creem充值成功，充值额度: %v，支付金额：%.2f", quota, topUp.Money))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package model

import (
        "errors"
        "fmt"
        "time"

        "github.com/QuantumNous/new-api/common"

        "gorm.io/gorm"
)

var ErrTwoFANotEnabled = errors.New("用户未启用2FA")

// TwoFA 用户2FA设置表
type TwoFA struct {
        Id             int            `json:"id" gorm:"primaryKey"`
        UserId         int            `json:"user_id" gorm:"unique;not null;index"`
        Secret         string         `json:"-" gorm:"type:varchar(255);not null"` // TOTP密钥，不返回给前端
        IsEnabled      bool           `json:"is_enabled"`
        FailedAttempts int            `json:"failed_attempts" gorm:"default:0"`
        LockedUntil    *time.Time     `json:"locked_until,omitempty"`
        LastUsedAt     *time.Time     `json:"last_used_at,omitempty"`
        CreatedAt      time.Time      `json:"created_at"`
        UpdatedAt      time.Time      `json:"updated_at"`
        DeletedAt      gorm.DeletedAt `json:"-" gorm:"index"`
}

// TwoFABackupCode 备用码使用记录表
type TwoFABackupCode struct {
        Id        int            `json:"id" gorm:"primaryKey"`
        UserId    int            `json:"user_id" gorm:"not null;index"`
        CodeHash  string         `json:"-" gorm:"type:varchar(255);not null"` // 备用码哈希
        IsUsed    bool           `json:"is_used"`
        UsedAt    *time.Time     `json:"used_at,omitempty"`
        CreatedAt time.Time      `json:"created_at"`
        DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
}

// GetTwoFAByUserId 根据用户ID获取2FA设置
func GetTwoFAByUserId(userId int) (*TwoFA, error) <span class="cov0" title="0">{
        if userId == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("用户ID不能为空")
        }</span>

        <span class="cov0" title="0">var twoFA TwoFA
        err := DB.Where("user_id = ?", userId).First(&amp;twoFA).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil // 返回nil表示未设置2FA
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;twoFA, nil</span>
}

// IsTwoFAEnabled 检查用户是否启用了2FA
func IsTwoFAEnabled(userId int) bool <span class="cov0" title="0">{
        twoFA, err := GetTwoFAByUserId(userId)
        if err != nil || twoFA == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return twoFA.IsEnabled</span>
}

// CreateTwoFA 创建2FA设置
func (t *TwoFA) Create() error <span class="cov0" title="0">{
        // 检查用户是否已存在2FA设置
        existing, err := GetTwoFAByUserId(t.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return errors.New("用户已存在2FA设置")
        }</span>

        // 验证用户存在
        <span class="cov0" title="0">var user User
        if err := DB.First(&amp;user, t.UserId).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return errors.New("用户不存在")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return DB.Create(t).Error</span>
}

// Update 更新2FA设置
func (t *TwoFA) Update() error <span class="cov0" title="0">{
        if t.Id == 0 </span><span class="cov0" title="0">{
                return errors.New("2FA记录ID不能为空")
        }</span>
        <span class="cov0" title="0">return DB.Save(t).Error</span>
}

// Delete 删除2FA设置
func (t *TwoFA) Delete() error <span class="cov0" title="0">{
        if t.Id == 0 </span><span class="cov0" title="0">{
                return errors.New("2FA记录ID不能为空")
        }</span>

        // 使用事务确保原子性
        <span class="cov0" title="0">return DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // 同时删除相关的备用码记录（硬删除）
                if err := tx.Unscoped().Where("user_id = ?", t.UserId).Delete(&amp;TwoFABackupCode{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 硬删除2FA记录
                <span class="cov0" title="0">return tx.Unscoped().Delete(t).Error</span>
        })
}

// ResetFailedAttempts 重置失败尝试次数
func (t *TwoFA) ResetFailedAttempts() error <span class="cov0" title="0">{
        t.FailedAttempts = 0
        t.LockedUntil = nil
        return t.Update()
}</span>

// IncrementFailedAttempts 增加失败尝试次数
func (t *TwoFA) IncrementFailedAttempts() error <span class="cov0" title="0">{
        t.FailedAttempts++

        // 检查是否需要锁定
        if t.FailedAttempts &gt;= common.MaxFailAttempts </span><span class="cov0" title="0">{
                lockUntil := time.Now().Add(time.Duration(common.LockoutDuration) * time.Second)
                t.LockedUntil = &amp;lockUntil
        }</span>

        <span class="cov0" title="0">return t.Update()</span>
}

// IsLocked 检查账户是否被锁定
func (t *TwoFA) IsLocked() bool <span class="cov0" title="0">{
        if t.LockedUntil == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Now().Before(*t.LockedUntil)</span>
}

// CreateBackupCodes 创建备用码
func CreateBackupCodes(userId int, codes []string) error <span class="cov0" title="0">{
        return DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // 先删除现有的备用码
                if err := tx.Where("user_id = ?", userId).Delete(&amp;TwoFABackupCode{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 创建新的备用码记录
                <span class="cov0" title="0">for _, code := range codes </span><span class="cov0" title="0">{
                        hashedCode, err := common.HashBackupCode(code)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">backupCode := TwoFABackupCode{
                                UserId:   userId,
                                CodeHash: hashedCode,
                                IsUsed:   false,
                        }

                        if err := tx.Create(&amp;backupCode).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// ValidateBackupCode 验证并使用备用码
func ValidateBackupCode(userId int, code string) (bool, error) <span class="cov0" title="0">{
        if !common.ValidateBackupCode(code) </span><span class="cov0" title="0">{
                return false, errors.New("验证码或备用码不正确")
        }</span>

        <span class="cov0" title="0">normalizedCode := common.NormalizeBackupCode(code)

        // 查找未使用的备用码
        var backupCodes []TwoFABackupCode
        if err := DB.Where("user_id = ? AND is_used = false", userId).Find(&amp;backupCodes).Error; err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // 验证备用码
        <span class="cov0" title="0">for _, bc := range backupCodes </span><span class="cov0" title="0">{
                if common.ValidatePasswordAndHash(normalizedCode, bc.CodeHash) </span><span class="cov0" title="0">{
                        // 标记为已使用
                        now := time.Now()
                        bc.IsUsed = true
                        bc.UsedAt = &amp;now

                        if err := DB.Save(&amp;bc).Error; err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>

                        <span class="cov0" title="0">return true, nil</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}

// GetUnusedBackupCodeCount 获取未使用的备用码数量
func GetUnusedBackupCodeCount(userId int) (int, error) <span class="cov0" title="0">{
        var count int64
        err := DB.Model(&amp;TwoFABackupCode{}).Where("user_id = ? AND is_used = false", userId).Count(&amp;count).Error
        return int(count), err
}</span>

// DisableTwoFA 禁用用户的2FA
func DisableTwoFA(userId int) error <span class="cov0" title="0">{
        twoFA, err := GetTwoFAByUserId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if twoFA == nil </span><span class="cov0" title="0">{
                return ErrTwoFANotEnabled
        }</span>

        // 删除2FA设置和备用码
        <span class="cov0" title="0">return twoFA.Delete()</span>
}

// EnableTwoFA 启用2FA
func (t *TwoFA) Enable() error <span class="cov0" title="0">{
        t.IsEnabled = true
        t.FailedAttempts = 0
        t.LockedUntil = nil
        return t.Update()
}</span>

// ValidateTOTPAndUpdateUsage 验证TOTP并更新使用记录
func (t *TwoFA) ValidateTOTPAndUpdateUsage(code string) (bool, error) <span class="cov0" title="0">{
        // 检查是否被锁定
        if t.IsLocked() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("账户已被锁定，请在%v后重试", t.LockedUntil.Format("2006-01-02 15:04:05"))
        }</span>

        // 验证TOTP码
        <span class="cov0" title="0">if !common.ValidateTOTPCode(t.Secret, code) </span><span class="cov0" title="0">{
                // 增加失败次数
                if err := t.IncrementFailedAttempts(); err != nil </span><span class="cov0" title="0">{
                        common.SysLog("更新2FA失败次数失败: " + err.Error())
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        // 验证成功，重置失败次数并更新最后使用时间
        <span class="cov0" title="0">now := time.Now()
        t.FailedAttempts = 0
        t.LockedUntil = nil
        t.LastUsedAt = &amp;now

        if err := t.Update(); err != nil </span><span class="cov0" title="0">{
                common.SysLog("更新2FA使用记录失败: " + err.Error())
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// ValidateBackupCodeAndUpdateUsage 验证备用码并更新使用记录
func (t *TwoFA) ValidateBackupCodeAndUpdateUsage(code string) (bool, error) <span class="cov0" title="0">{
        // 检查是否被锁定
        if t.IsLocked() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("账户已被锁定，请在%v后重试", t.LockedUntil.Format("2006-01-02 15:04:05"))
        }</span>

        // 验证备用码
        <span class="cov0" title="0">valid, err := ValidateBackupCode(t.UserId, code)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                // 增加失败次数
                if err := t.IncrementFailedAttempts(); err != nil </span><span class="cov0" title="0">{
                        common.SysLog("更新2FA失败次数失败: " + err.Error())
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        // 验证成功，重置失败次数并更新最后使用时间
        <span class="cov0" title="0">now := time.Now()
        t.FailedAttempts = 0
        t.LockedUntil = nil
        t.LastUsedAt = &amp;now

        if err := t.Update(); err != nil </span><span class="cov0" title="0">{
                common.SysLog("更新2FA使用记录失败: " + err.Error())
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// GetTwoFAStats 获取2FA统计信息（管理员使用）
func GetTwoFAStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        var totalUsers, enabledUsers int64

        // 总用户数
        if err := DB.Model(&amp;User{}).Count(&amp;totalUsers).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 启用2FA的用户数
        <span class="cov0" title="0">if err := DB.Model(&amp;TwoFA{}).Where("is_enabled = true").Count(&amp;enabledUsers).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">enabledRate := float64(0)
        if totalUsers &gt; 0 </span><span class="cov0" title="0">{
                enabledRate = float64(enabledUsers) / float64(totalUsers) * 100
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_users":   totalUsers,
                "enabled_users": enabledUsers,
                "enabled_rate":  fmt.Sprintf("%.1f%%", enabledRate),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package model

import (
        "fmt"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "gorm.io/gorm"
)

// QuotaData 柱状图数据
type QuotaData struct {
        Id        int    `json:"id"`
        UserID    int    `json:"user_id" gorm:"index"`
        Username  string `json:"username" gorm:"index:idx_qdt_model_user_name,priority:2;size:64;default:''"`
        ModelName string `json:"model_name" gorm:"index:idx_qdt_model_user_name,priority:1;size:64;default:''"`
        CreatedAt int64  `json:"created_at" gorm:"bigint;index:idx_qdt_created_at,priority:2"`
        TokenUsed int    `json:"token_used" gorm:"default:0"`
        Count     int    `json:"count" gorm:"default:0"`
        Quota     int    `json:"quota" gorm:"default:0"`
}

func UpdateQuotaData() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if common.DataExportEnabled </span><span class="cov0" title="0">{
                        common.SysLog("正在更新数据看板数据...")
                        SaveQuotaDataCache()
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Duration(common.DataExportInterval) * time.Minute)</span>
        }
}

var CacheQuotaData = make(map[string]*QuotaData)
var CacheQuotaDataLock = sync.Mutex{}

func logQuotaDataCache(userId int, username string, modelName string, quota int, createdAt int64, tokenUsed int) <span class="cov0" title="0">{
        key := fmt.Sprintf("%d-%s-%s-%d", userId, username, modelName, createdAt)
        quotaData, ok := CacheQuotaData[key]
        if ok </span><span class="cov0" title="0">{
                quotaData.Count += 1
                quotaData.Quota += quota
                quotaData.TokenUsed += tokenUsed
        }</span> else<span class="cov0" title="0"> {
                quotaData = &amp;QuotaData{
                        UserID:    userId,
                        Username:  username,
                        ModelName: modelName,
                        CreatedAt: createdAt,
                        Count:     1,
                        Quota:     quota,
                        TokenUsed: tokenUsed,
                }
        }</span>
        <span class="cov0" title="0">CacheQuotaData[key] = quotaData</span>
}

func LogQuotaData(userId int, username string, modelName string, quota int, createdAt int64, tokenUsed int) <span class="cov0" title="0">{
        // 只精确到小时
        createdAt = createdAt - (createdAt % 3600)

        CacheQuotaDataLock.Lock()
        defer CacheQuotaDataLock.Unlock()
        logQuotaDataCache(userId, username, modelName, quota, createdAt, tokenUsed)
}</span>

func SaveQuotaDataCache() <span class="cov0" title="0">{
        CacheQuotaDataLock.Lock()
        defer CacheQuotaDataLock.Unlock()
        size := len(CacheQuotaData)
        // 如果缓存中有数据，就保存到数据库中
        // 1. 先查询数据库中是否有数据
        // 2. 如果有数据，就更新数据
        // 3. 如果没有数据，就插入数据
        for _, quotaData := range CacheQuotaData </span><span class="cov0" title="0">{
                quotaDataDB := &amp;QuotaData{}
                DB.Table("quota_data").Where("user_id = ? and username = ? and model_name = ? and created_at = ?",
                        quotaData.UserID, quotaData.Username, quotaData.ModelName, quotaData.CreatedAt).First(quotaDataDB)
                if quotaDataDB.Id &gt; 0 </span><span class="cov0" title="0">{
                        //quotaDataDB.Count += quotaData.Count
                        //quotaDataDB.Quota += quotaData.Quota
                        //DB.Table("quota_data").Save(quotaDataDB)
                        increaseQuotaData(quotaData.UserID, quotaData.Username, quotaData.ModelName, quotaData.Count, quotaData.Quota, quotaData.CreatedAt, quotaData.TokenUsed)
                }</span> else<span class="cov0" title="0"> {
                        DB.Table("quota_data").Create(quotaData)
                }</span>
        }
        <span class="cov0" title="0">CacheQuotaData = make(map[string]*QuotaData)
        common.SysLog(fmt.Sprintf("保存数据看板数据成功，共保存%d条数据", size))</span>
}

func increaseQuotaData(userId int, username string, modelName string, count int, quota int, createdAt int64, tokenUsed int) <span class="cov0" title="0">{
        err := DB.Table("quota_data").Where("user_id = ? and username = ? and model_name = ? and created_at = ?",
                userId, username, modelName, createdAt).Updates(map[string]interface{}{
                "count":      gorm.Expr("count + ?", count),
                "quota":      gorm.Expr("quota + ?", quota),
                "token_used": gorm.Expr("token_used + ?", tokenUsed),
        }).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("increaseQuotaData error: %s", err))
        }</span>
}

func GetQuotaDataByUsername(username string, startTime int64, endTime int64) (quotaData []*QuotaData, err error) <span class="cov0" title="0">{
        var quotaDatas []*QuotaData
        // 从quota_data表中查询数据
        err = DB.Table("quota_data").Where("username = ? and created_at &gt;= ? and created_at &lt;= ?", username, startTime, endTime).Find(&amp;quotaDatas).Error
        return quotaDatas, err
}</span>

func GetQuotaDataByUserId(userId int, startTime int64, endTime int64) (quotaData []*QuotaData, err error) <span class="cov0" title="0">{
        var quotaDatas []*QuotaData
        // 从quota_data表中查询数据
        err = DB.Table("quota_data").Where("user_id = ? and created_at &gt;= ? and created_at &lt;= ?", userId, startTime, endTime).Find(&amp;quotaDatas).Error
        return quotaDatas, err
}</span>

func GetAllQuotaDates(startTime int64, endTime int64, username string) (quotaData []*QuotaData, err error) <span class="cov0" title="0">{
        if username != "" </span><span class="cov0" title="0">{
                return GetQuotaDataByUsername(username, startTime, endTime)
        }</span>
        <span class="cov0" title="0">var quotaDatas []*QuotaData
        // 从quota_data表中查询数据
        // only select model_name, sum(count) as count, sum(quota) as quota, model_name, created_at from quota_data group by model_name, created_at;
        //err = DB.Table("quota_data").Where("created_at &gt;= ? and created_at &lt;= ?", startTime, endTime).Find(&amp;quotaDatas).Error
        err = DB.Table("quota_data").Select("model_name, sum(count) as count, sum(quota) as quota, sum(token_used) as token_used, created_at").Where("created_at &gt;= ? and created_at &lt;= ?", startTime, endTime).Group("model_name, created_at").Find(&amp;quotaDatas).Error
        return quotaDatas, err</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"

        "github.com/bytedance/gopkg/util/gopool"
        "gorm.io/gorm"
)

// User if you add sensitive fields, don't forget to clean them in setupLogin function.
// Otherwise, the sensitive information will be saved on local storage in plain text!
type User struct {
        Id               int            `json:"id"`
        Username         string         `json:"username" gorm:"unique;index" validate:"max=20"`
        Password         string         `json:"password" gorm:"not null;" validate:"min=8,max=20"`
        OriginalPassword string         `json:"original_password" gorm:"-:all"` // this field is only for Password change verification, don't save it to database!
        DisplayName      string         `json:"display_name" gorm:"index" validate:"max=20"`
        Role             int            `json:"role" gorm:"type:int;default:1"`   // admin, common
        Status           int            `json:"status" gorm:"type:int;default:1"` // enabled, disabled
        Email            string         `json:"email" gorm:"index" validate:"max=50"`
        GitHubId         string         `json:"github_id" gorm:"column:github_id;index"`
        DiscordId        string         `json:"discord_id" gorm:"column:discord_id;index"`
        OidcId           string         `json:"oidc_id" gorm:"column:oidc_id;index"`
        WeChatId         string         `json:"wechat_id" gorm:"column:wechat_id;index"`
        TelegramId       string         `json:"telegram_id" gorm:"column:telegram_id;index"`
        VerificationCode string         `json:"verification_code" gorm:"-:all"`                                    // this field is only for Email verification, don't save it to database!
        AccessToken      *string        `json:"access_token" gorm:"type:char(32);column:access_token;uniqueIndex"` // this token is for system management
        Quota            int            `json:"quota" gorm:"type:int;default:0"`
        UsedQuota        int            `json:"used_quota" gorm:"type:int;default:0;column:used_quota"` // used quota
        RequestCount     int            `json:"request_count" gorm:"type:int;default:0;"`               // request number
        Group            string         `json:"group" gorm:"type:varchar(64);default:'default'"`
        AffCode          string         `json:"aff_code" gorm:"type:varchar(32);column:aff_code;uniqueIndex"`
        AffCount         int            `json:"aff_count" gorm:"type:int;default:0;column:aff_count"`
        AffQuota         int            `json:"aff_quota" gorm:"type:int;default:0;column:aff_quota"`           // 邀请剩余额度
        AffHistoryQuota  int            `json:"aff_history_quota" gorm:"type:int;default:0;column:aff_history"` // 邀请历史额度
        InviterId        int            `json:"inviter_id" gorm:"type:int;column:inviter_id;index"`
        DeletedAt        gorm.DeletedAt `gorm:"index"`
        LinuxDOId        string         `json:"linux_do_id" gorm:"column:linux_do_id;index"`
        Setting          string         `json:"setting" gorm:"type:text;column:setting"`
        Remark           string         `json:"remark,omitempty" gorm:"type:varchar(255)" validate:"max=255"`
        StripeCustomer   string         `json:"stripe_customer" gorm:"type:varchar(64);column:stripe_customer;index"`
}

func (user *User) ToBaseUser() *UserBase <span class="cov0" title="0">{
        cache := &amp;UserBase{
                Id:       user.Id,
                Group:    user.Group,
                Quota:    user.Quota,
                Status:   user.Status,
                Username: user.Username,
                Setting:  user.Setting,
                Email:    user.Email,
        }
        return cache
}</span>

func (user *User) GetAccessToken() string <span class="cov0" title="0">{
        if user.AccessToken == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *user.AccessToken</span>
}

func (user *User) SetAccessToken(token string) <span class="cov0" title="0">{
        user.AccessToken = &amp;token
}</span>

func (user *User) GetSetting() dto.UserSetting <span class="cov0" title="0">{
        setting := dto.UserSetting{}
        if user.Setting != "" </span><span class="cov0" title="0">{
                err := json.Unmarshal([]byte(user.Setting), &amp;setting)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("failed to unmarshal setting: " + err.Error())
                }</span>
        }
        <span class="cov0" title="0">return setting</span>
}

func (user *User) SetSetting(setting dto.UserSetting) <span class="cov0" title="0">{
        settingBytes, err := json.Marshal(setting)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("failed to marshal setting: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">user.Setting = string(settingBytes)</span>
}

// 根据用户角色生成默认的边栏配置
func generateDefaultSidebarConfigForRole(userRole int) string <span class="cov0" title="0">{
        defaultConfig := map[string]interface{}{}

        // 聊天区域 - 所有用户都可以访问
        defaultConfig["chat"] = map[string]interface{}{
                "enabled":    true,
                "playground": true,
                "chat":       true,
        }

        // 控制台区域 - 所有用户都可以访问
        defaultConfig["console"] = map[string]interface{}{
                "enabled":    true,
                "detail":     true,
                "token":      true,
                "log":        true,
                "midjourney": true,
                "task":       true,
        }

        // 个人中心区域 - 所有用户都可以访问
        defaultConfig["personal"] = map[string]interface{}{
                "enabled":  true,
                "topup":    true,
                "personal": true,
        }

        // 管理员区域 - 根据角色决定
        if userRole == common.RoleAdminUser </span><span class="cov0" title="0">{
                // 管理员可以访问管理员区域，但不能访问系统设置
                defaultConfig["admin"] = map[string]interface{}{
                        "enabled":    true,
                        "channel":    true,
                        "models":     true,
                        "redemption": true,
                        "user":       true,
                        "setting":    false, // 管理员不能访问系统设置
                }
        }</span> else<span class="cov0" title="0"> if userRole == common.RoleRootUser </span><span class="cov0" title="0">{
                // 超级管理员可以访问所有功能
                defaultConfig["admin"] = map[string]interface{}{
                        "enabled":    true,
                        "channel":    true,
                        "models":     true,
                        "redemption": true,
                        "user":       true,
                        "setting":    true,
                }
        }</span>
        // 普通用户不包含admin区域

        // 转换为JSON字符串
        <span class="cov0" title="0">configBytes, err := json.Marshal(defaultConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("生成默认边栏配置失败: " + err.Error())
                return ""
        }</span>

        <span class="cov0" title="0">return string(configBytes)</span>
}

// CheckUserExistOrDeleted check if user exist or deleted, if not exist, return false, nil, if deleted or exist, return true, nil
func CheckUserExistOrDeleted(username string, email string) (bool, error) <span class="cov0" title="0">{
        var user User

        // err := DB.Unscoped().First(&amp;user, "username = ? or email = ?", username, email).Error
        // check email if empty
        var err error
        if email == "" </span><span class="cov0" title="0">{
                err = DB.Unscoped().First(&amp;user, "username = ?", username).Error
        }</span> else<span class="cov0" title="0"> {
                err = DB.Unscoped().First(&amp;user, "username = ? or email = ?", username, email).Error
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        // not exist, return false, nil
                        return false, nil
                }</span>
                // other error, return false, err
                <span class="cov0" title="0">return false, err</span>
        }
        // exist, return true, nil
        <span class="cov0" title="0">return true, nil</span>
}

func GetMaxUserId() int <span class="cov0" title="0">{
        var user User
        DB.Unscoped().Last(&amp;user)
        return user.Id
}</span>

func GetAllUsers(pageInfo *common.PageInfo) (users []*User, total int64, err error) <span class="cov0" title="0">{
        // Start transaction
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Get total count within transaction
        <span class="cov0" title="0">err = tx.Unscoped().Model(&amp;User{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // Get paginated users within same transaction
        <span class="cov0" title="0">err = tx.Unscoped().Order("id desc").Limit(pageInfo.GetPageSize()).Offset(pageInfo.GetStartIdx()).Omit("password").Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

func SearchUsers(keyword string, group string, startIdx int, num int) ([]*User, int64, error) <span class="cov0" title="0">{
        var users []*User
        var total int64
        var err error

        // 开始事务
        tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, 0, tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // 构建基础查询
        <span class="cov0" title="0">query := tx.Unscoped().Model(&amp;User{})

        // 构建搜索条件
        likeCondition := "username LIKE ? OR email LIKE ? OR display_name LIKE ?"

        // 尝试将关键字转换为整数ID
        keywordInt, err := strconv.Atoi(keyword)
        if err == nil </span><span class="cov0" title="0">{
                // 如果是数字，同时搜索ID和其他字段
                likeCondition = "id = ? OR " + likeCondition
                if group != "" </span><span class="cov0" title="0">{
                        query = query.Where("("+likeCondition+") AND "+commonGroupCol+" = ?",
                                keywordInt, "%"+keyword+"%", "%"+keyword+"%", "%"+keyword+"%", group)
                }</span> else<span class="cov0" title="0"> {
                        query = query.Where(likeCondition,
                                keywordInt, "%"+keyword+"%", "%"+keyword+"%", "%"+keyword+"%")
                }</span>
        } else<span class="cov0" title="0"> {
                // 非数字关键字，只搜索字符串字段
                if group != "" </span><span class="cov0" title="0">{
                        query = query.Where("("+likeCondition+") AND "+commonGroupCol+" = ?",
                                "%"+keyword+"%", "%"+keyword+"%", "%"+keyword+"%", group)
                }</span> else<span class="cov0" title="0"> {
                        query = query.Where(likeCondition,
                                "%"+keyword+"%", "%"+keyword+"%", "%"+keyword+"%")
                }</span>
        }

        // 获取总数
        <span class="cov0" title="0">err = query.Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // 获取分页数据
        <span class="cov0" title="0">err = query.Omit("password").Order("id desc").Limit(num).Offset(startIdx).Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, err
        }</span>

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

func GetUserById(id int, selectAll bool) (*User, error) <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">user := User{Id: id}
        var err error = nil
        if selectAll </span><span class="cov0" title="0">{
                err = DB.First(&amp;user, "id = ?", id).Error
        }</span> else<span class="cov0" title="0"> {
                err = DB.Omit("password").First(&amp;user, "id = ?", id).Error
        }</span>
        <span class="cov0" title="0">return &amp;user, err</span>
}

func GetUserIdByAffCode(affCode string) (int, error) <span class="cov0" title="0">{
        if affCode == "" </span><span class="cov0" title="0">{
                return 0, errors.New("affCode 为空！")
        }</span>
        <span class="cov0" title="0">var user User
        err := DB.Select("id").First(&amp;user, "aff_code = ?", affCode).Error
        return user.Id, err</span>
}

func DeleteUserById(id int) (err error) <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">user := User{Id: id}
        return user.Delete()</span>
}

func HardDeleteUserById(id int) error <span class="cov0" title="0">{
        if id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">err := DB.Unscoped().Delete(&amp;User{}, "id = ?", id).Error
        return err</span>
}

func inviteUser(inviterId int) (err error) <span class="cov0" title="0">{
        user, err := GetUserById(inviterId, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user.AffCount++
        user.AffQuota += common.QuotaForInviter
        user.AffHistoryQuota += common.QuotaForInviter
        return DB.Save(user).Error</span>
}

func (user *User) TransferAffQuotaToQuota(quota int) error <span class="cov0" title="0">{
        // 检查quota是否小于最小额度
        if float64(quota) &lt; common.QuotaPerUnit </span><span class="cov0" title="0">{
                return fmt.Errorf("转移额度最小为%s！", logger.LogQuota(int(common.QuotaPerUnit)))
        }</span>

        // 开始数据库事务
        <span class="cov0" title="0">tx := DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">defer tx.Rollback() // 确保在函数退出时事务能回滚

        // 加锁查询用户以确保数据一致性
        err := tx.Set("gorm:query_option", "FOR UPDATE").First(&amp;user, user.Id).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 再次检查用户的AffQuota是否足够
        <span class="cov0" title="0">if user.AffQuota &lt; quota </span><span class="cov0" title="0">{
                return errors.New("邀请额度不足！")
        }</span>

        // 更新用户额度
        <span class="cov0" title="0">user.AffQuota -= quota
        user.Quota += quota

        // 保存用户状态
        if err := tx.Save(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 提交事务
        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (user *User) Insert(inviterId int) error <span class="cov0" title="0">{
        var err error
        if user.Password != "" </span><span class="cov0" title="0">{
                user.Password, err = common.Password2Hash(user.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">user.Quota = common.QuotaForNewUser
        //user.SetAccessToken(common.GetUUID())
        user.AffCode = common.GetRandomString(4)

        // 初始化用户设置，包括默认的边栏配置
        if user.Setting == "" </span><span class="cov0" title="0">{
                defaultSetting := dto.UserSetting{}
                // 这里暂时不设置SidebarModules，因为需要在用户创建后根据角色设置
                user.SetSetting(defaultSetting)
        }</span>

        <span class="cov0" title="0">result := DB.Create(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        // 用户创建成功后，根据角色初始化边栏配置
        // 需要重新获取用户以确保有正确的ID和Role
        <span class="cov0" title="0">var createdUser User
        if err := DB.Where("username = ?", user.Username).First(&amp;createdUser).Error; err == nil </span><span class="cov0" title="0">{
                // 生成基于角色的默认边栏配置
                defaultSidebarConfig := generateDefaultSidebarConfigForRole(createdUser.Role)
                if defaultSidebarConfig != "" </span><span class="cov0" title="0">{
                        currentSetting := createdUser.GetSetting()
                        currentSetting.SidebarModules = defaultSidebarConfig
                        createdUser.SetSetting(currentSetting)
                        createdUser.Update(false)
                        common.SysLog(fmt.Sprintf("为新用户 %s (角色: %d) 初始化边栏配置", createdUser.Username, createdUser.Role))
                }</span>
        }

        <span class="cov0" title="0">if common.QuotaForNewUser &gt; 0 </span><span class="cov0" title="0">{
                RecordLog(user.Id, LogTypeSystem, fmt.Sprintf("新用户注册赠送 %s", logger.LogQuota(common.QuotaForNewUser)))
        }</span>
        <span class="cov0" title="0">if inviterId != 0 </span><span class="cov0" title="0">{
                if common.QuotaForInvitee &gt; 0 </span><span class="cov0" title="0">{
                        _ = IncreaseUserQuota(user.Id, common.QuotaForInvitee, true)
                        RecordLog(user.Id, LogTypeSystem, fmt.Sprintf("使用邀请码赠送 %s", logger.LogQuota(common.QuotaForInvitee)))
                }</span>
                <span class="cov0" title="0">if common.QuotaForInviter &gt; 0 </span><span class="cov0" title="0">{
                        //_ = IncreaseUserQuota(inviterId, common.QuotaForInviter)
                        RecordLog(inviterId, LogTypeSystem, fmt.Sprintf("邀请用户赠送 %s", logger.LogQuota(common.QuotaForInviter)))
                        _ = inviteUser(inviterId)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (user *User) Update(updatePassword bool) error <span class="cov0" title="0">{
        var err error
        if updatePassword </span><span class="cov0" title="0">{
                user.Password, err = common.Password2Hash(user.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">newUser := *user
        DB.First(&amp;user, user.Id)
        if err = DB.Model(user).Updates(newUser).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update cache
        <span class="cov0" title="0">return updateUserCache(*user)</span>
}

func (user *User) Edit(updatePassword bool) error <span class="cov0" title="0">{
        var err error
        if updatePassword </span><span class="cov0" title="0">{
                user.Password, err = common.Password2Hash(user.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">newUser := *user
        updates := map[string]interface{}{
                "username":     newUser.Username,
                "display_name": newUser.DisplayName,
                "group":        newUser.Group,
                "quota":        newUser.Quota,
                "remark":       newUser.Remark,
        }
        if updatePassword </span><span class="cov0" title="0">{
                updates["password"] = newUser.Password
        }</span>

        <span class="cov0" title="0">DB.First(&amp;user, user.Id)
        if err = DB.Model(user).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update cache
        <span class="cov0" title="0">return updateUserCache(*user)</span>
}

func (user *User) Delete() error <span class="cov0" title="0">{
        if user.Id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">if err := DB.Delete(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov0" title="0">return invalidateUserCache(user.Id)</span>
}

func (user *User) HardDelete() error <span class="cov0" title="0">{
        if user.Id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">err := DB.Unscoped().Delete(user).Error
        return err</span>
}

// ValidateAndFill check password &amp; user status
func (user *User) ValidateAndFill() (err error) <span class="cov0" title="0">{
        // When querying with struct, GORM will only query with non-zero fields,
        // that means if your field's value is 0, '', false or other zero values,
        // it won't be used to build query conditions
        password := user.Password
        username := strings.TrimSpace(user.Username)
        if username == "" || password == "" </span><span class="cov0" title="0">{
                return errors.New("用户名或密码为空")
        }</span>
        // find buy username or email
        <span class="cov0" title="0">DB.Where("username = ? OR email = ?", username, username).First(user)
        okay := common.ValidatePasswordAndHash(password, user.Password)
        if !okay || user.Status != common.UserStatusEnabled </span><span class="cov0" title="0">{
                return errors.New("用户名或密码错误，或用户已被封禁")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (user *User) FillUserById() error <span class="cov0" title="0">{
        if user.Id == 0 </span><span class="cov0" title="0">{
                return errors.New("id 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{Id: user.Id}).First(user)
        return nil</span>
}

func (user *User) FillUserByEmail() error <span class="cov0" title="0">{
        if user.Email == "" </span><span class="cov0" title="0">{
                return errors.New("email 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{Email: user.Email}).First(user)
        return nil</span>
}

func (user *User) FillUserByGitHubId() error <span class="cov0" title="0">{
        if user.GitHubId == "" </span><span class="cov0" title="0">{
                return errors.New("GitHub id 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{GitHubId: user.GitHubId}).First(user)
        return nil</span>
}

func (user *User) FillUserByDiscordId() error <span class="cov0" title="0">{
        if user.DiscordId == "" </span><span class="cov0" title="0">{
                return errors.New("discord id 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{DiscordId: user.DiscordId}).First(user)
        return nil</span>
}

func (user *User) FillUserByOidcId() error <span class="cov0" title="0">{
        if user.OidcId == "" </span><span class="cov0" title="0">{
                return errors.New("oidc id 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{OidcId: user.OidcId}).First(user)
        return nil</span>
}

func (user *User) FillUserByWeChatId() error <span class="cov0" title="0">{
        if user.WeChatId == "" </span><span class="cov0" title="0">{
                return errors.New("WeChat id 为空！")
        }</span>
        <span class="cov0" title="0">DB.Where(User{WeChatId: user.WeChatId}).First(user)
        return nil</span>
}

func (user *User) FillUserByTelegramId() error <span class="cov0" title="0">{
        if user.TelegramId == "" </span><span class="cov0" title="0">{
                return errors.New("Telegram id 为空！")
        }</span>
        <span class="cov0" title="0">err := DB.Where(User{TelegramId: user.TelegramId}).First(user).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return errors.New("该 Telegram 账户未绑定")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func IsEmailAlreadyTaken(email string) bool <span class="cov0" title="0">{
        return DB.Unscoped().Where("email = ?", email).Find(&amp;User{}).RowsAffected == 1
}</span>

func IsWeChatIdAlreadyTaken(wechatId string) bool <span class="cov0" title="0">{
        return DB.Unscoped().Where("wechat_id = ?", wechatId).Find(&amp;User{}).RowsAffected == 1
}</span>

func IsGitHubIdAlreadyTaken(githubId string) bool <span class="cov0" title="0">{
        return DB.Unscoped().Where("github_id = ?", githubId).Find(&amp;User{}).RowsAffected == 1
}</span>

func IsDiscordIdAlreadyTaken(discordId string) bool <span class="cov0" title="0">{
        return DB.Unscoped().Where("discord_id = ?", discordId).Find(&amp;User{}).RowsAffected == 1
}</span>

func IsOidcIdAlreadyTaken(oidcId string) bool <span class="cov0" title="0">{
        return DB.Where("oidc_id = ?", oidcId).Find(&amp;User{}).RowsAffected == 1
}</span>

func IsTelegramIdAlreadyTaken(telegramId string) bool <span class="cov0" title="0">{
        return DB.Unscoped().Where("telegram_id = ?", telegramId).Find(&amp;User{}).RowsAffected == 1
}</span>

func ResetUserPasswordByEmail(email string, password string) error <span class="cov0" title="0">{
        if email == "" || password == "" </span><span class="cov0" title="0">{
                return errors.New("邮箱地址或密码为空！")
        }</span>
        <span class="cov0" title="0">hashedPassword, err := common.Password2Hash(password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = DB.Model(&amp;User{}).Where("email = ?", email).Update("password", hashedPassword).Error
        return err</span>
}

func IsAdmin(userId int) bool <span class="cov0" title="0">{
        if userId == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var user User
        err := DB.Where("id = ?", userId).Select("role").Find(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("no such user " + err.Error())
                return false
        }</span>
        <span class="cov0" title="0">return user.Role &gt;= common.RoleAdminUser</span>
}

//// IsUserEnabled checks user status from Redis first, falls back to DB if needed
//func IsUserEnabled(id int, fromDB bool) (status bool, err error) {
//        defer func() {
//                // Update Redis cache asynchronously on successful DB read
//                if shouldUpdateRedis(fromDB, err) {
//                        gopool.Go(func() {
//                                if err := updateUserStatusCache(id, status); err != nil {
//                                        common.SysError("failed to update user status cache: " + err.Error())
//                                }
//                        })
//                }
//        }()
//        if !fromDB &amp;&amp; common.RedisEnabled {
//                // Try Redis first
//                status, err := getUserStatusCache(id)
//                if err == nil {
//                        return status == common.UserStatusEnabled, nil
//                }
//                // Don't return error - fall through to DB
//        }
//        fromDB = true
//        var user User
//        err = DB.Where("id = ?", id).Select("status").Find(&amp;user).Error
//        if err != nil {
//                return false, err
//        }
//
//        return user.Status == common.UserStatusEnabled, nil
//}

func ValidateAccessToken(token string) (user *User) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">token = strings.Replace(token, "Bearer ", "", 1)
        user = &amp;User{}
        if DB.Where("access_token = ?", token).First(user).RowsAffected == 1 </span><span class="cov0" title="0">{
                return user
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetUserQuota gets quota from Redis first, falls back to DB if needed
func GetUserQuota(id int, fromDB bool) (quota int, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := updateUserQuotaCache(id, quota); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user quota cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">if !fromDB &amp;&amp; common.RedisEnabled </span><span class="cov0" title="0">{
                quota, err := getUserQuotaCache(id)
                if err == nil </span><span class="cov0" title="0">{
                        return quota, nil
                }</span>
                // Don't return error - fall through to DB
        }
        <span class="cov0" title="0">fromDB = true
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select("quota").Find(&amp;quota).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return quota, nil</span>
}

func GetUserUsedQuota(id int) (quota int, err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select("used_quota").Find(&amp;quota).Error
        return quota, err
}</span>

func GetUserEmail(id int) (email string, err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select("email").Find(&amp;email).Error
        return email, err
}</span>

// GetUserGroup gets group from Redis first, falls back to DB if needed
func GetUserGroup(id int, fromDB bool) (group string, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := updateUserGroupCache(id, group); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user group cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">if !fromDB &amp;&amp; common.RedisEnabled </span><span class="cov0" title="0">{
                group, err := getUserGroupCache(id)
                if err == nil </span><span class="cov0" title="0">{
                        return group, nil
                }</span>
                // Don't return error - fall through to DB
        }
        <span class="cov0" title="0">fromDB = true
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select(commonGroupCol).Find(&amp;group).Error
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}

// GetUserSetting gets setting from Redis first, falls back to DB if needed
func GetUserSetting(id int, fromDB bool) (settingMap dto.UserSetting, err error) <span class="cov0" title="0">{
        var setting string
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := updateUserSettingCache(id, setting); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user setting cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">if !fromDB &amp;&amp; common.RedisEnabled </span><span class="cov0" title="0">{
                setting, err := getUserSettingCache(id)
                if err == nil </span><span class="cov0" title="0">{
                        return setting, nil
                }</span>
                // Don't return error - fall through to DB
        }
        <span class="cov0" title="0">fromDB = true
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select("setting").Find(&amp;setting).Error
        if err != nil </span><span class="cov0" title="0">{
                return settingMap, err
        }</span>
        <span class="cov0" title="0">userBase := &amp;UserBase{
                Setting: setting,
        }
        return userBase.GetSetting(), nil</span>
}

func IncreaseUserQuota(id int, quota int, db bool) (err error) <span class="cov0" title="0">{
        if quota &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("quota 不能为负数！")
        }</span>
        <span class="cov0" title="0">gopool.Go(func() </span><span class="cov0" title="0">{
                err := cacheIncrUserQuota(id, int64(quota))
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("failed to increase user quota: " + err.Error())
                }</span>
        })
        <span class="cov0" title="0">if !db &amp;&amp; common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeUserQuota, id, quota)
                return nil
        }</span>
        <span class="cov0" title="0">return increaseUserQuota(id, quota)</span>
}

func increaseUserQuota(id int, quota int) (err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;User{}).Where("id = ?", id).Update("quota", gorm.Expr("quota + ?", quota)).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func DecreaseUserQuota(id int, quota int) (err error) <span class="cov0" title="0">{
        if quota &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("quota 不能为负数！")
        }</span>
        <span class="cov0" title="0">gopool.Go(func() </span><span class="cov0" title="0">{
                err := cacheDecrUserQuota(id, int64(quota))
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("failed to decrease user quota: " + err.Error())
                }</span>
        })
        <span class="cov0" title="0">if common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeUserQuota, id, -quota)
                return nil
        }</span>
        <span class="cov0" title="0">return decreaseUserQuota(id, quota)</span>
}

func decreaseUserQuota(id int, quota int) (err error) <span class="cov0" title="0">{
        err = DB.Model(&amp;User{}).Where("id = ?", id).Update("quota", gorm.Expr("quota - ?", quota)).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func DeltaUpdateUserQuota(id int, delta int) (err error) <span class="cov0" title="0">{
        if delta == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if delta &gt; 0 </span><span class="cov0" title="0">{
                return IncreaseUserQuota(id, delta, false)
        }</span> else<span class="cov0" title="0"> {
                return DecreaseUserQuota(id, -delta)
        }</span>
}

//func GetRootUserEmail() (email string) {
//        DB.Model(&amp;User{}).Where("role = ?", common.RoleRootUser).Select("email").Find(&amp;email)
//        return email
//}

func GetRootUser() (user *User) <span class="cov0" title="0">{
        DB.Where("role = ?", common.RoleRootUser).First(&amp;user)
        return user
}</span>

func UpdateUserUsedQuotaAndRequestCount(id int, quota int) <span class="cov0" title="0">{
        if common.BatchUpdateEnabled </span><span class="cov0" title="0">{
                addNewRecord(BatchUpdateTypeUsedQuota, id, quota)
                addNewRecord(BatchUpdateTypeRequestCount, id, 1)
                return
        }</span>
        <span class="cov0" title="0">updateUserUsedQuotaAndRequestCount(id, quota, 1)</span>
}

func updateUserUsedQuotaAndRequestCount(id int, quota int, count int) <span class="cov0" title="0">{
        err := DB.Model(&amp;User{}).Where("id = ?", id).Updates(
                map[string]interface{}{
                        "used_quota":    gorm.Expr("used_quota + ?", quota),
                        "request_count": gorm.Expr("request_count + ?", count),
                },
        ).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("failed to update user used quota and request count: " + err.Error())
                return
        }</span>

        //// 更新缓存
        //if err := invalidateUserCache(id); err != nil {
        //        common.SysError("failed to invalidate user cache: " + err.Error())
        //}
}

func updateUserUsedQuota(id int, quota int) <span class="cov0" title="0">{
        err := DB.Model(&amp;User{}).Where("id = ?", id).Updates(
                map[string]interface{}{
                        "used_quota": gorm.Expr("used_quota + ?", quota),
                },
        ).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("failed to update user used quota: " + err.Error())
        }</span>
}

func updateUserRequestCount(id int, count int) <span class="cov0" title="0">{
        err := DB.Model(&amp;User{}).Where("id = ?", id).Update("request_count", gorm.Expr("request_count + ?", count)).Error
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("failed to update user request count: " + err.Error())
        }</span>
}

// GetUsernameById gets username from Redis first, falls back to DB if needed
func GetUsernameById(id int, fromDB bool) (username string, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := updateUserNameCache(id, username); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user name cache: " + err.Error())
                                }</span>
                        })
                }
        }()
        <span class="cov0" title="0">if !fromDB &amp;&amp; common.RedisEnabled </span><span class="cov0" title="0">{
                username, err := getUserNameCache(id)
                if err == nil </span><span class="cov0" title="0">{
                        return username, nil
                }</span>
                // Don't return error - fall through to DB
        }
        <span class="cov0" title="0">fromDB = true
        err = DB.Model(&amp;User{}).Where("id = ?", id).Select("username").Find(&amp;username).Error
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return username, nil</span>
}

func IsLinuxDOIdAlreadyTaken(linuxDOId string) bool <span class="cov0" title="0">{
        var user User
        err := DB.Unscoped().Where("linux_do_id = ?", linuxDOId).First(&amp;user).Error
        return !errors.Is(err, gorm.ErrRecordNotFound)
}</span>

func (user *User) FillUserByLinuxDOId() error <span class="cov0" title="0">{
        if user.LinuxDOId == "" </span><span class="cov0" title="0">{
                return errors.New("linux do id is empty")
        }</span>
        <span class="cov0" title="0">err := DB.Where("linux_do_id = ?", user.LinuxDOId).First(user).Error
        return err</span>
}

func RootUserExists() bool <span class="cov0" title="0">{
        var user User
        err := DB.Where("role = ?", common.RoleRootUser).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package model

import (
        "fmt"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"

        "github.com/gin-gonic/gin"

        "github.com/bytedance/gopkg/util/gopool"
)

// UserBase struct remains the same as it represents the cached data structure
type UserBase struct {
        Id       int    `json:"id"`
        Group    string `json:"group"`
        Email    string `json:"email"`
        Quota    int    `json:"quota"`
        Status   int    `json:"status"`
        Username string `json:"username"`
        Setting  string `json:"setting"`
}

func (user *UserBase) WriteContext(c *gin.Context) <span class="cov0" title="0">{
        common.SetContextKey(c, constant.ContextKeyUserGroup, user.Group)
        common.SetContextKey(c, constant.ContextKeyUserQuota, user.Quota)
        common.SetContextKey(c, constant.ContextKeyUserStatus, user.Status)
        common.SetContextKey(c, constant.ContextKeyUserEmail, user.Email)
        common.SetContextKey(c, constant.ContextKeyUserName, user.Username)
        common.SetContextKey(c, constant.ContextKeyUserSetting, user.GetSetting())
}</span>

func (user *UserBase) GetSetting() dto.UserSetting <span class="cov0" title="0">{
        setting := dto.UserSetting{}
        if user.Setting != "" </span><span class="cov0" title="0">{
                err := common.Unmarshal([]byte(user.Setting), &amp;setting)
                if err != nil </span><span class="cov0" title="0">{
                        common.SysLog("failed to unmarshal setting: " + err.Error())
                }</span>
        }
        <span class="cov0" title="0">return setting</span>
}

// getUserCacheKey returns the key for user cache
func getUserCacheKey(userId int) string <span class="cov0" title="0">{
        return fmt.Sprintf("user:%d", userId)
}</span>

// invalidateUserCache clears user cache
func invalidateUserCache(userId int) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisDelKey(getUserCacheKey(userId))</span>
}

// updateUserCache updates all user cache fields using hash
func updateUserCache(user User) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return common.RedisHSetObj(
                getUserCacheKey(user.Id),
                user.ToBaseUser(),
                time.Duration(common.RedisKeyCacheSeconds())*time.Second,
        )</span>
}

// GetUserCache gets complete user cache from hash
func GetUserCache(userId int) (userCache *UserBase, err error) <span class="cov0" title="0">{
        var user *User
        var fromDB bool
        defer func() </span><span class="cov0" title="0">{
                // Update Redis cache asynchronously on successful DB read
                if shouldUpdateRedis(fromDB, err) &amp;&amp; user != nil </span><span class="cov0" title="0">{
                        gopool.Go(func() </span><span class="cov0" title="0">{
                                if err := updateUserCache(*user); err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to update user status cache: " + err.Error())
                                }</span>
                        })
                }
        }()

        // Try getting from Redis first
        <span class="cov0" title="0">userCache, err = cacheGetUserBase(userId)
        if err == nil </span><span class="cov0" title="0">{
                return userCache, nil
        }</span>

        // If Redis fails, get from DB
        <span class="cov0" title="0">fromDB = true
        user, err = GetUserById(userId, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Return nil and error if DB lookup fails
        }</span>

        // Create cache object from user data
        <span class="cov0" title="0">userCache = &amp;UserBase{
                Id:       user.Id,
                Group:    user.Group,
                Quota:    user.Quota,
                Status:   user.Status,
                Username: user.Username,
                Setting:  user.Setting,
                Email:    user.Email,
        }

        return userCache, nil</span>
}

func cacheGetUserBase(userId int) (*UserBase, error) <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis is not enabled")
        }</span>
        <span class="cov0" title="0">var userCache UserBase
        // Try getting from Redis first
        err := common.RedisHGetObj(getUserCacheKey(userId), &amp;userCache)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userCache, nil</span>
}

// Add atomic quota operations using hash fields
func cacheIncrUserQuota(userId int, delta int64) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisHIncrBy(getUserCacheKey(userId), "Quota", delta)</span>
}

func cacheDecrUserQuota(userId int, delta int64) error <span class="cov0" title="0">{
        return cacheIncrUserQuota(userId, -delta)
}</span>

// Helper functions to get individual fields if needed
func getUserGroupCache(userId int) (string, error) <span class="cov0" title="0">{
        cache, err := GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return cache.Group, nil</span>
}

func getUserQuotaCache(userId int) (int, error) <span class="cov0" title="0">{
        cache, err := GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return cache.Quota, nil</span>
}

func getUserStatusCache(userId int) (int, error) <span class="cov0" title="0">{
        cache, err := GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return cache.Status, nil</span>
}

func getUserNameCache(userId int) (string, error) <span class="cov0" title="0">{
        cache, err := GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return cache.Username, nil</span>
}

func getUserSettingCache(userId int) (dto.UserSetting, error) <span class="cov0" title="0">{
        cache, err := GetUserCache(userId)
        if err != nil </span><span class="cov0" title="0">{
                return dto.UserSetting{}, err
        }</span>
        <span class="cov0" title="0">return cache.GetSetting(), nil</span>
}

// New functions for individual field updates
func updateUserStatusCache(userId int, status bool) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">statusInt := common.UserStatusEnabled
        if !status </span><span class="cov0" title="0">{
                statusInt = common.UserStatusDisabled
        }</span>
        <span class="cov0" title="0">return common.RedisHSetField(getUserCacheKey(userId), "Status", fmt.Sprintf("%d", statusInt))</span>
}

func updateUserQuotaCache(userId int, quota int) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisHSetField(getUserCacheKey(userId), "Quota", fmt.Sprintf("%d", quota))</span>
}

func updateUserGroupCache(userId int, group string) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisHSetField(getUserCacheKey(userId), "Group", group)</span>
}

func updateUserNameCache(userId int, username string) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisHSetField(getUserCacheKey(userId), "Username", username)</span>
}

func updateUserSettingCache(userId int, setting string) error <span class="cov0" title="0">{
        if !common.RedisEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return common.RedisHSetField(getUserCacheKey(userId), "Setting", setting)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package model

import (
        "errors"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"

        "github.com/bytedance/gopkg/util/gopool"
        "gorm.io/gorm"
)

const (
        BatchUpdateTypeUserQuota = iota
        BatchUpdateTypeTokenQuota
        BatchUpdateTypeUsedQuota
        BatchUpdateTypeChannelUsedQuota
        BatchUpdateTypeRequestCount
        BatchUpdateTypeCount // if you add a new type, you need to add a new map and a new lock
)

var batchUpdateStores []map[int]int
var batchUpdateLocks []sync.Mutex

func init() <span class="cov8" title="1">{
        for i := 0; i &lt; BatchUpdateTypeCount; i++ </span><span class="cov8" title="1">{
                batchUpdateStores = append(batchUpdateStores, make(map[int]int))
                batchUpdateLocks = append(batchUpdateLocks, sync.Mutex{})
        }</span>
}

func InitBatchUpdater() <span class="cov0" title="0">{
        gopool.Go(func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(common.BatchUpdateInterval) * time.Second)
                        batchUpdate()
                }</span>
        })
}

func addNewRecord(type_ int, id int, value int) <span class="cov0" title="0">{
        batchUpdateLocks[type_].Lock()
        defer batchUpdateLocks[type_].Unlock()
        if _, ok := batchUpdateStores[type_][id]; !ok </span><span class="cov0" title="0">{
                batchUpdateStores[type_][id] = value
        }</span> else<span class="cov0" title="0"> {
                batchUpdateStores[type_][id] += value
        }</span>
}

func batchUpdate() <span class="cov0" title="0">{
        // check if there's any data to update
        hasData := false
        for i := 0; i &lt; BatchUpdateTypeCount; i++ </span><span class="cov0" title="0">{
                batchUpdateLocks[i].Lock()
                if len(batchUpdateStores[i]) &gt; 0 </span><span class="cov0" title="0">{
                        hasData = true
                        batchUpdateLocks[i].Unlock()
                        break</span>
                }
                <span class="cov0" title="0">batchUpdateLocks[i].Unlock()</span>
        }

        <span class="cov0" title="0">if !hasData </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">common.SysLog("batch update started")
        for i := 0; i &lt; BatchUpdateTypeCount; i++ </span><span class="cov0" title="0">{
                batchUpdateLocks[i].Lock()
                store := batchUpdateStores[i]
                batchUpdateStores[i] = make(map[int]int)
                batchUpdateLocks[i].Unlock()
                // TODO: maybe we can combine updates with same key?
                for key, value := range store </span><span class="cov0" title="0">{
                        switch i </span>{
                        case BatchUpdateTypeUserQuota:<span class="cov0" title="0">
                                err := increaseUserQuota(key, value)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to batch update user quota: " + err.Error())
                                }</span>
                        case BatchUpdateTypeTokenQuota:<span class="cov0" title="0">
                                err := increaseTokenQuota(key, value)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.SysLog("failed to batch update token quota: " + err.Error())
                                }</span>
                        case BatchUpdateTypeUsedQuota:<span class="cov0" title="0">
                                updateUserUsedQuota(key, value)</span>
                        case BatchUpdateTypeRequestCount:<span class="cov0" title="0">
                                updateUserRequestCount(key, value)</span>
                        case BatchUpdateTypeChannelUsedQuota:<span class="cov0" title="0">
                                updateChannelUsedQuota(key, value)</span>
                        }
                }
        }
        <span class="cov0" title="0">common.SysLog("batch update finished")</span>
}

func RecordExist(err error) (bool, error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func shouldUpdateRedis(fromDB bool, err error) bool <span class="cov0" title="0">{
        return common.RedisEnabled &amp;&amp; fromDB &amp;&amp; err == nil
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package model

import (
        "github.com/QuantumNous/new-api/common"

        "gorm.io/gorm"
)

// Vendor 用于存储供应商信息，供模型引用
// Name 唯一，用于在模型中关联
// Icon 采用 @lobehub/icons 的图标名，前端可直接渲染
// Status 预留字段，1 表示启用
// 本表同样遵循 3NF 设计范式

type Vendor struct {
        Id          int            `json:"id"`
        Name        string         `json:"name" gorm:"size:128;not null;uniqueIndex:uk_vendor_name_delete_at,priority:1"`
        Description string         `json:"description,omitempty" gorm:"type:text"`
        Icon        string         `json:"icon,omitempty" gorm:"type:varchar(128)"`
        Status      int            `json:"status" gorm:"default:1"`
        CreatedTime int64          `json:"created_time" gorm:"bigint"`
        UpdatedTime int64          `json:"updated_time" gorm:"bigint"`
        DeletedAt   gorm.DeletedAt `json:"-" gorm:"index;uniqueIndex:uk_vendor_name_delete_at,priority:2"`
}

// Insert 创建新的供应商记录
func (v *Vendor) Insert() error <span class="cov0" title="0">{
        now := common.GetTimestamp()
        v.CreatedTime = now
        v.UpdatedTime = now
        return DB.Create(v).Error
}</span>

// IsVendorNameDuplicated 检查供应商名称是否重复（排除自身 ID）
func IsVendorNameDuplicated(id int, name string) (bool, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">var cnt int64
        err := DB.Model(&amp;Vendor{}).Where("name = ? AND id &lt;&gt; ?", name, id).Count(&amp;cnt).Error
        return cnt &gt; 0, err</span>
}

// Update 更新供应商记录
func (v *Vendor) Update() error <span class="cov0" title="0">{
        v.UpdatedTime = common.GetTimestamp()
        return DB.Save(v).Error
}</span>

// Delete 软删除供应商
func (v *Vendor) Delete() error <span class="cov0" title="0">{
        return DB.Delete(v).Error
}</span>

// GetVendorByID 根据 ID 获取供应商
func GetVendorByID(id int) (*Vendor, error) <span class="cov0" title="0">{
        var v Vendor
        err := DB.First(&amp;v, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;v, nil</span>
}

// GetAllVendors 获取全部供应商（分页）
func GetAllVendors(offset int, limit int) ([]*Vendor, error) <span class="cov0" title="0">{
        var vendors []*Vendor
        err := DB.Offset(offset).Limit(limit).Find(&amp;vendors).Error
        return vendors, err
}</span>

// SearchVendors 按关键字搜索供应商
func SearchVendors(keyword string, offset int, limit int) ([]*Vendor, int64, error) <span class="cov0" title="0">{
        db := DB.Model(&amp;Vendor{})
        if keyword != "" </span><span class="cov0" title="0">{
                like := "%" + keyword + "%"
                db = db.Where("name LIKE ? OR description LIKE ?", like, like)
        }</span>
        <span class="cov0" title="0">var total int64
        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">var vendors []*Vendor
        if err := db.Offset(offset).Limit(limit).Order("id DESC").Find(&amp;vendors).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return vendors, total, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package service

import (
        "encoding/base64"
        "fmt"
        "strings"
)

func parseAudio(audioBase64 string, format string) (duration float64, err error) <span class="cov0" title="0">{
        audioData, err := base64.StdEncoding.DecodeString(audioBase64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("base64 decode error: %v", err)
        }</span>

        <span class="cov0" title="0">var samplesCount int
        var sampleRate int

        switch format </span>{
        case "pcm16":<span class="cov0" title="0">
                samplesCount = len(audioData) / 2 // 16位 = 2字节每样本
                sampleRate = 24000</span>                // 24kHz
        case "g711_ulaw", "g711_alaw":<span class="cov0" title="0">
                samplesCount = len(audioData) // 8位 = 1字节每样本
                sampleRate = 8000</span>             // 8kHz
        default:<span class="cov0" title="0">
                samplesCount = len(audioData) // 8位 = 1字节每样本
                sampleRate = 8000</span>             // 8kHz
        }

        <span class="cov0" title="0">duration = float64(samplesCount) / float64(sampleRate)
        return duration, nil</span>
}

func DecodeBase64AudioData(audioBase64 string) (string, error) <span class="cov0" title="0">{
        // 检查并移除 data:audio/xxx;base64, 前缀
        idx := strings.Index(audioBase64, ",")
        if idx != -1 </span><span class="cov0" title="0">{
                audioBase64 = audioBase64[idx+1:]
        }</span>

        // 解码 Base64 数据
        <span class="cov0" title="0">_, err := base64.StdEncoding.DecodeString(audioBase64)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("base64 decode error: %v", err)
        }</span>

        <span class="cov0" title="0">return audioBase64, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package service

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/types"
)

func formatNotifyType(channelId int, status int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%d_%d", dto.NotifyTypeChannelUpdate, channelId, status)
}</span>

// disable &amp; notify
func DisableChannel(channelError types.ChannelError, reason string) <span class="cov0" title="0">{
        common.SysLog(fmt.Sprintf("通道「%s」（#%d）发生错误，准备禁用，原因：%s", channelError.ChannelName, channelError.ChannelId, reason))

        // 检查是否启用自动禁用功能
        if !channelError.AutoBan </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("通道「%s」（#%d）未启用自动禁用功能，跳过禁用操作", channelError.ChannelName, channelError.ChannelId))
                return
        }</span>

        <span class="cov0" title="0">success := model.UpdateChannelStatus(channelError.ChannelId, channelError.UsingKey, common.ChannelStatusAutoDisabled, reason)
        if success </span><span class="cov0" title="0">{
                subject := fmt.Sprintf("通道「%s」（#%d）已被禁用", channelError.ChannelName, channelError.ChannelId)
                content := fmt.Sprintf("通道「%s」（#%d）已被禁用，原因：%s", channelError.ChannelName, channelError.ChannelId, reason)
                NotifyRootUser(formatNotifyType(channelError.ChannelId, common.ChannelStatusAutoDisabled), subject, content)
        }</span>
}

func EnableChannel(channelId int, usingKey string, channelName string) <span class="cov0" title="0">{
        success := model.UpdateChannelStatus(channelId, usingKey, common.ChannelStatusEnabled, "")
        if success </span><span class="cov0" title="0">{
                subject := fmt.Sprintf("通道「%s」（#%d）已被启用", channelName, channelId)
                content := fmt.Sprintf("通道「%s」（#%d）已被启用", channelName, channelId)
                NotifyRootUser(formatNotifyType(channelId, common.ChannelStatusEnabled), subject, content)
        }</span>
}

func ShouldDisableChannel(channelType int, err *types.NewAPIError) bool <span class="cov0" title="0">{
        if !common.AutomaticDisableChannelEnabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if types.IsChannelError(err) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if types.IsSkipRetryError(err) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if err.StatusCode == http.StatusForbidden </span><span class="cov0" title="0">{
                switch channelType </span>{
                case constant.ChannelTypeGemini:<span class="cov0" title="0">
                        return true</span>
                }
        }
        <span class="cov0" title="0">oaiErr := err.ToOpenAIError()
        switch oaiErr.Code </span>{
        case "invalid_api_key":<span class="cov0" title="0">
                return true</span>
        case "account_deactivated":<span class="cov0" title="0">
                return true</span>
        case "billing_not_active":<span class="cov0" title="0">
                return true</span>
        case "pre_consume_token_quota_failed":<span class="cov0" title="0">
                return true</span>
        case "Arrearage":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">switch oaiErr.Type </span>{
        case "insufficient_quota":<span class="cov0" title="0">
                return true</span>
        case "insufficient_user_quota":<span class="cov0" title="0">
                return true</span>
        // https://docs.anthropic.com/claude/reference/errors
        case "authentication_error":<span class="cov0" title="0">
                return true</span>
        case "permission_error":<span class="cov0" title="0">
                return true</span>
        case "forbidden":<span class="cov0" title="0">
                return true</span>
        }

        <span class="cov0" title="0">lowerMessage := strings.ToLower(err.Error())
        search, _ := AcSearch(lowerMessage, operation_setting.AutomaticDisableKeywords, true)
        return search</span>
}

func ShouldEnableChannel(newAPIError *types.NewAPIError, status int) bool <span class="cov0" title="0">{
        if !common.AutomaticEnableChannelEnabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if newAPIError != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if status != common.ChannelStatusAutoDisabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package service

import (
        "errors"
        "fmt"
        "sort"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/gin-gonic/gin"
)

func CacheGetRandomSatisfiedChannel(c *gin.Context, group string, modelName string, retry int) (*model.Channel, string, error) <span class="cov0" title="0">{
        var channel *model.Channel
        var err error
        selectGroup := group
        userGroup := common.GetContextKeyString(c, constant.ContextKeyUserGroup)
        if group == "auto" </span><span class="cov0" title="0">{
                if len(setting.GetAutoGroups()) == 0 </span><span class="cov0" title="0">{
                        return nil, selectGroup, errors.New("auto groups is not enabled")
                }</span>
                <span class="cov0" title="0">for _, autoGroup := range GetUserAutoGroup(userGroup) </span><span class="cov0" title="0">{
                        logger.LogDebug(c, "Auto selecting group:", autoGroup)
                        channel, _ = model.GetRandomSatisfiedChannel(autoGroup, modelName, retry)
                        if channel == nil </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                c.Set("auto_group", autoGroup)
                                selectGroup = autoGroup
                                logger.LogDebug(c, "Auto selected group:", autoGroup)
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                channel, err = model.GetRandomSatisfiedChannel(group, modelName, retry)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, group, err
                }</span>
        }
        <span class="cov0" title="0">return channel, selectGroup, nil</span>
}

// SelectChannelWithPriority 按分组优先级选择渠道
func SelectChannelWithPriority(c *gin.Context, token *model.Token, modelName string, retry int) (*model.Channel, string, error) <span class="cov0" title="0">{
        priorities, err := token.GetGroupPriorities()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c, "Failed to parse group priorities: "+err.Error())
                fallbackGroup := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)
                if fallbackGroup == "" </span><span class="cov0" title="0">{
                        fallbackGroup = token.Group
                }</span>
                <span class="cov0" title="0">return CacheGetRandomSatisfiedChannel(c, fallbackGroup, modelName, retry)</span>
        }

        <span class="cov0" title="0">baseGroup := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)
        if baseGroup == "" </span><span class="cov0" title="0">{
                baseGroup = token.Group
        }</span>
        <span class="cov0" title="0">if baseGroup == "" </span><span class="cov0" title="0">{
                baseGroup = common.GetContextKeyString(c, constant.ContextKeyUserGroup)
        }</span>

        <span class="cov0" title="0">if len(priorities) == 0 </span><span class="cov0" title="0">{
                return CacheGetRandomSatisfiedChannel(c, baseGroup, modelName, retry)
        }</span>

        <span class="cov0" title="0">for _, p := range priorities </span><span class="cov0" title="0">{
                logger.LogDebug(c, fmt.Sprintf("Trying group: %s (priority: %d)", p.Group, p.Priority))

                channel, selectGroup, err := CacheGetRandomSatisfiedChannel(c, p.Group, modelName, retry)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogDebug(c, fmt.Sprintf("Group %s failed: %s", p.Group, err.Error()))
                        continue</span>
                }

                <span class="cov0" title="0">if channel != nil </span><span class="cov0" title="0">{
                        logger.LogInfo(c, fmt.Sprintf("Selected channel from group: %s", selectGroup))
                        common.SetContextKey(c, constant.ContextKeyUsingGroup, selectGroup)
                        return channel, selectGroup, nil
                }</span>
        }

        <span class="cov0" title="0">logger.LogWarn(c, "All configured groups failed")

        if token.AutoSmartGroup </span><span class="cov0" title="0">{
                logger.LogInfo(c, "Auto smart group enabled, trying fallback groups by ratio")
                return selectChannelByRatio(c, modelName, retry, priorities)
        }</span>

        <span class="cov0" title="0">return nil, "", errors.New("所有配置的分组都无可用渠道")</span>
}

// selectChannelByRatio 按费率从低到高选择分组
func selectChannelByRatio(c *gin.Context, modelName string, retry int, excludePriorities []model.GroupPriority) (*model.Channel, string, error) <span class="cov0" title="0">{
        userGroup := common.GetContextKeyString(c, constant.ContextKeyUserGroup)
        usableGroups := GetUserUsableGroups(userGroup)
        ratioMap := ratio_setting.GetGroupRatioCopy()

        excludeMap := make(map[string]bool)
        for _, p := range excludePriorities </span><span class="cov0" title="0">{
                excludeMap[p.Group] = true
        }</span>

        <span class="cov0" title="0">type groupWithRatio struct {
                group string
                ratio float64
        }
        candidates := make([]groupWithRatio, 0)

        for group := range usableGroups </span><span class="cov0" title="0">{
                if excludeMap[group] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ratio, ok := ratioMap[group]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">candidates = append(candidates, groupWithRatio{
                        group: group,
                        ratio: ratio,
                })</span>
        }

        <span class="cov0" title="0">if len(candidates) == 0 </span><span class="cov0" title="0">{
                return nil, "", errors.New("没有可用的备用分组")
        }</span>

        <span class="cov0" title="0">sort.Slice(candidates, func(i, j int) bool </span><span class="cov0" title="0">{
                return candidates[i].ratio &lt; candidates[j].ratio
        }</span>)

        <span class="cov0" title="0">for _, item := range candidates </span><span class="cov0" title="0">{
                logger.LogDebug(c, fmt.Sprintf("Auto smart group trying: %s (ratio: %.2f)", item.group, item.ratio))

                channel, selectGroup, err := CacheGetRandomSatisfiedChannel(c, item.group, modelName, retry)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogDebug(c, fmt.Sprintf("Auto smart group %s failed: %s", item.group, err.Error()))
                        continue</span>
                }

                <span class="cov0" title="0">if channel != nil </span><span class="cov0" title="0">{
                        logger.LogInfo(c, fmt.Sprintf("Auto smart group selected: %s", selectGroup))
                        common.SetContextKey(c, constant.ContextKeyUsingGroup, selectGroup)
                        return channel, selectGroup, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, "", errors.New("自动智能分组也无法找到可用渠道")</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/relay/channel/openrouter"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
)

func ClaudeToOpenAIRequest(claudeRequest dto.ClaudeRequest, info *relaycommon.RelayInfo) (*dto.GeneralOpenAIRequest, error) <span class="cov0" title="0">{
        openAIRequest := dto.GeneralOpenAIRequest{
                Model:       claudeRequest.Model,
                MaxTokens:   claudeRequest.MaxTokens,
                Temperature: claudeRequest.Temperature,
                TopP:        claudeRequest.TopP,
                Stream:      claudeRequest.Stream,
        }

        isOpenRouter := info.ChannelType == constant.ChannelTypeOpenRouter

        if claudeRequest.Thinking != nil &amp;&amp; claudeRequest.Thinking.Type == "enabled" </span><span class="cov0" title="0">{
                if isOpenRouter </span><span class="cov0" title="0">{
                        reasoning := openrouter.RequestReasoning{
                                MaxTokens: claudeRequest.Thinking.GetBudgetTokens(),
                        }
                        reasoningJSON, err := json.Marshal(reasoning)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal reasoning: %w", err)
                        }</span>
                        <span class="cov0" title="0">openAIRequest.Reasoning = reasoningJSON</span>
                } else<span class="cov0" title="0"> {
                        thinkingSuffix := "-thinking"
                        if strings.HasSuffix(info.OriginModelName, thinkingSuffix) &amp;&amp;
                                !strings.HasSuffix(openAIRequest.Model, thinkingSuffix) </span><span class="cov0" title="0">{
                                openAIRequest.Model = openAIRequest.Model + thinkingSuffix
                        }</span>
                }
        }

        // Convert stop sequences
        <span class="cov0" title="0">if len(claudeRequest.StopSequences) == 1 </span><span class="cov0" title="0">{
                openAIRequest.Stop = claudeRequest.StopSequences[0]
        }</span> else<span class="cov0" title="0"> if len(claudeRequest.StopSequences) &gt; 1 </span><span class="cov0" title="0">{
                openAIRequest.Stop = claudeRequest.StopSequences
        }</span>

        // Convert tools
        <span class="cov0" title="0">tools, _ := common.Any2Type[[]dto.Tool](claudeRequest.Tools)
        openAITools := make([]dto.ToolCallRequest, 0)
        for _, claudeTool := range tools </span><span class="cov0" title="0">{
                openAITool := dto.ToolCallRequest{
                        Type: "function",
                        Function: dto.FunctionRequest{
                                Name:        claudeTool.Name,
                                Description: claudeTool.Description,
                                Parameters:  claudeTool.InputSchema,
                        },
                }
                openAITools = append(openAITools, openAITool)
        }</span>
        <span class="cov0" title="0">openAIRequest.Tools = openAITools

        // Convert messages
        openAIMessages := make([]dto.Message, 0)

        // Add system message if present
        if claudeRequest.System != nil </span><span class="cov0" title="0">{
                if claudeRequest.IsStringSystem() &amp;&amp; claudeRequest.GetStringSystem() != "" </span><span class="cov0" title="0">{
                        openAIMessage := dto.Message{
                                Role: "system",
                        }
                        openAIMessage.SetStringContent(claudeRequest.GetStringSystem())
                        openAIMessages = append(openAIMessages, openAIMessage)
                }</span> else<span class="cov0" title="0"> {
                        systems := claudeRequest.ParseSystem()
                        if len(systems) &gt; 0 </span><span class="cov0" title="0">{
                                openAIMessage := dto.Message{
                                        Role: "system",
                                }
                                isOpenRouterClaude := isOpenRouter &amp;&amp; strings.HasPrefix(info.UpstreamModelName, "anthropic/claude")
                                if isOpenRouterClaude </span><span class="cov0" title="0">{
                                        systemMediaMessages := make([]dto.MediaContent, 0, len(systems))
                                        for _, system := range systems </span><span class="cov0" title="0">{
                                                message := dto.MediaContent{
                                                        Type:         "text",
                                                        Text:         system.GetText(),
                                                        CacheControl: system.CacheControl,
                                                }
                                                systemMediaMessages = append(systemMediaMessages, message)
                                        }</span>
                                        <span class="cov0" title="0">openAIMessage.SetMediaContent(systemMediaMessages)</span>
                                } else<span class="cov0" title="0"> {
                                        systemStr := ""
                                        for _, system := range systems </span><span class="cov0" title="0">{
                                                if system.Text != nil </span><span class="cov0" title="0">{
                                                        systemStr += *system.Text
                                                }</span>
                                        }
                                        <span class="cov0" title="0">openAIMessage.SetStringContent(systemStr)</span>
                                }
                                <span class="cov0" title="0">openAIMessages = append(openAIMessages, openAIMessage)</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, claudeMessage := range claudeRequest.Messages </span><span class="cov0" title="0">{
                openAIMessage := dto.Message{
                        Role: claudeMessage.Role,
                }

                //log.Printf("claudeMessage.Content: %v", claudeMessage.Content)
                if claudeMessage.IsStringContent() </span><span class="cov0" title="0">{
                        openAIMessage.SetStringContent(claudeMessage.GetStringContent())
                }</span> else<span class="cov0" title="0"> {
                        content, err := claudeMessage.ParseContent()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">contents := content
                        var toolCalls []dto.ToolCallRequest
                        mediaMessages := make([]dto.MediaContent, 0, len(contents))

                        for _, mediaMsg := range contents </span><span class="cov0" title="0">{
                                switch mediaMsg.Type </span>{
                                case "text":<span class="cov0" title="0">
                                        message := dto.MediaContent{
                                                Type:         "text",
                                                Text:         mediaMsg.GetText(),
                                                CacheControl: mediaMsg.CacheControl,
                                        }
                                        mediaMessages = append(mediaMessages, message)</span>
                                case "image":<span class="cov0" title="0">
                                        // Handle image conversion (base64 to URL or keep as is)
                                        imageData := fmt.Sprintf("data:%s;base64,%s", mediaMsg.Source.MediaType, mediaMsg.Source.Data)
                                        //textContent += fmt.Sprintf("[Image: %s]", imageData)
                                        mediaMessage := dto.MediaContent{
                                                Type:     "image_url",
                                                ImageUrl: &amp;dto.MessageImageUrl{Url: imageData},
                                        }
                                        mediaMessages = append(mediaMessages, mediaMessage)</span>
                                case "tool_use":<span class="cov0" title="0">
                                        toolCall := dto.ToolCallRequest{
                                                ID:   mediaMsg.Id,
                                                Type: "function",
                                                Function: dto.FunctionRequest{
                                                        Name:      mediaMsg.Name,
                                                        Arguments: toJSONString(mediaMsg.Input),
                                                },
                                        }
                                        toolCalls = append(toolCalls, toolCall)</span>
                                case "tool_result":<span class="cov0" title="0">
                                        // Add tool result as a separate message
                                        toolName := mediaMsg.Name
                                        if toolName == "" </span><span class="cov0" title="0">{
                                                toolName = claudeRequest.SearchToolNameByToolCallId(mediaMsg.ToolUseId)
                                        }</span>
                                        <span class="cov0" title="0">oaiToolMessage := dto.Message{
                                                Role:       "tool",
                                                Name:       &amp;toolName,
                                                ToolCallId: mediaMsg.ToolUseId,
                                        }
                                        //oaiToolMessage.SetStringContent(*mediaMsg.GetMediaContent().Text)
                                        if mediaMsg.IsStringContent() </span><span class="cov0" title="0">{
                                                oaiToolMessage.SetStringContent(mediaMsg.GetStringContent())
                                        }</span> else<span class="cov0" title="0"> {
                                                mediaContents := mediaMsg.ParseMediaContent()
                                                encodeJson, _ := common.Marshal(mediaContents)
                                                oaiToolMessage.SetStringContent(string(encodeJson))
                                        }</span>
                                        <span class="cov0" title="0">openAIMessages = append(openAIMessages, oaiToolMessage)</span>
                                }
                        }

                        <span class="cov0" title="0">if len(toolCalls) &gt; 0 </span><span class="cov0" title="0">{
                                openAIMessage.SetToolCalls(toolCalls)
                        }</span>

                        <span class="cov0" title="0">if len(mediaMessages) &gt; 0 &amp;&amp; len(toolCalls) == 0 </span><span class="cov0" title="0">{
                                openAIMessage.SetMediaContent(mediaMessages)
                        }</span>
                }
                <span class="cov0" title="0">if len(openAIMessage.ParseContent()) &gt; 0 || len(openAIMessage.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        openAIMessages = append(openAIMessages, openAIMessage)
                }</span>
        }

        <span class="cov0" title="0">openAIRequest.Messages = openAIMessages

        return &amp;openAIRequest, nil</span>
}

func generateStopBlock(index int) *dto.ClaudeResponse <span class="cov0" title="0">{
        return &amp;dto.ClaudeResponse{
                Type:  "content_block_stop",
                Index: common.GetPointer[int](index),
        }
}</span>

func StreamResponseOpenAI2Claude(openAIResponse *dto.ChatCompletionsStreamResponse, info *relaycommon.RelayInfo) []*dto.ClaudeResponse <span class="cov0" title="0">{
        var claudeResponses []*dto.ClaudeResponse
        if info.SendResponseCount == 1 </span><span class="cov0" title="0">{
                msg := &amp;dto.ClaudeMediaMessage{
                        Id:    openAIResponse.Id,
                        Model: openAIResponse.Model,
                        Type:  "message",
                        Role:  "assistant",
                        Usage: &amp;dto.ClaudeUsage{
                                InputTokens:  info.PromptTokens,
                                OutputTokens: 0,
                        },
                }
                msg.SetContent(make([]any, 0))
                claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                        Type:    "message_start",
                        Message: msg,
                })
                claudeResponses = append(claudeResponses)
                //claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                //        Type: "ping",
                //})
                if openAIResponse.IsToolCall() </span><span class="cov0" title="0">{
                        info.ClaudeConvertInfo.LastMessagesType = relaycommon.LastMessageTypeTools
                        resp := &amp;dto.ClaudeResponse{
                                Type: "content_block_start",
                                ContentBlock: &amp;dto.ClaudeMediaMessage{
                                        Id:    openAIResponse.GetFirstToolCall().ID,
                                        Type:  "tool_use",
                                        Name:  openAIResponse.GetFirstToolCall().Function.Name,
                                        Input: map[string]interface{}{},
                                },
                        }
                        resp.SetIndex(0)
                        claudeResponses = append(claudeResponses, resp)
                }</span> else <span class="cov0" title="0">{

                }</span>
                // 判断首个响应是否存在内容（非标准的 OpenAI 响应）
                <span class="cov0" title="0">if len(openAIResponse.Choices) &gt; 0 &amp;&amp; len(openAIResponse.Choices[0].Delta.GetContentString()) &gt; 0 </span><span class="cov0" title="0">{
                        claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                Index: &amp;info.ClaudeConvertInfo.Index,
                                Type:  "content_block_start",
                                ContentBlock: &amp;dto.ClaudeMediaMessage{
                                        Type: "text",
                                        Text: common.GetPointer[string](""),
                                },
                        })
                        claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                Index: &amp;info.ClaudeConvertInfo.Index,
                                Type:  "content_block_delta",
                                Delta: &amp;dto.ClaudeMediaMessage{
                                        Type: "text_delta",
                                        Text: common.GetPointer[string](openAIResponse.Choices[0].Delta.GetContentString()),
                                },
                        })
                        info.ClaudeConvertInfo.LastMessagesType = relaycommon.LastMessageTypeText
                }</span>
                <span class="cov0" title="0">return claudeResponses</span>
        }

        <span class="cov0" title="0">if len(openAIResponse.Choices) == 0 </span><span class="cov0" title="0">{
                // no choices
                // 可能为非标准的 OpenAI 响应，判断是否已经完成
                if info.Done </span><span class="cov0" title="0">{
                        claudeResponses = append(claudeResponses, generateStopBlock(info.ClaudeConvertInfo.Index))
                        oaiUsage := info.ClaudeConvertInfo.Usage
                        if oaiUsage != nil </span><span class="cov0" title="0">{
                                claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                        Type: "message_delta",
                                        Usage: &amp;dto.ClaudeUsage{
                                                InputTokens:              oaiUsage.PromptTokens,
                                                OutputTokens:             oaiUsage.CompletionTokens,
                                                CacheCreationInputTokens: oaiUsage.PromptTokensDetails.CachedCreationTokens,
                                                CacheReadInputTokens:     oaiUsage.PromptTokensDetails.CachedTokens,
                                        },
                                        Delta: &amp;dto.ClaudeMediaMessage{
                                                StopReason: common.GetPointer[string](stopReasonOpenAI2Claude(info.FinishReason)),
                                        },
                                })
                        }</span>
                        <span class="cov0" title="0">claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                Type: "message_stop",
                        })</span>
                }
                <span class="cov0" title="0">return claudeResponses</span>
        } else<span class="cov0" title="0"> {
                chosenChoice := openAIResponse.Choices[0]
                if chosenChoice.FinishReason != nil &amp;&amp; *chosenChoice.FinishReason != "" </span><span class="cov0" title="0">{
                        // should be done
                        info.FinishReason = *chosenChoice.FinishReason
                        if !info.Done </span><span class="cov0" title="0">{
                                return claudeResponses
                        }</span>
                }
                <span class="cov0" title="0">if info.Done </span><span class="cov0" title="0">{
                        claudeResponses = append(claudeResponses, generateStopBlock(info.ClaudeConvertInfo.Index))
                        oaiUsage := info.ClaudeConvertInfo.Usage
                        if oaiUsage != nil </span><span class="cov0" title="0">{
                                claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                        Type: "message_delta",
                                        Usage: &amp;dto.ClaudeUsage{
                                                InputTokens:              oaiUsage.PromptTokens,
                                                OutputTokens:             oaiUsage.CompletionTokens,
                                                CacheCreationInputTokens: oaiUsage.PromptTokensDetails.CachedCreationTokens,
                                                CacheReadInputTokens:     oaiUsage.PromptTokensDetails.CachedTokens,
                                        },
                                        Delta: &amp;dto.ClaudeMediaMessage{
                                                StopReason: common.GetPointer[string](stopReasonOpenAI2Claude(info.FinishReason)),
                                        },
                                })
                        }</span>
                        <span class="cov0" title="0">claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                Type: "message_stop",
                        })</span>
                } else<span class="cov0" title="0"> {
                        var claudeResponse dto.ClaudeResponse
                        var isEmpty bool
                        claudeResponse.Type = "content_block_delta"
                        if len(chosenChoice.Delta.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                                if info.ClaudeConvertInfo.LastMessagesType != relaycommon.LastMessageTypeTools </span><span class="cov0" title="0">{
                                        claudeResponses = append(claudeResponses, generateStopBlock(info.ClaudeConvertInfo.Index))
                                        info.ClaudeConvertInfo.Index++
                                        claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                                Index: &amp;info.ClaudeConvertInfo.Index,
                                                Type:  "content_block_start",
                                                ContentBlock: &amp;dto.ClaudeMediaMessage{
                                                        Id:    openAIResponse.GetFirstToolCall().ID,
                                                        Type:  "tool_use",
                                                        Name:  openAIResponse.GetFirstToolCall().Function.Name,
                                                        Input: map[string]interface{}{},
                                                },
                                        })
                                }</span>
                                <span class="cov0" title="0">info.ClaudeConvertInfo.LastMessagesType = relaycommon.LastMessageTypeTools
                                // tools delta
                                claudeResponse.Delta = &amp;dto.ClaudeMediaMessage{
                                        Type:        "input_json_delta",
                                        PartialJson: &amp;chosenChoice.Delta.ToolCalls[0].Function.Arguments,
                                }</span>
                        } else<span class="cov0" title="0"> {
                                reasoning := chosenChoice.Delta.GetReasoningContent()
                                textContent := chosenChoice.Delta.GetContentString()
                                if reasoning != "" || textContent != "" </span><span class="cov0" title="0">{
                                        if reasoning != "" </span><span class="cov0" title="0">{
                                                if info.ClaudeConvertInfo.LastMessagesType != relaycommon.LastMessageTypeThinking </span><span class="cov0" title="0">{
                                                        //info.ClaudeConvertInfo.Index++
                                                        claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                                                Index: &amp;info.ClaudeConvertInfo.Index,
                                                                Type:  "content_block_start",
                                                                ContentBlock: &amp;dto.ClaudeMediaMessage{
                                                                        Type:     "thinking",
                                                                        Thinking: common.GetPointer[string](""),
                                                                },
                                                        })
                                                }</span>
                                                <span class="cov0" title="0">info.ClaudeConvertInfo.LastMessagesType = relaycommon.LastMessageTypeThinking
                                                // text delta
                                                claudeResponse.Delta = &amp;dto.ClaudeMediaMessage{
                                                        Type:     "thinking_delta",
                                                        Thinking: &amp;reasoning,
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if info.ClaudeConvertInfo.LastMessagesType != relaycommon.LastMessageTypeText </span><span class="cov0" title="0">{
                                                        if info.LastMessagesType == relaycommon.LastMessageTypeThinking || info.LastMessagesType == relaycommon.LastMessageTypeTools </span><span class="cov0" title="0">{
                                                                claudeResponses = append(claudeResponses, generateStopBlock(info.ClaudeConvertInfo.Index))
                                                                info.ClaudeConvertInfo.Index++
                                                        }</span>
                                                        <span class="cov0" title="0">claudeResponses = append(claudeResponses, &amp;dto.ClaudeResponse{
                                                                Index: &amp;info.ClaudeConvertInfo.Index,
                                                                Type:  "content_block_start",
                                                                ContentBlock: &amp;dto.ClaudeMediaMessage{
                                                                        Type: "text",
                                                                        Text: common.GetPointer[string](""),
                                                                },
                                                        })</span>
                                                }
                                                <span class="cov0" title="0">info.ClaudeConvertInfo.LastMessagesType = relaycommon.LastMessageTypeText
                                                // text delta
                                                claudeResponse.Delta = &amp;dto.ClaudeMediaMessage{
                                                        Type: "text_delta",
                                                        Text: common.GetPointer[string](textContent),
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        isEmpty = true
                                }</span>
                        }
                        <span class="cov0" title="0">claudeResponse.Index = &amp;info.ClaudeConvertInfo.Index
                        if !isEmpty </span><span class="cov0" title="0">{
                                claudeResponses = append(claudeResponses, &amp;claudeResponse)
                        }</span>
                }
        }

        <span class="cov0" title="0">return claudeResponses</span>
}

func ResponseOpenAI2Claude(openAIResponse *dto.OpenAITextResponse, info *relaycommon.RelayInfo) *dto.ClaudeResponse <span class="cov0" title="0">{
        var stopReason string
        contents := make([]dto.ClaudeMediaMessage, 0)
        claudeResponse := &amp;dto.ClaudeResponse{
                Id:    openAIResponse.Id,
                Type:  "message",
                Role:  "assistant",
                Model: openAIResponse.Model,
        }
        for _, choice := range openAIResponse.Choices </span><span class="cov0" title="0">{
                stopReason = stopReasonOpenAI2Claude(choice.FinishReason)
                if choice.FinishReason == "tool_calls" </span><span class="cov0" title="0">{
                        for _, toolUse := range choice.Message.ParseToolCalls() </span><span class="cov0" title="0">{
                                claudeContent := dto.ClaudeMediaMessage{}
                                claudeContent.Type = "tool_use"
                                claudeContent.Id = toolUse.ID
                                claudeContent.Name = toolUse.Function.Name
                                var mapParams map[string]interface{}
                                if err := common.Unmarshal([]byte(toolUse.Function.Arguments), &amp;mapParams); err == nil </span><span class="cov0" title="0">{
                                        claudeContent.Input = mapParams
                                }</span> else<span class="cov0" title="0"> {
                                        claudeContent.Input = toolUse.Function.Arguments
                                }</span>
                                <span class="cov0" title="0">contents = append(contents, claudeContent)</span>
                        }
                } else<span class="cov0" title="0"> {
                        claudeContent := dto.ClaudeMediaMessage{}
                        claudeContent.Type = "text"
                        claudeContent.SetText(choice.Message.StringContent())
                        contents = append(contents, claudeContent)
                }</span>
        }
        <span class="cov0" title="0">claudeResponse.Content = contents
        claudeResponse.StopReason = stopReason
        claudeResponse.Usage = &amp;dto.ClaudeUsage{
                InputTokens:  openAIResponse.PromptTokens,
                OutputTokens: openAIResponse.CompletionTokens,
        }

        return claudeResponse</span>
}

func stopReasonOpenAI2Claude(reason string) string <span class="cov0" title="0">{
        switch reason </span>{
        case "stop":<span class="cov0" title="0">
                return "end_turn"</span>
        case "stop_sequence":<span class="cov0" title="0">
                return "stop_sequence"</span>
        case "length":<span class="cov0" title="0">
                fallthrough</span>
        case "max_tokens":<span class="cov0" title="0">
                return "max_tokens"</span>
        case "tool_calls":<span class="cov0" title="0">
                return "tool_use"</span>
        default:<span class="cov0" title="0">
                return reason</span>
        }
}

func toJSONString(v interface{}) string <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

func GeminiToOpenAIRequest(geminiRequest *dto.GeminiChatRequest, info *relaycommon.RelayInfo) (*dto.GeneralOpenAIRequest, error) <span class="cov0" title="0">{
        openaiRequest := &amp;dto.GeneralOpenAIRequest{
                Model:  info.UpstreamModelName,
                Stream: info.IsStream,
        }

        // 转换 messages
        var messages []dto.Message
        for _, content := range geminiRequest.Contents </span><span class="cov0" title="0">{
                message := dto.Message{
                        Role: convertGeminiRoleToOpenAI(content.Role),
                }

                // 处理 parts
                var mediaContents []dto.MediaContent
                var toolCalls []dto.ToolCallRequest
                for _, part := range content.Parts </span><span class="cov0" title="0">{
                        if part.Text != "" </span><span class="cov0" title="0">{
                                mediaContent := dto.MediaContent{
                                        Type: "text",
                                        Text: part.Text,
                                }
                                mediaContents = append(mediaContents, mediaContent)
                        }</span> else<span class="cov0" title="0"> if part.InlineData != nil </span><span class="cov0" title="0">{
                                mediaContent := dto.MediaContent{
                                        Type: "image_url",
                                        ImageUrl: &amp;dto.MessageImageUrl{
                                                Url:      fmt.Sprintf("data:%s;base64,%s", part.InlineData.MimeType, part.InlineData.Data),
                                                Detail:   "auto",
                                                MimeType: part.InlineData.MimeType,
                                        },
                                }
                                mediaContents = append(mediaContents, mediaContent)
                        }</span> else<span class="cov0" title="0"> if part.FileData != nil </span><span class="cov0" title="0">{
                                mediaContent := dto.MediaContent{
                                        Type: "image_url",
                                        ImageUrl: &amp;dto.MessageImageUrl{
                                                Url:      part.FileData.FileUri,
                                                Detail:   "auto",
                                                MimeType: part.FileData.MimeType,
                                        },
                                }
                                mediaContents = append(mediaContents, mediaContent)
                        }</span> else<span class="cov0" title="0"> if part.FunctionCall != nil </span><span class="cov0" title="0">{
                                // 处理 Gemini 的工具调用
                                toolCall := dto.ToolCallRequest{
                                        ID:   fmt.Sprintf("call_%d", len(toolCalls)+1), // 生成唯一ID
                                        Type: "function",
                                        Function: dto.FunctionRequest{
                                                Name:      part.FunctionCall.FunctionName,
                                                Arguments: toJSONString(part.FunctionCall.Arguments),
                                        },
                                }
                                toolCalls = append(toolCalls, toolCall)
                        }</span> else<span class="cov0" title="0"> if part.FunctionResponse != nil </span><span class="cov0" title="0">{
                                // 处理 Gemini 的工具响应，创建单独的 tool 消息
                                toolMessage := dto.Message{
                                        Role:       "tool",
                                        ToolCallId: fmt.Sprintf("call_%d", len(toolCalls)), // 使用对应的调用ID
                                }
                                toolMessage.SetStringContent(toJSONString(part.FunctionResponse.Response))
                                messages = append(messages, toolMessage)
                        }</span>
                }

                // 设置消息内容
                <span class="cov0" title="0">if len(toolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        // 如果有工具调用，设置工具调用
                        message.SetToolCalls(toolCalls)
                }</span> else<span class="cov0" title="0"> if len(mediaContents) == 1 &amp;&amp; mediaContents[0].Type == "text" </span><span class="cov0" title="0">{
                        // 如果只有一个文本内容，直接设置字符串
                        message.Content = mediaContents[0].Text
                }</span> else<span class="cov0" title="0"> if len(mediaContents) &gt; 0 </span><span class="cov0" title="0">{
                        // 如果有多个内容或包含媒体，设置为数组
                        message.SetMediaContent(mediaContents)
                }</span>

                // 只有当消息有内容或工具调用时才添加
                <span class="cov0" title="0">if len(message.ParseContent()) &gt; 0 || len(message.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        messages = append(messages, message)
                }</span>
        }

        <span class="cov0" title="0">openaiRequest.Messages = messages

        if geminiRequest.GenerationConfig.Temperature != nil </span><span class="cov0" title="0">{
                openaiRequest.Temperature = geminiRequest.GenerationConfig.Temperature
        }</span>
        <span class="cov0" title="0">if geminiRequest.GenerationConfig.TopP &gt; 0 </span><span class="cov0" title="0">{
                openaiRequest.TopP = geminiRequest.GenerationConfig.TopP
        }</span>
        <span class="cov0" title="0">if geminiRequest.GenerationConfig.TopK &gt; 0 </span><span class="cov0" title="0">{
                openaiRequest.TopK = int(geminiRequest.GenerationConfig.TopK)
        }</span>
        <span class="cov0" title="0">if geminiRequest.GenerationConfig.MaxOutputTokens &gt; 0 </span><span class="cov0" title="0">{
                openaiRequest.MaxTokens = geminiRequest.GenerationConfig.MaxOutputTokens
        }</span>
        // gemini stop sequences 最多 5 个，openai stop 最多 4 个
        <span class="cov0" title="0">if len(geminiRequest.GenerationConfig.StopSequences) &gt; 0 </span><span class="cov0" title="0">{
                openaiRequest.Stop = geminiRequest.GenerationConfig.StopSequences[:4]
        }</span>
        <span class="cov0" title="0">if geminiRequest.GenerationConfig.CandidateCount &gt; 0 </span><span class="cov0" title="0">{
                openaiRequest.N = geminiRequest.GenerationConfig.CandidateCount
        }</span>

        // 转换工具调用
        <span class="cov0" title="0">if len(geminiRequest.GetTools()) &gt; 0 </span><span class="cov0" title="0">{
                var tools []dto.ToolCallRequest
                for _, tool := range geminiRequest.GetTools() </span><span class="cov0" title="0">{
                        if tool.FunctionDeclarations != nil </span><span class="cov0" title="0">{
                                // 将 Gemini 的 FunctionDeclarations 转换为 OpenAI 的 ToolCallRequest
                                functionDeclarations, ok := tool.FunctionDeclarations.([]dto.FunctionRequest)
                                if ok </span><span class="cov0" title="0">{
                                        for _, function := range functionDeclarations </span><span class="cov0" title="0">{
                                                openAITool := dto.ToolCallRequest{
                                                        Type: "function",
                                                        Function: dto.FunctionRequest{
                                                                Name:        function.Name,
                                                                Description: function.Description,
                                                                Parameters:  function.Parameters,
                                                        },
                                                }
                                                tools = append(tools, openAITool)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if len(tools) &gt; 0 </span><span class="cov0" title="0">{
                        openaiRequest.Tools = tools
                }</span>
        }

        // gemini system instructions
        <span class="cov0" title="0">if geminiRequest.SystemInstructions != nil </span><span class="cov0" title="0">{
                // 将系统指令作为第一条消息插入
                systemMessage := dto.Message{
                        Role:    "system",
                        Content: extractTextFromGeminiParts(geminiRequest.SystemInstructions.Parts),
                }
                openaiRequest.Messages = append([]dto.Message{systemMessage}, openaiRequest.Messages...)
        }</span>

        <span class="cov0" title="0">return openaiRequest, nil</span>
}

func convertGeminiRoleToOpenAI(geminiRole string) string <span class="cov0" title="0">{
        switch geminiRole </span>{
        case "user":<span class="cov0" title="0">
                return "user"</span>
        case "model":<span class="cov0" title="0">
                return "assistant"</span>
        case "function":<span class="cov0" title="0">
                return "function"</span>
        default:<span class="cov0" title="0">
                return "user"</span>
        }
}

func extractTextFromGeminiParts(parts []dto.GeminiPart) string <span class="cov0" title="0">{
        var texts []string
        for _, part := range parts </span><span class="cov0" title="0">{
                if part.Text != "" </span><span class="cov0" title="0">{
                        texts = append(texts, part.Text)
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(texts, "\n")</span>
}

// ResponseOpenAI2Gemini 将 OpenAI 响应转换为 Gemini 格式
func ResponseOpenAI2Gemini(openAIResponse *dto.OpenAITextResponse, info *relaycommon.RelayInfo) *dto.GeminiChatResponse <span class="cov0" title="0">{
        geminiResponse := &amp;dto.GeminiChatResponse{
                Candidates: make([]dto.GeminiChatCandidate, 0, len(openAIResponse.Choices)),
                UsageMetadata: dto.GeminiUsageMetadata{
                        PromptTokenCount:     openAIResponse.PromptTokens,
                        CandidatesTokenCount: openAIResponse.CompletionTokens,
                        TotalTokenCount:      openAIResponse.PromptTokens + openAIResponse.CompletionTokens,
                },
        }

        for _, choice := range openAIResponse.Choices </span><span class="cov0" title="0">{
                candidate := dto.GeminiChatCandidate{
                        Index:         int64(choice.Index),
                        SafetyRatings: []dto.GeminiChatSafetyRating{},
                }

                // 设置结束原因
                var finishReason string
                switch choice.FinishReason </span>{
                case "stop":<span class="cov0" title="0">
                        finishReason = "STOP"</span>
                case "length":<span class="cov0" title="0">
                        finishReason = "MAX_TOKENS"</span>
                case "content_filter":<span class="cov0" title="0">
                        finishReason = "SAFETY"</span>
                case "tool_calls":<span class="cov0" title="0">
                        finishReason = "STOP"</span>
                default:<span class="cov0" title="0">
                        finishReason = "STOP"</span>
                }
                <span class="cov0" title="0">candidate.FinishReason = &amp;finishReason

                // 转换消息内容
                content := dto.GeminiChatContent{
                        Role:  "model",
                        Parts: make([]dto.GeminiPart, 0),
                }

                // 处理工具调用
                toolCalls := choice.Message.ParseToolCalls()
                if len(toolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        for _, toolCall := range toolCalls </span><span class="cov0" title="0">{
                                // 解析参数
                                var args map[string]interface{}
                                if toolCall.Function.Arguments != "" </span><span class="cov0" title="0">{
                                        if err := json.Unmarshal([]byte(toolCall.Function.Arguments), &amp;args); err != nil </span><span class="cov0" title="0">{
                                                args = map[string]interface{}{"arguments": toolCall.Function.Arguments}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        args = make(map[string]interface{})
                                }</span>

                                <span class="cov0" title="0">part := dto.GeminiPart{
                                        FunctionCall: &amp;dto.FunctionCall{
                                                FunctionName: toolCall.Function.Name,
                                                Arguments:    args,
                                        },
                                }
                                content.Parts = append(content.Parts, part)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // 处理文本内容
                        textContent := choice.Message.StringContent()
                        if textContent != "" </span><span class="cov0" title="0">{
                                part := dto.GeminiPart{
                                        Text: textContent,
                                }
                                content.Parts = append(content.Parts, part)
                        }</span>
                }

                <span class="cov0" title="0">candidate.Content = content
                geminiResponse.Candidates = append(geminiResponse.Candidates, candidate)</span>
        }

        <span class="cov0" title="0">return geminiResponse</span>
}

// StreamResponseOpenAI2Gemini 将 OpenAI 流式响应转换为 Gemini 格式
func StreamResponseOpenAI2Gemini(openAIResponse *dto.ChatCompletionsStreamResponse, info *relaycommon.RelayInfo) *dto.GeminiChatResponse <span class="cov0" title="0">{
        // 检查是否有实际内容或结束标志
        hasContent := false
        hasFinishReason := false
        for _, choice := range openAIResponse.Choices </span><span class="cov0" title="0">{
                if len(choice.Delta.GetContentString()) &gt; 0 || (choice.Delta.ToolCalls != nil &amp;&amp; len(choice.Delta.ToolCalls) &gt; 0) </span><span class="cov0" title="0">{
                        hasContent = true
                }</span>
                <span class="cov0" title="0">if choice.FinishReason != nil </span><span class="cov0" title="0">{
                        hasFinishReason = true
                }</span>
        }

        // 如果没有实际内容且没有结束标志，跳过。主要针对 openai 流响应开头的空数据
        <span class="cov0" title="0">if !hasContent &amp;&amp; !hasFinishReason </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">geminiResponse := &amp;dto.GeminiChatResponse{
                Candidates: make([]dto.GeminiChatCandidate, 0, len(openAIResponse.Choices)),
                UsageMetadata: dto.GeminiUsageMetadata{
                        PromptTokenCount:     info.PromptTokens,
                        CandidatesTokenCount: 0, // 流式响应中可能没有完整的 usage 信息
                        TotalTokenCount:      info.PromptTokens,
                },
        }

        for _, choice := range openAIResponse.Choices </span><span class="cov0" title="0">{
                candidate := dto.GeminiChatCandidate{
                        Index:         int64(choice.Index),
                        SafetyRatings: []dto.GeminiChatSafetyRating{},
                }

                // 设置结束原因
                if choice.FinishReason != nil </span><span class="cov0" title="0">{
                        var finishReason string
                        switch *choice.FinishReason </span>{
                        case "stop":<span class="cov0" title="0">
                                finishReason = "STOP"</span>
                        case "length":<span class="cov0" title="0">
                                finishReason = "MAX_TOKENS"</span>
                        case "content_filter":<span class="cov0" title="0">
                                finishReason = "SAFETY"</span>
                        case "tool_calls":<span class="cov0" title="0">
                                finishReason = "STOP"</span>
                        default:<span class="cov0" title="0">
                                finishReason = "STOP"</span>
                        }
                        <span class="cov0" title="0">candidate.FinishReason = &amp;finishReason</span>
                }

                // 转换消息内容
                <span class="cov0" title="0">content := dto.GeminiChatContent{
                        Role:  "model",
                        Parts: make([]dto.GeminiPart, 0),
                }

                // 处理工具调用
                if choice.Delta.ToolCalls != nil </span><span class="cov0" title="0">{
                        for _, toolCall := range choice.Delta.ToolCalls </span><span class="cov0" title="0">{
                                // 解析参数
                                var args map[string]interface{}
                                if toolCall.Function.Arguments != "" </span><span class="cov0" title="0">{
                                        if err := json.Unmarshal([]byte(toolCall.Function.Arguments), &amp;args); err != nil </span><span class="cov0" title="0">{
                                                args = map[string]interface{}{"arguments": toolCall.Function.Arguments}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        args = make(map[string]interface{})
                                }</span>

                                <span class="cov0" title="0">part := dto.GeminiPart{
                                        FunctionCall: &amp;dto.FunctionCall{
                                                FunctionName: toolCall.Function.Name,
                                                Arguments:    args,
                                        },
                                }
                                content.Parts = append(content.Parts, part)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // 处理文本内容
                        textContent := choice.Delta.GetContentString()
                        if textContent != "" </span><span class="cov0" title="0">{
                                part := dto.GeminiPart{
                                        Text: textContent,
                                }
                                content.Parts = append(content.Parts, part)
                        }</span>
                }

                <span class="cov0" title="0">candidate.Content = content
                geminiResponse.Candidates = append(geminiResponse.Candidates, candidate)</span>
        }

        <span class="cov0" title="0">return geminiResponse</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package service

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/setting/system_setting"
)

// WorkerRequest Worker请求的数据结构
type WorkerRequest struct {
        URL     string            `json:"url"`
        Key     string            `json:"key"`
        Method  string            `json:"method,omitempty"`
        Headers map[string]string `json:"headers,omitempty"`
        Body    json.RawMessage   `json:"body,omitempty"`
}

// DoWorkerRequest 通过Worker发送请求
func DoWorkerRequest(req *WorkerRequest) (*http.Response, error) <span class="cov0" title="0">{
        if !system_setting.EnableWorker() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("worker not enabled")
        }</span>
        <span class="cov0" title="0">if !system_setting.WorkerAllowHttpImageRequestEnabled &amp;&amp; !strings.HasPrefix(req.URL, "https") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only support https url")
        }</span>

        // SSRF防护：验证请求URL
        <span class="cov0" title="0">fetchSetting := system_setting.GetFetchSetting()
        if err := common.ValidateURLWithFetchSetting(req.URL, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request reject: %v", err)
        }</span>

        <span class="cov0" title="0">workerUrl := system_setting.WorkerUrl
        if !strings.HasSuffix(workerUrl, "/") </span><span class="cov0" title="0">{
                workerUrl += "/"
        }</span>

        // 序列化worker请求数据
        <span class="cov0" title="0">workerPayload, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal worker payload: %v", err)
        }</span>

        <span class="cov0" title="0">return GetHttpClient().Post(workerUrl, "application/json", bytes.NewBuffer(workerPayload))</span>
}

func DoDownloadRequest(originUrl string, reason ...string) (resp *http.Response, err error) <span class="cov0" title="0">{
        if system_setting.EnableWorker() </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("downloading file from worker: %s, reason: %s", originUrl, strings.Join(reason, ", ")))
                req := &amp;WorkerRequest{
                        URL: originUrl,
                        Key: system_setting.WorkerValidKey,
                }
                return DoWorkerRequest(req)
        }</span> else<span class="cov0" title="0"> {
                // SSRF防护：验证请求URL（非Worker模式）
                fetchSetting := system_setting.GetFetchSetting()
                if err := common.ValidateURLWithFetchSetting(originUrl, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("request reject: %v", err)
                }</span>

                <span class="cov0" title="0">common.SysLog(fmt.Sprintf("downloading from origin: %s, reason: %s", common.MaskSensitiveInfo(originUrl), strings.Join(reason, ", ")))
                return GetHttpClient().Get(originUrl)</span>
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package service

import (
        "github.com/QuantumNous/new-api/setting/operation_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"
)

func GetCallbackAddress() string <span class="cov0" title="0">{
        if operation_setting.CustomCallbackAddress == "" </span><span class="cov0" title="0">{
                return system_setting.ServerAddress
        }</span>
        <span class="cov0" title="0">return operation_setting.CustomCallbackAddress</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/types"
)

func MidjourneyErrorWrapper(code int, desc string) *dto.MidjourneyResponse <span class="cov0" title="0">{
        return &amp;dto.MidjourneyResponse{
                Code:        code,
                Description: desc,
        }
}</span>

func MidjourneyErrorWithStatusCodeWrapper(code int, desc string, statusCode int) *dto.MidjourneyResponseWithStatusCode <span class="cov0" title="0">{
        return &amp;dto.MidjourneyResponseWithStatusCode{
                StatusCode: statusCode,
                Response:   *MidjourneyErrorWrapper(code, desc),
        }
}</span>

//// OpenAIErrorWrapper wraps an error into an OpenAIErrorWithStatusCode
//func OpenAIErrorWrapper(err error, code string, statusCode int) *dto.OpenAIErrorWithStatusCode {
//        text := err.Error()
//        lowerText := strings.ToLower(text)
//        if !strings.HasPrefix(lowerText, "get file base64 from url") &amp;&amp; !strings.HasPrefix(lowerText, "mime type is not supported") {
//                if strings.Contains(lowerText, "post") || strings.Contains(lowerText, "dial") || strings.Contains(lowerText, "http") {
//                        common.SysLog(fmt.Sprintf("error: %s", text))
//                        text = "请求上游地址失败"
//                }
//        }
//        openAIError := dto.OpenAIError{
//                Message: text,
//                Type:    "new_api_error",
//                Code:    code,
//        }
//        return &amp;dto.OpenAIErrorWithStatusCode{
//                Error:      openAIError,
//                StatusCode: statusCode,
//        }
//}
//
//func OpenAIErrorWrapperLocal(err error, code string, statusCode int) *dto.OpenAIErrorWithStatusCode {
//        openaiErr := OpenAIErrorWrapper(err, code, statusCode)
//        openaiErr.LocalError = true
//        return openaiErr
//}

func ClaudeErrorWrapper(err error, code string, statusCode int) *dto.ClaudeErrorWithStatusCode <span class="cov0" title="0">{
        text := err.Error()
        lowerText := strings.ToLower(text)
        if !strings.HasPrefix(lowerText, "get file base64 from url") </span><span class="cov0" title="0">{
                if strings.Contains(lowerText, "post") || strings.Contains(lowerText, "dial") || strings.Contains(lowerText, "http") </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("error: %s", text))
                        text = "请求上游地址失败"
                }</span>
        }
        <span class="cov0" title="0">claudeError := types.ClaudeError{
                Message: text,
                Type:    "new_api_error",
        }
        return &amp;dto.ClaudeErrorWithStatusCode{
                Error:      claudeError,
                StatusCode: statusCode,
        }</span>
}

func ClaudeErrorWrapperLocal(err error, code string, statusCode int) *dto.ClaudeErrorWithStatusCode <span class="cov0" title="0">{
        claudeErr := ClaudeErrorWrapper(err, code, statusCode)
        claudeErr.LocalError = true
        return claudeErr
}</span>

func RelayErrorHandler(ctx context.Context, resp *http.Response, showBodyWhenFail bool) (newApiErr *types.NewAPIError) <span class="cov0" title="0">{
        newApiErr = types.InitOpenAIError(types.ErrorCodeBadResponseStatusCode, resp.StatusCode)

        responseBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">CloseResponseBodyGracefully(resp)
        var errResponse dto.GeneralErrorResponse

        err = common.Unmarshal(responseBody, &amp;errResponse)
        if err != nil </span><span class="cov0" title="0">{
                if showBodyWhenFail </span><span class="cov0" title="0">{
                        newApiErr.Err = fmt.Errorf("bad response status code %d, body: %s", resp.StatusCode, string(responseBody))
                }</span> else<span class="cov0" title="0"> {
                        if common.DebugEnabled </span><span class="cov0" title="0">{
                                logger.LogInfo(ctx, fmt.Sprintf("bad response status code %d, body: %s", resp.StatusCode, string(responseBody)))
                        }</span>
                        <span class="cov0" title="0">newApiErr.Err = fmt.Errorf("bad response status code %d", resp.StatusCode)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if errResponse.Error.Message != "" </span><span class="cov0" title="0">{
                // General format error (OpenAI, Anthropic, Gemini, etc.)
                newApiErr = types.WithOpenAIError(errResponse.Error, resp.StatusCode)
        }</span> else<span class="cov0" title="0"> {
                newApiErr = types.NewOpenAIError(errors.New(errResponse.ToMessage()), types.ErrorCodeBadResponseStatusCode, resp.StatusCode)
        }</span>
        <span class="cov0" title="0">return</span>
}

func ResetStatusCode(newApiErr *types.NewAPIError, statusCodeMappingStr string) <span class="cov0" title="0">{
        if statusCodeMappingStr == "" || statusCodeMappingStr == "{}" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">statusCodeMapping := make(map[string]string)
        err := common.Unmarshal([]byte(statusCodeMappingStr), &amp;statusCodeMapping)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if newApiErr.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">codeStr := strconv.Itoa(newApiErr.StatusCode)
        if _, ok := statusCodeMapping[codeStr]; ok </span><span class="cov0" title="0">{
                intCode, _ := strconv.Atoi(statusCodeMapping[codeStr])
                newApiErr.StatusCode = intCode
        }</span>
}

func TaskErrorWrapperLocal(err error, code string, statusCode int) *dto.TaskError <span class="cov0" title="0">{
        openaiErr := TaskErrorWrapper(err, code, statusCode)
        openaiErr.LocalError = true
        return openaiErr
}</span>

func TaskErrorWrapper(err error, code string, statusCode int) *dto.TaskError <span class="cov0" title="0">{
        text := err.Error()
        lowerText := strings.ToLower(text)
        if strings.Contains(lowerText, "post") || strings.Contains(lowerText, "dial") || strings.Contains(lowerText, "http") </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("error: %s", text))
                //text = "请求上游地址失败"
                text = common.MaskSensitiveInfo(text)
        }</span>
        //避免暴露内部错误
        <span class="cov0" title="0">taskError := &amp;dto.TaskError{
                Code:       code,
                Message:    text,
                StatusCode: statusCode,
                Error:      err,
        }

        return taskError</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package service

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "image"
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"
        "io"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/types"

        "github.com/gin-gonic/gin"
)

// GetFileTypeFromUrl 获取文件类型，返回 mime type， 例如 image/jpeg, image/png, image/gif, image/bmp, image/tiff, application/pdf
// 如果获取失败，返回 application/octet-stream
func GetFileTypeFromUrl(c *gin.Context, url string, reason ...string) (string, error) <span class="cov0" title="0">{
        response, err := DoDownloadRequest(url, []string{"get_mime_type", strings.Join(reason, ", ")}...)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("fail to get file type from url: %s, error: %s", url, err.Error()))
                return "", err
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                logger.LogError(c, fmt.Sprintf("failed to download file from %s, status code: %d", url, response.StatusCode))
                return "", fmt.Errorf("failed to download file, status code: %d", response.StatusCode)
        }</span>

        <span class="cov0" title="0">if headerType := strings.TrimSpace(response.Header.Get("Content-Type")); headerType != "" </span><span class="cov0" title="0">{
                if i := strings.Index(headerType, ";"); i != -1 </span><span class="cov0" title="0">{
                        headerType = headerType[:i]
                }</span>
                <span class="cov0" title="0">if headerType != "application/octet-stream" </span><span class="cov0" title="0">{
                        return headerType, nil
                }</span>
        }

        <span class="cov0" title="0">if cd := response.Header.Get("Content-Disposition"); cd != "" </span><span class="cov0" title="0">{
                parts := strings.Split(cd, ";")
                for _, part := range parts </span><span class="cov0" title="0">{
                        part = strings.TrimSpace(part)
                        if strings.HasPrefix(strings.ToLower(part), "filename=") </span><span class="cov0" title="0">{
                                name := strings.TrimSpace(strings.TrimPrefix(part, "filename="))
                                if len(name) &gt; 2 &amp;&amp; name[0] == '"' &amp;&amp; name[len(name)-1] == '"' </span><span class="cov0" title="0">{
                                        name = name[1 : len(name)-1]
                                }</span>
                                <span class="cov0" title="0">if dot := strings.LastIndex(name, "."); dot != -1 &amp;&amp; dot+1 &lt; len(name) </span><span class="cov0" title="0">{
                                        ext := strings.ToLower(name[dot+1:])
                                        if ext != "" </span><span class="cov0" title="0">{
                                                mt := GetMimeTypeByExtension(ext)
                                                if mt != "application/octet-stream" </span><span class="cov0" title="0">{
                                                        return mt, nil
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov0" title="0">cleanedURL := url
        if q := strings.Index(cleanedURL, "?"); q != -1 </span><span class="cov0" title="0">{
                cleanedURL = cleanedURL[:q]
        }</span>
        <span class="cov0" title="0">if slash := strings.LastIndex(cleanedURL, "/"); slash != -1 &amp;&amp; slash+1 &lt; len(cleanedURL) </span><span class="cov0" title="0">{
                last := cleanedURL[slash+1:]
                if dot := strings.LastIndex(last, "."); dot != -1 &amp;&amp; dot+1 &lt; len(last) </span><span class="cov0" title="0">{
                        ext := strings.ToLower(last[dot+1:])
                        if ext != "" </span><span class="cov0" title="0">{
                                mt := GetMimeTypeByExtension(ext)
                                if mt != "application/octet-stream" </span><span class="cov0" title="0">{
                                        return mt, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var readData []byte
        limits := []int{512, 8 * 1024, 24 * 1024, 64 * 1024}
        for _, limit := range limits </span><span class="cov0" title="0">{
                logger.LogDebug(c, fmt.Sprintf("Trying to read %d bytes to determine file type", limit))
                if len(readData) &lt; limit </span><span class="cov0" title="0">{
                        need := limit - len(readData)
                        tmp := make([]byte, need)
                        n, _ := io.ReadFull(response.Body, tmp)
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                readData = append(readData, tmp[:n]...)
                        }</span>
                }

                <span class="cov0" title="0">if len(readData) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sniffed := http.DetectContentType(readData)
                if sniffed != "" &amp;&amp; sniffed != "application/octet-stream" </span><span class="cov0" title="0">{
                        return sniffed, nil
                }</span>

                <span class="cov0" title="0">if _, format, err := image.DecodeConfig(bytes.NewReader(readData)); err == nil </span><span class="cov0" title="0">{
                        switch strings.ToLower(format) </span>{
                        case "jpeg", "jpg":<span class="cov0" title="0">
                                return "image/jpeg", nil</span>
                        case "png":<span class="cov0" title="0">
                                return "image/png", nil</span>
                        case "gif":<span class="cov0" title="0">
                                return "image/gif", nil</span>
                        case "bmp":<span class="cov0" title="0">
                                return "image/bmp", nil</span>
                        case "tiff":<span class="cov0" title="0">
                                return "image/tiff", nil</span>
                        default:<span class="cov0" title="0">
                                if format != "" </span><span class="cov0" title="0">{
                                        return "image/" + strings.ToLower(format), nil
                                }</span>
                        }
                }
        }

        // Fallback
        <span class="cov0" title="0">return "application/octet-stream", nil</span>
}

func GetFileBase64FromUrl(c *gin.Context, url string, reason ...string) (*types.LocalFileData, error) <span class="cov0" title="0">{
        contextKey := fmt.Sprintf("file_download_%s", common.GenerateHMAC(url))

        // Check if the file has already been downloaded in this request
        if cachedData, exists := c.Get(contextKey); exists </span><span class="cov0" title="0">{
                if common.DebugEnabled </span><span class="cov0" title="0">{
                        logger.LogDebug(c, fmt.Sprintf("Using cached file data for URL: %s", url))
                }</span>
                <span class="cov0" title="0">return cachedData.(*types.LocalFileData), nil</span>
        }

        <span class="cov0" title="0">var maxFileSize = constant.MaxFileDownloadMB * 1024 * 1024

        resp, err := DoDownloadRequest(url, reason...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Always use LimitReader to prevent oversized downloads
        fileBytes, err := io.ReadAll(io.LimitReader(resp.Body, int64(maxFileSize+1)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Check actual size after reading
        <span class="cov0" title="0">if len(fileBytes) &gt; maxFileSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file size exceeds maximum allowed size: %dMB", constant.MaxFileDownloadMB)
        }</span>

        // Convert to base64
        <span class="cov0" title="0">base64Data := base64.StdEncoding.EncodeToString(fileBytes)

        mimeType := resp.Header.Get("Content-Type")
        if len(strings.Split(mimeType, ";")) &gt; 1 </span><span class="cov0" title="0">{
                // If Content-Type has parameters, take the first part
                mimeType = strings.Split(mimeType, ";")[0]
        }</span>
        <span class="cov0" title="0">if mimeType == "application/octet-stream" </span><span class="cov0" title="0">{
                logger.LogDebug(c, fmt.Sprintf("MIME type is application/octet-stream for URL: %s", url))
                // try to guess the MIME type from the url last segment
                urlParts := strings.Split(url, "/")
                if len(urlParts) &gt; 0 </span><span class="cov0" title="0">{
                        lastSegment := urlParts[len(urlParts)-1]
                        if strings.Contains(lastSegment, ".") </span><span class="cov0" title="0">{
                                // Extract the file extension
                                filename := strings.Split(lastSegment, ".")
                                if len(filename) &gt; 1 </span><span class="cov0" title="0">{
                                        ext := strings.ToLower(filename[len(filename)-1])
                                        // Guess MIME type based on file extension
                                        mimeType = GetMimeTypeByExtension(ext)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // try to guess the MIME type from the file extension
                        fileName := resp.Header.Get("Content-Disposition")
                        if fileName != "" </span><span class="cov0" title="0">{
                                // Extract the filename from the Content-Disposition header
                                parts := strings.Split(fileName, ";")
                                for _, part := range parts </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(strings.TrimSpace(part), "filename=") </span><span class="cov0" title="0">{
                                                fileName = strings.TrimSpace(strings.TrimPrefix(part, "filename="))
                                                // Remove quotes if present
                                                if len(fileName) &gt; 2 &amp;&amp; fileName[0] == '"' &amp;&amp; fileName[len(fileName)-1] == '"' </span><span class="cov0" title="0">{
                                                        fileName = fileName[1 : len(fileName)-1]
                                                }</span>
                                                // Guess MIME type based on file extension
                                                <span class="cov0" title="0">if ext := strings.ToLower(strings.TrimPrefix(fileName, ".")); ext != "" </span><span class="cov0" title="0">{
                                                        mimeType = GetMimeTypeByExtension(ext)
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">data := &amp;types.LocalFileData{
                Base64Data: base64Data,
                MimeType:   mimeType,
                Size:       int64(len(fileBytes)),
        }
        // Store the file data in the context to avoid re-downloading
        c.Set(contextKey, data)

        return data, nil</span>
}

func GetMimeTypeByExtension(ext string) string <span class="cov0" title="0">{
        // Convert to lowercase for case-insensitive comparison
        ext = strings.ToLower(ext)
        switch ext </span>{
        // Text files
        case "txt", "md", "markdown", "csv", "json", "xml", "html", "htm":<span class="cov0" title="0">
                return "text/plain"</span>

        // Image files
        case "jpg", "jpeg":<span class="cov0" title="0">
                return "image/jpeg"</span>
        case "png":<span class="cov0" title="0">
                return "image/png"</span>
        case "gif":<span class="cov0" title="0">
                return "image/gif"</span>

        // Audio files
        case "mp3":<span class="cov0" title="0">
                return "audio/mp3"</span>
        case "wav":<span class="cov0" title="0">
                return "audio/wav"</span>
        case "mpeg":<span class="cov0" title="0">
                return "audio/mpeg"</span>

        // Video files
        case "mp4":<span class="cov0" title="0">
                return "video/mp4"</span>
        case "wmv":<span class="cov0" title="0">
                return "video/wmv"</span>
        case "flv":<span class="cov0" title="0">
                return "video/flv"</span>
        case "mov":<span class="cov0" title="0">
                return "video/mov"</span>
        case "mpg":<span class="cov0" title="0">
                return "video/mpg"</span>
        case "avi":<span class="cov0" title="0">
                return "video/avi"</span>
        case "mpegps":<span class="cov0" title="0">
                return "video/mpegps"</span>

        // Document files
        case "pdf":<span class="cov0" title="0">
                return "application/pdf"</span>

        default:<span class="cov0" title="0">
                return "application/octet-stream"</span> // Default for unknown types
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package service

import (
        "strings"

        "github.com/QuantumNous/new-api/setting"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
)

func GetUserUsableGroups(userGroup string) map[string]string <span class="cov0" title="0">{
        groupsCopy := setting.GetUserUsableGroupsCopy()
        if userGroup != "" </span><span class="cov0" title="0">{
                specialSettings, b := ratio_setting.GetGroupRatioSetting().GroupSpecialUsableGroup.Get(userGroup)
                if b </span><span class="cov0" title="0">{
                        // 处理特殊可用分组
                        for specialGroup, desc := range specialSettings </span><span class="cov0" title="0">{
                                if strings.HasPrefix(specialGroup, "-:") </span><span class="cov0" title="0">{
                                        // 移除分组
                                        groupToRemove := strings.TrimPrefix(specialGroup, "-:")
                                        delete(groupsCopy, groupToRemove)
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(specialGroup, "+:") </span><span class="cov0" title="0">{
                                        // 添加分组
                                        groupToAdd := strings.TrimPrefix(specialGroup, "+:")
                                        groupsCopy[groupToAdd] = desc
                                }</span> else<span class="cov0" title="0"> {
                                        // 直接添加分组
                                        groupsCopy[specialGroup] = desc
                                }</span>
                        }
                }
                // 如果userGroup不在UserUsableGroups中，返回UserUsableGroups + userGroup
                <span class="cov0" title="0">if _, ok := groupsCopy[userGroup]; !ok </span><span class="cov0" title="0">{
                        groupsCopy[userGroup] = "用户分组"
                }</span>
        }
        <span class="cov0" title="0">return groupsCopy</span>
}

func GroupInUserUsableGroups(userGroup, groupName string) bool <span class="cov0" title="0">{
        _, ok := GetUserUsableGroups(userGroup)[groupName]
        return ok
}</span>

// GetUserAutoGroup 根据用户分组获取自动分组设置
func GetUserAutoGroup(userGroup string) []string <span class="cov0" title="0">{
        groups := GetUserUsableGroups(userGroup)
        autoGroups := make([]string, 0)
        for _, group := range setting.GetAutoGroups() </span><span class="cov0" title="0">{
                if _, ok := groups[group]; ok </span><span class="cov0" title="0">{
                        autoGroups = append(autoGroups, group)
                }</span>
        }
        <span class="cov0" title="0">return autoGroups</span>
}

// GetUserGroupRatio 获取用户使用某个分组的倍率
// userGroup 用户分组
// group 需要获取倍率的分组
func GetUserGroupRatio(userGroup, group string) float64 <span class="cov0" title="0">{
        ratio, ok := ratio_setting.GetGroupGroupRatio(userGroup, group)
        if ok </span><span class="cov0" title="0">{
                return ratio
        }</span>
        <span class="cov0" title="0">return ratio_setting.GetGroupRatio(group)</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package service

import (
        "bytes"
        "fmt"
        "io"
        "net/http"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"

        "github.com/gin-gonic/gin"
)

func CloseResponseBodyGracefully(httpResponse *http.Response) <span class="cov0" title="0">{
        if httpResponse == nil || httpResponse.Body == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err := httpResponse.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                common.SysError("failed to close response body: " + err.Error())
        }</span>
}

func IOCopyBytesGracefully(c *gin.Context, src *http.Response, data []byte) <span class="cov0" title="0">{
        if c.Writer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">body := io.NopCloser(bytes.NewBuffer(data))

        // We shouldn't set the header before we parse the response body, because the parse part may fail.
        // And then we will have to send an error response, but in this case, the header has already been set.
        // So the httpClient will be confused by the response.
        // For example, Postman will report error, and we cannot check the response at all.
        if src != nil </span><span class="cov0" title="0">{
                for k, v := range src.Header </span><span class="cov0" title="0">{
                        // avoid setting Content-Length
                        if k == "Content-Length" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">c.Writer.Header().Set(k, v[0])</span>
                }
        }

        // set Content-Length header manually BEFORE calling WriteHeader
        <span class="cov0" title="0">c.Writer.Header().Set("Content-Length", fmt.Sprintf("%d", len(data)))

        // Write header with status code (this sends the headers)
        if src != nil </span><span class="cov0" title="0">{
                c.Writer.WriteHeader(src.StatusCode)
        }</span> else<span class="cov0" title="0"> {
                c.Writer.WriteHeader(http.StatusOK)
        }</span>

        <span class="cov0" title="0">_, err := io.Copy(c.Writer, body)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError(c, fmt.Sprintf("failed to copy response body: %s", err.Error()))
        }</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package service

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/setting/system_setting"

        "golang.org/x/net/proxy"
)

var (
        httpClient      *http.Client
        proxyClientLock sync.Mutex
        proxyClients    = make(map[string]*http.Client)
)

func checkRedirect(req *http.Request, via []*http.Request) error <span class="cov0" title="0">{
        fetchSetting := system_setting.GetFetchSetting()
        urlStr := req.URL.String()
        if err := common.ValidateURLWithFetchSetting(urlStr, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redirect to %s blocked: %v", urlStr, err)
        }</span>
        <span class="cov0" title="0">if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("stopped after 10 redirects")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func InitHttpClient() <span class="cov0" title="0">{
        if common.RelayTimeout == 0 </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{
                        CheckRedirect: checkRedirect,
                }
        }</span> else<span class="cov0" title="0"> {
                httpClient = &amp;http.Client{
                        Timeout:       time.Duration(common.RelayTimeout) * time.Second,
                        CheckRedirect: checkRedirect,
                }
        }</span>
}

func GetHttpClient() *http.Client <span class="cov0" title="0">{
        return httpClient
}</span>

// ResetProxyClientCache 清空代理客户端缓存，确保下次使用时重新初始化
func ResetProxyClientCache() <span class="cov0" title="0">{
        proxyClientLock.Lock()
        defer proxyClientLock.Unlock()
        for _, client := range proxyClients </span><span class="cov0" title="0">{
                if transport, ok := client.Transport.(*http.Transport); ok &amp;&amp; transport != nil </span><span class="cov0" title="0">{
                        transport.CloseIdleConnections()
                }</span>
        }
        <span class="cov0" title="0">proxyClients = make(map[string]*http.Client)</span>
}

// NewProxyHttpClient 创建支持代理的 HTTP 客户端
func NewProxyHttpClient(proxyURL string) (*http.Client, error) <span class="cov0" title="0">{
        if proxyURL == "" </span><span class="cov0" title="0">{
                return http.DefaultClient, nil
        }</span>

        <span class="cov0" title="0">proxyClientLock.Lock()
        if client, ok := proxyClients[proxyURL]; ok </span><span class="cov0" title="0">{
                proxyClientLock.Unlock()
                return client, nil
        }</span>
        <span class="cov0" title="0">proxyClientLock.Unlock()

        parsedURL, err := url.Parse(proxyURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch parsedURL.Scheme </span>{
        case "http", "https":<span class="cov0" title="0">
                client := &amp;http.Client{
                        Transport: &amp;http.Transport{
                                Proxy: http.ProxyURL(parsedURL),
                        },
                        CheckRedirect: checkRedirect,
                }
                client.Timeout = time.Duration(common.RelayTimeout) * time.Second
                proxyClientLock.Lock()
                proxyClients[proxyURL] = client
                proxyClientLock.Unlock()
                return client, nil</span>

        case "socks5", "socks5h":<span class="cov0" title="0">
                // 获取认证信息
                var auth *proxy.Auth
                if parsedURL.User != nil </span><span class="cov0" title="0">{
                        auth = &amp;proxy.Auth{
                                User:     parsedURL.User.Username(),
                                Password: "",
                        }
                        if password, ok := parsedURL.User.Password(); ok </span><span class="cov0" title="0">{
                                auth.Password = password
                        }</span>
                }

                // 创建 SOCKS5 代理拨号器
                // proxy.SOCKS5 使用 tcp 参数，所有 TCP 连接包括 DNS 查询都将通过代理进行。行为与 socks5h 相同
                <span class="cov0" title="0">dialer, err := proxy.SOCKS5("tcp", parsedURL.Host, auth, proxy.Direct)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">client := &amp;http.Client{
                        Transport: &amp;http.Transport{
                                DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                                        return dialer.Dial(network, addr)
                                }</span>,
                        },
                        CheckRedirect: checkRedirect,
                }
                <span class="cov0" title="0">client.Timeout = time.Duration(common.RelayTimeout) * time.Second
                proxyClientLock.Lock()
                proxyClients[proxyURL] = client
                proxyClientLock.Unlock()
                return client, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported proxy scheme: %s, must be http, https, socks5 or socks5h", parsedURL.Scheme)</span>
        }
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package service

import (
        "bytes"
        "encoding/base64"
        "errors"
        "fmt"
        "image"
        "io"
        "net/http"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"

        "golang.org/x/image/webp"
)

// return image.Config, format, clean base64 string, error
func DecodeBase64ImageData(base64String string) (image.Config, string, string, error) <span class="cov0" title="0">{
        // 去除base64数据的URL前缀（如果有）
        if idx := strings.Index(base64String, ","); idx != -1 </span><span class="cov0" title="0">{
                base64String = base64String[idx+1:]
        }</span>

        <span class="cov0" title="0">if len(base64String) == 0 </span><span class="cov0" title="0">{
                return image.Config{}, "", "", errors.New("base64 string is empty")
        }</span>

        // 将base64字符串解码为字节切片
        <span class="cov0" title="0">decodedData, err := base64.StdEncoding.DecodeString(base64String)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error: Failed to decode base64 string")
                return image.Config{}, "", "", fmt.Errorf("failed to decode base64 string: %s", err.Error())
        }</span>

        // 创建一个bytes.Buffer用于存储解码后的数据
        <span class="cov0" title="0">reader := bytes.NewReader(decodedData)
        config, format, err := getImageConfig(reader)
        return config, format, base64String, err</span>
}

func DecodeBase64FileData(base64String string) (string, string, error) <span class="cov0" title="0">{
        var mimeType string
        var idx int
        idx = strings.Index(base64String, ",")
        if idx == -1 </span><span class="cov0" title="0">{
                _, file_type, base64, err := DecodeBase64ImageData(base64String)
                return "image/" + file_type, base64, err
        }</span>
        <span class="cov0" title="0">mimeType = base64String[:idx]
        base64String = base64String[idx+1:]
        idx = strings.Index(mimeType, ";")
        if idx == -1 </span><span class="cov0" title="0">{
                _, file_type, base64, err := DecodeBase64ImageData(base64String)
                return "image/" + file_type, base64, err
        }</span>
        <span class="cov0" title="0">mimeType = mimeType[:idx]
        idx = strings.Index(mimeType, ":")
        if idx == -1 </span><span class="cov0" title="0">{
                _, file_type, base64, err := DecodeBase64ImageData(base64String)
                return "image/" + file_type, base64, err
        }</span>
        <span class="cov0" title="0">mimeType = mimeType[idx+1:]
        return mimeType, base64String, nil</span>
}

// GetImageFromUrl 获取图片的类型和base64编码的数据
func GetImageFromUrl(url string) (mimeType string, data string, err error) <span class="cov0" title="0">{
        resp, err := DoDownloadRequest(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to download image: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check HTTP status code
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to download image: HTTP %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")
        if contentType != "application/octet-stream" &amp;&amp; !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid content type: %s, required image/*", contentType)
        }</span>
        <span class="cov0" title="0">maxImageSize := int64(constant.MaxFileDownloadMB * 1024 * 1024)

        // Check Content-Length if available
        if resp.ContentLength &gt; maxImageSize </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("image size %d exceeds maximum allowed size of %d bytes", resp.ContentLength, maxImageSize)
        }</span>

        // Use LimitReader to prevent reading oversized images
        <span class="cov0" title="0">limitReader := io.LimitReader(resp.Body, maxImageSize)
        buffer := &amp;bytes.Buffer{}

        written, err := io.Copy(buffer, limitReader)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to read image data: %w", err)
        }</span>
        <span class="cov0" title="0">if written &gt;= maxImageSize </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("image size exceeds maximum allowed size of %d bytes", maxImageSize)
        }</span>

        <span class="cov0" title="0">data = base64.StdEncoding.EncodeToString(buffer.Bytes())
        mimeType = contentType

        // Handle application/octet-stream type
        if mimeType == "application/octet-stream" </span><span class="cov0" title="0">{
                _, format, _, err := DecodeBase64ImageData(data)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>
                <span class="cov0" title="0">mimeType = "image/" + format</span>
        }

        <span class="cov0" title="0">return mimeType, data, nil</span>
}

func DecodeUrlImageData(imageUrl string) (image.Config, string, error) <span class="cov0" title="0">{
        response, err := DoDownloadRequest(imageUrl)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("fail to get image from url: %s", err.Error()))
                return image.Config{}, "", err
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                err = errors.New(fmt.Sprintf("fail to get image from url: %s", response.Status))
                return image.Config{}, "", err
        }</span>

        <span class="cov0" title="0">mimeType := response.Header.Get("Content-Type")

        if mimeType != "application/octet-stream" &amp;&amp; !strings.HasPrefix(mimeType, "image/") </span><span class="cov0" title="0">{
                return image.Config{}, "", fmt.Errorf("invalid content type: %s, required image/*", mimeType)
        }</span>

        <span class="cov0" title="0">var readData []byte
        for _, limit := range []int64{1024 * 8, 1024 * 24, 1024 * 64} </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("try to decode image config with limit: %d", limit))

                // 从response.Body读取更多的数据直到达到当前的限制
                additionalData := make([]byte, limit-int64(len(readData)))
                n, _ := io.ReadFull(response.Body, additionalData)
                readData = append(readData, additionalData[:n]...)

                // 使用io.MultiReader组合已经读取的数据和response.Body
                limitReader := io.MultiReader(bytes.NewReader(readData), response.Body)

                var config image.Config
                var format string
                config, format, err = getImageConfig(limitReader)
                if err == nil </span><span class="cov0" title="0">{
                        return config, format, nil
                }</span>
        }

        <span class="cov0" title="0">return image.Config{}, "", err</span> // 返回最后一个错误
}

func getImageConfig(reader io.Reader) (image.Config, string, error) <span class="cov0" title="0">{
        // 读取图片的头部信息来获取图片尺寸
        config, format, err := image.DecodeConfig(reader)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New(fmt.Sprintf("fail to decode image config(gif, jpg, png): %s", err.Error()))
                common.SysLog(err.Error())
                config, err = webp.DecodeConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.New(fmt.Sprintf("fail to decode image config(webp): %s", err.Error()))
                        common.SysLog(err.Error())
                }</span>
                <span class="cov0" title="0">format = "webp"</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return image.Config{}, "", err
        }</span>
        <span class="cov0" title="0">return config, format, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package service

import (
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        "github.com/QuantumNous/new-api/types"

        "github.com/gin-gonic/gin"
)

func appendRequestPath(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, other map[string]interface{}) <span class="cov0" title="0">{
        if other == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if ctx != nil &amp;&amp; ctx.Request != nil &amp;&amp; ctx.Request.URL != nil </span><span class="cov0" title="0">{
                if path := ctx.Request.URL.Path; path != "" </span><span class="cov0" title="0">{
                        other["request_path"] = path
                        return
                }</span>
        }
        <span class="cov0" title="0">if relayInfo != nil &amp;&amp; relayInfo.RequestURLPath != "" </span><span class="cov0" title="0">{
                path := relayInfo.RequestURLPath
                if idx := strings.Index(path, "?"); idx != -1 </span><span class="cov0" title="0">{
                        path = path[:idx]
                }</span>
                <span class="cov0" title="0">other["request_path"] = path</span>
        }
}

func GenerateTextOtherInfo(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, modelRatio, groupRatio, completionRatio float64,
        cacheTokens int, cacheRatio float64, modelPrice float64, userGroupRatio float64) map[string]interface{} <span class="cov0" title="0">{
        other := make(map[string]interface{})
        other["model_ratio"] = modelRatio
        other["group_ratio"] = groupRatio
        other["completion_ratio"] = completionRatio
        other["cache_tokens"] = cacheTokens
        other["cache_ratio"] = cacheRatio
        other["model_price"] = modelPrice
        other["user_group_ratio"] = userGroupRatio
        other["frt"] = float64(relayInfo.FirstResponseTime.UnixMilli() - relayInfo.StartTime.UnixMilli())
        if relayInfo.ReasoningEffort != "" </span><span class="cov0" title="0">{
                other["reasoning_effort"] = relayInfo.ReasoningEffort
        }</span>
        <span class="cov0" title="0">if relayInfo.IsModelMapped </span><span class="cov0" title="0">{
                other["is_model_mapped"] = true
                other["upstream_model_name"] = relayInfo.UpstreamModelName
        }</span>

        <span class="cov0" title="0">isSystemPromptOverwritten := common.GetContextKeyBool(ctx, constant.ContextKeySystemPromptOverride)
        if isSystemPromptOverwritten </span><span class="cov0" title="0">{
                other["is_system_prompt_overwritten"] = true
        }</span>

        <span class="cov0" title="0">adminInfo := make(map[string]interface{})
        adminInfo["use_channel"] = ctx.GetStringSlice("use_channel")
        isMultiKey := common.GetContextKeyBool(ctx, constant.ContextKeyChannelIsMultiKey)
        if isMultiKey </span><span class="cov0" title="0">{
                adminInfo["is_multi_key"] = true
                adminInfo["multi_key_index"] = common.GetContextKeyInt(ctx, constant.ContextKeyChannelMultiKeyIndex)
        }</span>

        <span class="cov0" title="0">isLocalCountTokens := common.GetContextKeyBool(ctx, constant.ContextKeyLocalCountTokens)
        if isLocalCountTokens </span><span class="cov0" title="0">{
                adminInfo["local_count_tokens"] = isLocalCountTokens
        }</span>

        <span class="cov0" title="0">other["admin_info"] = adminInfo
        appendRequestPath(ctx, relayInfo, other)
        return other</span>
}

func GenerateWssOtherInfo(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, usage *dto.RealtimeUsage, modelRatio, groupRatio, completionRatio, audioRatio, audioCompletionRatio, modelPrice, userGroupRatio float64) map[string]interface{} <span class="cov0" title="0">{
        info := GenerateTextOtherInfo(ctx, relayInfo, modelRatio, groupRatio, completionRatio, 0, 0.0, modelPrice, userGroupRatio)
        info["ws"] = true
        info["audio_input"] = usage.InputTokenDetails.AudioTokens
        info["audio_output"] = usage.OutputTokenDetails.AudioTokens
        info["text_input"] = usage.InputTokenDetails.TextTokens
        info["text_output"] = usage.OutputTokenDetails.TextTokens
        info["audio_ratio"] = audioRatio
        info["audio_completion_ratio"] = audioCompletionRatio
        return info
}</span>

func GenerateAudioOtherInfo(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, usage *dto.Usage, modelRatio, groupRatio, completionRatio, audioRatio, audioCompletionRatio, modelPrice, userGroupRatio float64) map[string]interface{} <span class="cov0" title="0">{
        info := GenerateTextOtherInfo(ctx, relayInfo, modelRatio, groupRatio, completionRatio, 0, 0.0, modelPrice, userGroupRatio)
        info["audio"] = true
        info["audio_input"] = usage.PromptTokensDetails.AudioTokens
        info["audio_output"] = usage.CompletionTokenDetails.AudioTokens
        info["text_input"] = usage.PromptTokensDetails.TextTokens
        info["text_output"] = usage.CompletionTokenDetails.TextTokens
        info["audio_ratio"] = audioRatio
        info["audio_completion_ratio"] = audioCompletionRatio
        return info
}</span>

func GenerateClaudeOtherInfo(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, modelRatio, groupRatio, completionRatio float64,
        cacheTokens int, cacheRatio float64,
        cacheCreationTokens int, cacheCreationRatio float64,
        cacheCreationTokens5m int, cacheCreationRatio5m float64,
        cacheCreationTokens1h int, cacheCreationRatio1h float64,
        modelPrice float64, userGroupRatio float64) map[string]interface{} <span class="cov0" title="0">{
        info := GenerateTextOtherInfo(ctx, relayInfo, modelRatio, groupRatio, completionRatio, cacheTokens, cacheRatio, modelPrice, userGroupRatio)
        info["claude"] = true
        info["cache_creation_tokens"] = cacheCreationTokens
        info["cache_creation_ratio"] = cacheCreationRatio
        if cacheCreationTokens5m != 0 </span><span class="cov0" title="0">{
                info["cache_creation_tokens_5m"] = cacheCreationTokens5m
                info["cache_creation_ratio_5m"] = cacheCreationRatio5m
        }</span>
        <span class="cov0" title="0">if cacheCreationTokens1h != 0 </span><span class="cov0" title="0">{
                info["cache_creation_tokens_1h"] = cacheCreationTokens1h
                info["cache_creation_ratio_1h"] = cacheCreationRatio1h
        }</span>
        <span class="cov0" title="0">return info</span>
}

func GenerateMjOtherInfo(relayInfo *relaycommon.RelayInfo, priceData types.PerCallPriceData) map[string]interface{} <span class="cov0" title="0">{
        other := make(map[string]interface{})
        other["model_price"] = priceData.ModelPrice
        other["group_ratio"] = priceData.GroupRatioInfo.GroupRatio
        if priceData.GroupRatioInfo.HasSpecialRatio </span><span class="cov0" title="0">{
                other["user_group_ratio"] = priceData.GroupRatioInfo.GroupSpecialRatio
        }</span>
        <span class="cov0" title="0">appendRequestPath(nil, relayInfo, other)
        return other</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package service

import (
        "context"
        "encoding/json"
        "io"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        relayconstant "github.com/QuantumNous/new-api/relay/constant"
        "github.com/QuantumNous/new-api/setting"

        "github.com/gin-gonic/gin"
)

func CoverActionToModelName(mjAction string) string <span class="cov0" title="0">{
        modelName := "mj_" + strings.ToLower(mjAction)
        if mjAction == constant.MjActionSwapFace </span><span class="cov0" title="0">{
                modelName = "swap_face"
        }</span>
        <span class="cov0" title="0">return modelName</span>
}

func GetMjRequestModel(relayMode int, midjRequest *dto.MidjourneyRequest) (string, *dto.MidjourneyResponse, bool) <span class="cov0" title="0">{
        action := ""
        if relayMode == relayconstant.RelayModeMidjourneyAction </span><span class="cov0" title="0">{
                // plus request
                err := CoverPlusActionToNormalAction(midjRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err, false
                }</span>
                <span class="cov0" title="0">action = midjRequest.Action</span>
        } else<span class="cov0" title="0"> {
                switch relayMode </span>{
                case relayconstant.RelayModeMidjourneyImagine:<span class="cov0" title="0">
                        action = constant.MjActionImagine</span>
                case relayconstant.RelayModeMidjourneyVideo:<span class="cov0" title="0">
                        action = constant.MjActionVideo</span>
                case relayconstant.RelayModeMidjourneyEdits:<span class="cov0" title="0">
                        action = constant.MjActionEdits</span>
                case relayconstant.RelayModeMidjourneyDescribe:<span class="cov0" title="0">
                        action = constant.MjActionDescribe</span>
                case relayconstant.RelayModeMidjourneyBlend:<span class="cov0" title="0">
                        action = constant.MjActionBlend</span>
                case relayconstant.RelayModeMidjourneyShorten:<span class="cov0" title="0">
                        action = constant.MjActionShorten</span>
                case relayconstant.RelayModeMidjourneyChange:<span class="cov0" title="0">
                        action = midjRequest.Action</span>
                case relayconstant.RelayModeMidjourneyModal:<span class="cov0" title="0">
                        action = constant.MjActionModal</span>
                case relayconstant.RelayModeSwapFace:<span class="cov0" title="0">
                        action = constant.MjActionSwapFace</span>
                case relayconstant.RelayModeMidjourneyUpload:<span class="cov0" title="0">
                        action = constant.MjActionUpload</span>
                case relayconstant.RelayModeMidjourneySimpleChange:<span class="cov0" title="0">
                        params := ConvertSimpleChangeParams(midjRequest.Content)
                        if params == nil </span><span class="cov0" title="0">{
                                return "", MidjourneyErrorWrapper(constant.MjRequestError, "invalid_request"), false
                        }</span>
                        <span class="cov0" title="0">action = params.Action</span>
                case relayconstant.RelayModeMidjourneyTaskFetch, relayconstant.RelayModeMidjourneyTaskFetchByCondition, relayconstant.RelayModeMidjourneyNotify:<span class="cov0" title="0">
                        return "", nil, true</span>
                default:<span class="cov0" title="0">
                        return "", MidjourneyErrorWrapper(constant.MjRequestError, "unknown_relay_action"), false</span>
                }
        }
        <span class="cov0" title="0">modelName := CoverActionToModelName(action)
        return modelName, nil, true</span>
}

func CoverPlusActionToNormalAction(midjRequest *dto.MidjourneyRequest) *dto.MidjourneyResponse <span class="cov0" title="0">{
        // "customId": "MJ::JOB::upsample::2::3dbbd469-36af-4a0f-8f02-df6c579e7011"
        customId := midjRequest.CustomId
        if customId == "" </span><span class="cov0" title="0">{
                return MidjourneyErrorWrapper(constant.MjRequestError, "custom_id_is_required")
        }</span>
        <span class="cov0" title="0">splits := strings.Split(customId, "::")
        var action string
        if splits[1] == "JOB" </span><span class="cov0" title="0">{
                action = splits[2]
        }</span> else<span class="cov0" title="0"> {
                action = splits[1]
        }</span>

        <span class="cov0" title="0">if action == "" </span><span class="cov0" title="0">{
                return MidjourneyErrorWrapper(constant.MjRequestError, "unknown_action")
        }</span>
        <span class="cov0" title="0">if strings.Contains(action, "upsample") </span><span class="cov0" title="0">{
                index, err := strconv.Atoi(splits[3])
                if err != nil </span><span class="cov0" title="0">{
                        return MidjourneyErrorWrapper(constant.MjRequestError, "index_parse_failed")
                }</span>
                <span class="cov0" title="0">midjRequest.Index = index
                midjRequest.Action = constant.MjActionUpscale</span>
        } else<span class="cov0" title="0"> if strings.Contains(action, "variation") </span><span class="cov0" title="0">{
                midjRequest.Index = 1
                if action == "variation" </span><span class="cov0" title="0">{
                        index, err := strconv.Atoi(splits[3])
                        if err != nil </span><span class="cov0" title="0">{
                                return MidjourneyErrorWrapper(constant.MjRequestError, "index_parse_failed")
                        }</span>
                        <span class="cov0" title="0">midjRequest.Index = index
                        midjRequest.Action = constant.MjActionVariation</span>
                } else<span class="cov0" title="0"> if action == "low_variation" </span><span class="cov0" title="0">{
                        midjRequest.Action = constant.MjActionLowVariation
                }</span> else<span class="cov0" title="0"> if action == "high_variation" </span><span class="cov0" title="0">{
                        midjRequest.Action = constant.MjActionHighVariation
                }</span>
        } else<span class="cov0" title="0"> if strings.Contains(action, "pan") </span><span class="cov0" title="0">{
                midjRequest.Action = constant.MjActionPan
                midjRequest.Index = 1
        }</span> else<span class="cov0" title="0"> if strings.Contains(action, "reroll") </span><span class="cov0" title="0">{
                midjRequest.Action = constant.MjActionReRoll
                midjRequest.Index = 1
        }</span> else<span class="cov0" title="0"> if action == "Outpaint" </span><span class="cov0" title="0">{
                midjRequest.Action = constant.MjActionZoom
                midjRequest.Index = 1
        }</span> else<span class="cov0" title="0"> if action == "CustomZoom" </span><span class="cov0" title="0">{
                midjRequest.Action = constant.MjActionCustomZoom
                midjRequest.Index = 1
        }</span> else<span class="cov0" title="0"> if action == "Inpaint" </span><span class="cov0" title="0">{
                midjRequest.Action = constant.MjActionInPaint
                midjRequest.Index = 1
        }</span> else<span class="cov0" title="0"> {
                return MidjourneyErrorWrapper(constant.MjRequestError, "unknown_action:"+customId)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ConvertSimpleChangeParams(content string) *dto.MidjourneyRequest <span class="cov0" title="0">{
        split := strings.Split(content, " ")
        if len(split) != 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">action := strings.ToLower(split[1])
        changeParams := &amp;dto.MidjourneyRequest{}
        changeParams.TaskId = split[0]

        if action[0] == 'u' </span><span class="cov0" title="0">{
                changeParams.Action = "UPSCALE"
        }</span> else<span class="cov0" title="0"> if action[0] == 'v' </span><span class="cov0" title="0">{
                changeParams.Action = "VARIATION"
        }</span> else<span class="cov0" title="0"> if action == "r" </span><span class="cov0" title="0">{
                changeParams.Action = "REROLL"
                return changeParams
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>

        <span class="cov0" title="0">index, err := strconv.Atoi(action[1:2])
        if err != nil || index &lt; 1 || index &gt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">changeParams.Index = index
        return changeParams</span>
}

func DoMidjourneyHttpRequest(c *gin.Context, timeout time.Duration, fullRequestURL string) (*dto.MidjourneyResponseWithStatusCode, []byte, error) <span class="cov0" title="0">{
        var nullBytes []byte
        //var requestBody io.Reader
        //requestBody = c.Request.Body
        // read request body to json, delete accountFilter and notifyHook
        var mapResult map[string]interface{}
        // if get request, no need to read request body
        if c.Request.Method != "GET" </span><span class="cov0" title="0">{
                err := json.NewDecoder(c.Request.Body).Decode(&amp;mapResult)
                if err != nil </span><span class="cov0" title="0">{
                        return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "read_request_body_failed", http.StatusInternalServerError), nullBytes, err
                }</span>
                <span class="cov0" title="0">if !setting.MjAccountFilterEnabled </span><span class="cov0" title="0">{
                        delete(mapResult, "accountFilter")
                }</span>
                <span class="cov0" title="0">if !setting.MjNotifyEnabled </span><span class="cov0" title="0">{
                        delete(mapResult, "notifyHook")
                }</span>
                //req, err := http.NewRequest(c.Request.Method, fullRequestURL, requestBody)
                // make new request with mapResult
        }
        <span class="cov0" title="0">if setting.MjModeClearEnabled </span><span class="cov0" title="0">{
                if prompt, ok := mapResult["prompt"].(string); ok </span><span class="cov0" title="0">{
                        prompt = strings.Replace(prompt, "--fast", "", -1)
                        prompt = strings.Replace(prompt, "--relax", "", -1)
                        prompt = strings.Replace(prompt, "--turbo", "", -1)

                        mapResult["prompt"] = prompt
                }</span>
        }
        <span class="cov0" title="0">reqBody, err := json.Marshal(mapResult)
        if err != nil </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "marshal_request_body_failed", http.StatusInternalServerError), nullBytes, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest(c.Request.Method, fullRequestURL, strings.NewReader(string(reqBody)))
        if err != nil </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "create_request_failed", http.StatusInternalServerError), nullBytes, err
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        // 使用带有超时的 context 创建新的请求
        req = req.WithContext(ctx)
        req.Header.Set("Content-Type", c.Request.Header.Get("Content-Type"))
        req.Header.Set("Accept", c.Request.Header.Get("Accept"))
        auth := common.GetContextKeyString(c, constant.ContextKeyChannelKey)
        if auth != "" </span><span class="cov0" title="0">{
                auth = strings.TrimPrefix(auth, "Bearer ")
                req.Header.Set("mj-api-secret", auth)
        }</span>
        <span class="cov0" title="0">defer cancel()
        resp, err := GetHttpClient().Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog("do request failed: " + err.Error())
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "do_request_failed", http.StatusInternalServerError), nullBytes, err
        }</span>
        <span class="cov0" title="0">statusCode := resp.StatusCode
        //if statusCode != 200  {
        //        return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "bad_response_status_code", statusCode), nullBytes, nil
        //}
        err = req.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "close_request_body_failed", statusCode), nullBytes, err
        }</span>
        <span class="cov0" title="0">err = c.Request.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "close_request_body_failed", statusCode), nullBytes, err
        }</span>
        <span class="cov0" title="0">var midjResponse dto.MidjourneyResponse
        var midjourneyUploadsResponse dto.MidjourneyUploadResponse
        responseBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "read_response_body_failed", statusCode), nullBytes, err
        }</span>
        <span class="cov0" title="0">CloseResponseBodyGracefully(resp)
        respStr := string(responseBody)
        log.Printf("respStr: %s", respStr)
        if respStr == "" </span><span class="cov0" title="0">{
                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "empty_response_body", statusCode), responseBody, nil
        }</span> else<span class="cov0" title="0"> {
                err = json.Unmarshal(responseBody, &amp;midjResponse)
                if err != nil </span><span class="cov0" title="0">{
                        err2 := json.Unmarshal(responseBody, &amp;midjourneyUploadsResponse)
                        if err2 != nil </span><span class="cov0" title="0">{
                                return MidjourneyErrorWithStatusCodeWrapper(constant.MjErrorUnknown, "unmarshal_response_body_failed", statusCode), responseBody, err
                        }</span>
                }
        }
        //log.Printf("midjResponse: %v", midjResponse)
        //for k, v := range resp.Header {
        //        c.Writer.Header().Set(k, v[0])
        //}
        <span class="cov0" title="0">return &amp;dto.MidjourneyResponseWithStatusCode{
                StatusCode: statusCode,
                Response:   midjResponse,
        }, responseBody, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package service

import (
        "fmt"
        "strconv"
        "sync"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/bytedance/gopkg/util/gopool"
)

// notifyLimitStore is used for in-memory rate limiting when Redis is disabled
var (
        notifyLimitStore sync.Map
        cleanupOnce      sync.Once
)

type limitCount struct {
        Count     int
        Timestamp time.Time
}

func getDuration() time.Duration <span class="cov0" title="0">{
        minute := constant.NotificationLimitDurationMinute
        return time.Duration(minute) * time.Minute
}</span>

// startCleanupTask starts a background task to clean up expired entries
func startCleanupTask() <span class="cov0" title="0">{
        gopool.Go(func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(time.Hour)
                        now := time.Now()
                        notifyLimitStore.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                                if limit, ok := value.(limitCount); ok </span><span class="cov0" title="0">{
                                        if now.Sub(limit.Timestamp) &gt;= getDuration() </span><span class="cov0" title="0">{
                                                notifyLimitStore.Delete(key)
                                        }</span>
                                }
                                <span class="cov0" title="0">return true</span>
                        })
                }
        })
}

// CheckNotificationLimit checks if the user has exceeded their notification limit
// Returns true if the user can send notification, false if limit exceeded
func CheckNotificationLimit(userId int, notifyType string) (bool, error) <span class="cov0" title="0">{
        if common.RedisEnabled </span><span class="cov0" title="0">{
                return checkRedisLimit(userId, notifyType)
        }</span>
        <span class="cov0" title="0">return checkMemoryLimit(userId, notifyType)</span>
}

func checkRedisLimit(userId int, notifyType string) (bool, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("notify_limit:%d:%s:%s", userId, notifyType, time.Now().Format("2006010215"))

        // Get current count
        count, err := common.RedisGet(key)
        if err != nil &amp;&amp; err.Error() != "redis: nil" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get notification count: %w", err)
        }</span>

        // If key doesn't exist, initialize it
        <span class="cov0" title="0">if count == "" </span><span class="cov0" title="0">{
                err = common.RedisSet(key, "1", getDuration())
                return true, err
        }</span>

        <span class="cov0" title="0">currentCount, _ := strconv.Atoi(count)
        limit := constant.NotifyLimitCount

        // Check if limit is already reached
        if currentCount &gt;= limit </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Only increment if under limit
        <span class="cov0" title="0">err = common.RedisIncr(key, 1)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to increment notification count: %w", err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func checkMemoryLimit(userId int, notifyType string) (bool, error) <span class="cov0" title="0">{
        // Ensure cleanup task is started
        cleanupOnce.Do(startCleanupTask)

        key := fmt.Sprintf("%d:%s:%s", userId, notifyType, time.Now().Format("2006010215"))
        now := time.Now()

        // Get current limit count or initialize new one
        var currentLimit limitCount
        if value, ok := notifyLimitStore.Load(key); ok </span><span class="cov0" title="0">{
                currentLimit = value.(limitCount)
                // Check if the entry has expired
                if now.Sub(currentLimit.Timestamp) &gt;= getDuration() </span><span class="cov0" title="0">{
                        currentLimit = limitCount{Count: 0, Timestamp: now}
                }</span>
        } else<span class="cov0" title="0"> {
                currentLimit = limitCount{Count: 0, Timestamp: now}
        }</span>

        // Increment count
        <span class="cov0" title="0">currentLimit.Count++

        // Check against limits
        limit := constant.NotifyLimitCount

        // Store updated count
        notifyLimitStore.Store(key, currentLimit)

        return currentLimit.Count &lt;= limit, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package service

import (
        "fmt"
        "net/http"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        "github.com/QuantumNous/new-api/types"

        "github.com/bytedance/gopkg/util/gopool"
        "github.com/gin-gonic/gin"
)

func ReturnPreConsumedQuota(c *gin.Context, relayInfo *relaycommon.RelayInfo) <span class="cov0" title="0">{
        if relayInfo.FinalPreConsumedQuota != 0 </span><span class="cov0" title="0">{
                logger.LogInfo(c, fmt.Sprintf("用户 %d 请求失败, 返还预扣费额度 %s", relayInfo.UserId, logger.FormatQuota(relayInfo.FinalPreConsumedQuota)))
                gopool.Go(func() </span><span class="cov0" title="0">{
                        relayInfoCopy := *relayInfo

                        err := PostConsumeQuota(&amp;relayInfoCopy, -relayInfoCopy.FinalPreConsumedQuota, 0, false)
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysLog("error return pre-consumed quota: " + err.Error())
                        }</span>
                })
        }
}

// PreConsumeQuota checks if the user has enough quota to pre-consume.
// It returns the pre-consumed quota if successful, or an error if not.
func PreConsumeQuota(c *gin.Context, preConsumedQuota int, relayInfo *relaycommon.RelayInfo) *types.NewAPIError <span class="cov0" title="0">{
        userQuota, err := model.GetUserQuota(relayInfo.UserId, false)
        if err != nil </span><span class="cov0" title="0">{
                return types.NewError(err, types.ErrorCodeQueryDataError, types.ErrOptionWithSkipRetry())
        }</span>
        <span class="cov0" title="0">if userQuota &lt;= 0 </span><span class="cov0" title="0">{
                return types.NewErrorWithStatusCode(fmt.Errorf("用户额度不足, 剩余额度: %s", logger.FormatQuota(userQuota)), types.ErrorCodeInsufficientUserQuota, http.StatusForbidden, types.ErrOptionWithSkipRetry(), types.ErrOptionWithNoRecordErrorLog())
        }</span>
        <span class="cov0" title="0">if userQuota-preConsumedQuota &lt; 0 </span><span class="cov0" title="0">{
                return types.NewErrorWithStatusCode(fmt.Errorf("预扣费额度失败, 用户剩余额度: %s, 需要预扣费额度: %s", logger.FormatQuota(userQuota), logger.FormatQuota(preConsumedQuota)), types.ErrorCodeInsufficientUserQuota, http.StatusForbidden, types.ErrOptionWithSkipRetry(), types.ErrOptionWithNoRecordErrorLog())
        }</span>

        <span class="cov0" title="0">trustQuota := common.GetTrustQuota()

        relayInfo.UserQuota = userQuota
        if userQuota &gt; trustQuota </span><span class="cov0" title="0">{
                // 用户额度充足，判断令牌额度是否充足
                if !relayInfo.TokenUnlimited </span><span class="cov0" title="0">{
                        // 非无限令牌，判断令牌额度是否充足
                        tokenQuota := c.GetInt("token_quota")
                        if tokenQuota &gt; trustQuota </span><span class="cov0" title="0">{
                                // 令牌额度充足，信任令牌
                                preConsumedQuota = 0
                                logger.LogInfo(c, fmt.Sprintf("用户 %d 剩余额度 %s 且令牌 %d 额度 %d 充足, 信任且不需要预扣费", relayInfo.UserId, logger.FormatQuota(userQuota), relayInfo.TokenId, tokenQuota))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // in this case, we do not pre-consume quota
                        // because the user has enough quota
                        preConsumedQuota = 0
                        logger.LogInfo(c, fmt.Sprintf("用户 %d 额度充足且为无限额度令牌, 信任且不需要预扣费", relayInfo.UserId))
                }</span>
        }

        <span class="cov0" title="0">if preConsumedQuota &gt; 0 </span><span class="cov0" title="0">{
                err := PreConsumeTokenQuota(relayInfo, preConsumedQuota)
                if err != nil </span><span class="cov0" title="0">{
                        return types.NewErrorWithStatusCode(err, types.ErrorCodePreConsumeTokenQuotaFailed, http.StatusForbidden, types.ErrOptionWithSkipRetry(), types.ErrOptionWithNoRecordErrorLog())
                }</span>
                <span class="cov0" title="0">err = model.DecreaseUserQuota(relayInfo.UserId, preConsumedQuota)
                if err != nil </span><span class="cov0" title="0">{
                        return types.NewError(err, types.ErrorCodeUpdateDataError, types.ErrOptionWithSkipRetry())
                }</span>
                <span class="cov0" title="0">logger.LogInfo(c, fmt.Sprintf("用户 %d 预扣费 %s, 预扣费后剩余额度: %s", relayInfo.UserId, logger.FormatQuota(preConsumedQuota), logger.FormatQuota(userQuota-preConsumedQuota)))</span>
        }
        <span class="cov0" title="0">relayInfo.FinalPreConsumedQuota = preConsumedQuota
        return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package service

import (
        "errors"
        "fmt"
        "log"
        "math"
        "strings"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/logger"
        "github.com/QuantumNous/new-api/model"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        "github.com/QuantumNous/new-api/setting/ratio_setting"
        "github.com/QuantumNous/new-api/setting/system_setting"
        "github.com/QuantumNous/new-api/types"

        "github.com/bytedance/gopkg/util/gopool"

        "github.com/gin-gonic/gin"
        "github.com/shopspring/decimal"
)

type TokenDetails struct {
        TextTokens  int
        AudioTokens int
}

type QuotaInfo struct {
        InputDetails  TokenDetails
        OutputDetails TokenDetails
        ModelName     string
        UsePrice      bool
        ModelPrice    float64
        ModelRatio    float64
        GroupRatio    float64
}

func hasCustomModelRatio(modelName string, currentRatio float64) bool <span class="cov0" title="0">{
        defaultRatio, exists := ratio_setting.GetDefaultModelRatioMap()[modelName]
        if !exists </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return currentRatio != defaultRatio</span>
}

func calculateAudioQuota(info QuotaInfo) int <span class="cov0" title="0">{
        if info.UsePrice </span><span class="cov0" title="0">{
                modelPrice := decimal.NewFromFloat(info.ModelPrice)
                quotaPerUnit := decimal.NewFromFloat(common.QuotaPerUnit)
                groupRatio := decimal.NewFromFloat(info.GroupRatio)

                quota := modelPrice.Mul(quotaPerUnit).Mul(groupRatio)
                return int(quota.IntPart())
        }</span>

        <span class="cov0" title="0">completionRatio := decimal.NewFromFloat(ratio_setting.GetCompletionRatio(info.ModelName))
        audioRatio := decimal.NewFromFloat(ratio_setting.GetAudioRatio(info.ModelName))
        audioCompletionRatio := decimal.NewFromFloat(ratio_setting.GetAudioCompletionRatio(info.ModelName))

        groupRatio := decimal.NewFromFloat(info.GroupRatio)
        modelRatio := decimal.NewFromFloat(info.ModelRatio)
        ratio := groupRatio.Mul(modelRatio)

        inputTextTokens := decimal.NewFromInt(int64(info.InputDetails.TextTokens))
        outputTextTokens := decimal.NewFromInt(int64(info.OutputDetails.TextTokens))
        inputAudioTokens := decimal.NewFromInt(int64(info.InputDetails.AudioTokens))
        outputAudioTokens := decimal.NewFromInt(int64(info.OutputDetails.AudioTokens))

        quota := decimal.Zero
        quota = quota.Add(inputTextTokens)
        quota = quota.Add(outputTextTokens.Mul(completionRatio))
        quota = quota.Add(inputAudioTokens.Mul(audioRatio))
        quota = quota.Add(outputAudioTokens.Mul(audioRatio).Mul(audioCompletionRatio))

        quota = quota.Mul(ratio)

        // If ratio is not zero and quota is less than or equal to zero, set quota to 1
        if !ratio.IsZero() &amp;&amp; quota.LessThanOrEqual(decimal.Zero) </span><span class="cov0" title="0">{
                quota = decimal.NewFromInt(1)
        }</span>

        <span class="cov0" title="0">return int(quota.Round(0).IntPart())</span>
}

func PreWssConsumeQuota(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, usage *dto.RealtimeUsage) error <span class="cov0" title="0">{
        if relayInfo.UsePrice </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">userQuota, err := model.GetUserQuota(relayInfo.UserId, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">token, err := model.GetTokenByKey(strings.TrimLeft(relayInfo.TokenKey, "sk-"), false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">modelName := relayInfo.OriginModelName
        textInputTokens := usage.InputTokenDetails.TextTokens
        textOutTokens := usage.OutputTokenDetails.TextTokens
        audioInputTokens := usage.InputTokenDetails.AudioTokens
        audioOutTokens := usage.OutputTokenDetails.AudioTokens
        groupRatio := ratio_setting.GetGroupRatio(relayInfo.UsingGroup)
        modelRatio, _, _ := ratio_setting.GetModelRatio(modelName)

        autoGroup, exists := ctx.Get("auto_group")
        if exists </span><span class="cov0" title="0">{
                groupRatio = ratio_setting.GetGroupRatio(autoGroup.(string))
                log.Printf("final group ratio: %f", groupRatio)
                relayInfo.UsingGroup = autoGroup.(string)
        }</span>

        <span class="cov0" title="0">actualGroupRatio := groupRatio
        userGroupRatio, ok := ratio_setting.GetGroupGroupRatio(relayInfo.UserGroup, relayInfo.UsingGroup)
        if ok </span><span class="cov0" title="0">{
                actualGroupRatio = userGroupRatio
        }</span>

        <span class="cov0" title="0">quotaInfo := QuotaInfo{
                InputDetails: TokenDetails{
                        TextTokens:  textInputTokens,
                        AudioTokens: audioInputTokens,
                },
                OutputDetails: TokenDetails{
                        TextTokens:  textOutTokens,
                        AudioTokens: audioOutTokens,
                },
                ModelName:  modelName,
                UsePrice:   relayInfo.UsePrice,
                ModelRatio: modelRatio,
                GroupRatio: actualGroupRatio,
        }

        quota := calculateAudioQuota(quotaInfo)

        if userQuota &lt; quota </span><span class="cov0" title="0">{
                return fmt.Errorf("user quota is not enough, user quota: %s, need quota: %s", logger.FormatQuota(userQuota), logger.FormatQuota(quota))
        }</span>

        <span class="cov0" title="0">if !token.UnlimitedQuota &amp;&amp; token.RemainQuota &lt; quota </span><span class="cov0" title="0">{
                return fmt.Errorf("token quota is not enough, token remain quota: %s, need quota: %s", logger.FormatQuota(token.RemainQuota), logger.FormatQuota(quota))
        }</span>

        <span class="cov0" title="0">err = PostConsumeQuota(relayInfo, quota, 0, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.LogInfo(ctx, "realtime streaming consume quota success, quota: "+fmt.Sprintf("%d", quota))
        return nil</span>
}

func PostWssConsumeQuota(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, modelName string,
        usage *dto.RealtimeUsage, extraContent string) <span class="cov0" title="0">{

        useTimeSeconds := time.Now().Unix() - relayInfo.StartTime.Unix()
        textInputTokens := usage.InputTokenDetails.TextTokens
        textOutTokens := usage.OutputTokenDetails.TextTokens

        audioInputTokens := usage.InputTokenDetails.AudioTokens
        audioOutTokens := usage.OutputTokenDetails.AudioTokens

        tokenName := ctx.GetString("token_name")
        completionRatio := decimal.NewFromFloat(ratio_setting.GetCompletionRatio(modelName))
        audioRatio := decimal.NewFromFloat(ratio_setting.GetAudioRatio(relayInfo.OriginModelName))
        audioCompletionRatio := decimal.NewFromFloat(ratio_setting.GetAudioCompletionRatio(modelName))

        modelRatio := relayInfo.PriceData.ModelRatio
        groupRatio := relayInfo.PriceData.GroupRatioInfo.GroupRatio
        modelPrice := relayInfo.PriceData.ModelPrice
        usePrice := relayInfo.PriceData.UsePrice

        quotaInfo := QuotaInfo{
                InputDetails: TokenDetails{
                        TextTokens:  textInputTokens,
                        AudioTokens: audioInputTokens,
                },
                OutputDetails: TokenDetails{
                        TextTokens:  textOutTokens,
                        AudioTokens: audioOutTokens,
                },
                ModelName:  modelName,
                UsePrice:   usePrice,
                ModelRatio: modelRatio,
                GroupRatio: groupRatio,
        }

        quota := calculateAudioQuota(quotaInfo)

        totalTokens := usage.TotalTokens
        var logContent string
        if !usePrice </span><span class="cov0" title="0">{
                logContent = fmt.Sprintf("模型倍率 %.2f，补全倍率 %.2f，音频倍率 %.2f，音频补全倍率 %.2f，分组倍率 %.2f",
                        modelRatio, completionRatio.InexactFloat64(), audioRatio.InexactFloat64(), audioCompletionRatio.InexactFloat64(), groupRatio)
        }</span> else<span class="cov0" title="0"> {
                logContent = fmt.Sprintf("模型价格 %.2f，分组倍率 %.2f", modelPrice, groupRatio)
        }</span>

        // record all the consume log even if quota is 0
        <span class="cov0" title="0">if totalTokens == 0 </span><span class="cov0" title="0">{
                // in this case, must be some error happened
                // we cannot just return, because we may have to return the pre-consumed quota
                quota = 0
                logContent += fmt.Sprintf("（可能是上游超时）")
                logger.LogError(ctx, fmt.Sprintf("total tokens is 0, cannot consume quota, userId %d, channelId %d, "+
                        "tokenId %d, model %s， pre-consumed quota %d", relayInfo.UserId, relayInfo.ChannelId, relayInfo.TokenId, modelName, relayInfo.FinalPreConsumedQuota))
        }</span> else<span class="cov0" title="0"> {
                model.UpdateUserUsedQuotaAndRequestCount(relayInfo.UserId, quota)
                model.UpdateChannelUsedQuota(relayInfo.ChannelId, quota)
        }</span>

        <span class="cov0" title="0">logModel := modelName
        if extraContent != "" </span><span class="cov0" title="0">{
                logContent += ", " + extraContent
        }</span>
        <span class="cov0" title="0">other := GenerateWssOtherInfo(ctx, relayInfo, usage, modelRatio, groupRatio,
                completionRatio.InexactFloat64(), audioRatio.InexactFloat64(), audioCompletionRatio.InexactFloat64(), modelPrice, relayInfo.PriceData.GroupRatioInfo.GroupSpecialRatio)
        model.RecordConsumeLog(ctx, relayInfo.UserId, model.RecordConsumeLogParams{
                ChannelId:        relayInfo.ChannelId,
                PromptTokens:     usage.InputTokens,
                CompletionTokens: usage.OutputTokens,
                ModelName:        logModel,
                TokenName:        tokenName,
                Quota:            quota,
                Content:          logContent,
                TokenId:          relayInfo.TokenId,
                UseTimeSeconds:   int(useTimeSeconds),
                IsStream:         relayInfo.IsStream,
                Group:            relayInfo.UsingGroup,
                Other:            other,
        })</span>
}

func PostClaudeConsumeQuota(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, usage *dto.Usage) <span class="cov0" title="0">{

        useTimeSeconds := time.Now().Unix() - relayInfo.StartTime.Unix()
        promptTokens := usage.PromptTokens
        completionTokens := usage.CompletionTokens
        modelName := relayInfo.OriginModelName

        tokenName := ctx.GetString("token_name")
        completionRatio := relayInfo.PriceData.CompletionRatio
        modelRatio := relayInfo.PriceData.ModelRatio
        groupRatio := relayInfo.PriceData.GroupRatioInfo.GroupRatio
        modelPrice := relayInfo.PriceData.ModelPrice
        cacheRatio := relayInfo.PriceData.CacheRatio
        cacheTokens := usage.PromptTokensDetails.CachedTokens

        cacheCreationRatio := relayInfo.PriceData.CacheCreationRatio
        cacheCreationRatio5m := relayInfo.PriceData.CacheCreation5mRatio
        cacheCreationRatio1h := relayInfo.PriceData.CacheCreation1hRatio
        cacheCreationTokens := usage.PromptTokensDetails.CachedCreationTokens
        cacheCreationTokens5m := usage.ClaudeCacheCreation5mTokens
        cacheCreationTokens1h := usage.ClaudeCacheCreation1hTokens

        if relayInfo.ChannelType == constant.ChannelTypeOpenRouter </span><span class="cov0" title="0">{
                promptTokens -= cacheTokens
                isUsingCustomSettings := relayInfo.PriceData.UsePrice || hasCustomModelRatio(modelName, relayInfo.PriceData.ModelRatio)
                if cacheCreationTokens == 0 &amp;&amp; relayInfo.PriceData.CacheCreationRatio != 1 &amp;&amp; usage.Cost != 0 &amp;&amp; !isUsingCustomSettings </span><span class="cov0" title="0">{
                        maybeCacheCreationTokens := CalcOpenRouterCacheCreateTokens(*usage, relayInfo.PriceData)
                        if maybeCacheCreationTokens &gt;= 0 &amp;&amp; promptTokens &gt;= maybeCacheCreationTokens </span><span class="cov0" title="0">{
                                cacheCreationTokens = maybeCacheCreationTokens
                        }</span>
                }
                <span class="cov0" title="0">promptTokens -= cacheCreationTokens</span>
        }

        <span class="cov0" title="0">calculateQuota := 0.0
        if !relayInfo.PriceData.UsePrice </span><span class="cov0" title="0">{
                calculateQuota = float64(promptTokens)
                calculateQuota += float64(cacheTokens) * cacheRatio
                calculateQuota += float64(cacheCreationTokens5m) * cacheCreationRatio5m
                calculateQuota += float64(cacheCreationTokens1h) * cacheCreationRatio1h
                remainingCacheCreationTokens := cacheCreationTokens - cacheCreationTokens5m - cacheCreationTokens1h
                if remainingCacheCreationTokens &gt; 0 </span><span class="cov0" title="0">{
                        calculateQuota += float64(remainingCacheCreationTokens) * cacheCreationRatio
                }</span>
                <span class="cov0" title="0">calculateQuota += float64(completionTokens) * completionRatio
                calculateQuota = calculateQuota * groupRatio * modelRatio</span>
        } else<span class="cov0" title="0"> {
                calculateQuota = modelPrice * common.QuotaPerUnit * groupRatio
        }</span>

        <span class="cov0" title="0">if modelRatio != 0 &amp;&amp; calculateQuota &lt;= 0 </span><span class="cov0" title="0">{
                calculateQuota = 1
        }</span>

        <span class="cov0" title="0">quota := int(calculateQuota)

        totalTokens := promptTokens + completionTokens

        var logContent string
        // record all the consume log even if quota is 0
        if totalTokens == 0 </span><span class="cov0" title="0">{
                // in this case, must be some error happened
                // we cannot just return, because we may have to return the pre-consumed quota
                quota = 0
                logContent += fmt.Sprintf("（可能是上游出错）")
                logger.LogError(ctx, fmt.Sprintf("total tokens is 0, cannot consume quota, userId %d, channelId %d, "+
                        "tokenId %d, model %s， pre-consumed quota %d", relayInfo.UserId, relayInfo.ChannelId, relayInfo.TokenId, modelName, relayInfo.FinalPreConsumedQuota))
        }</span> else<span class="cov0" title="0"> {
                model.UpdateUserUsedQuotaAndRequestCount(relayInfo.UserId, quota)
                model.UpdateChannelUsedQuota(relayInfo.ChannelId, quota)
        }</span>

        <span class="cov0" title="0">quotaDelta := quota - relayInfo.FinalPreConsumedQuota

        if quotaDelta &gt; 0 </span><span class="cov0" title="0">{
                logger.LogInfo(ctx, fmt.Sprintf("预扣费后补扣费：%s（实际消耗：%s，预扣费：%s）",
                        logger.FormatQuota(quotaDelta),
                        logger.FormatQuota(quota),
                        logger.FormatQuota(relayInfo.FinalPreConsumedQuota),
                ))
        }</span> else<span class="cov0" title="0"> if quotaDelta &lt; 0 </span><span class="cov0" title="0">{
                logger.LogInfo(ctx, fmt.Sprintf("预扣费后返还扣费：%s（实际消耗：%s，预扣费：%s）",
                        logger.FormatQuota(-quotaDelta),
                        logger.FormatQuota(quota),
                        logger.FormatQuota(relayInfo.FinalPreConsumedQuota),
                ))
        }</span>

        <span class="cov0" title="0">if quotaDelta != 0 </span><span class="cov0" title="0">{
                err := PostConsumeQuota(relayInfo, quotaDelta, relayInfo.FinalPreConsumedQuota, true)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(ctx, "error consuming token remain quota: "+err.Error())
                }</span>
        }

        <span class="cov0" title="0">other := GenerateClaudeOtherInfo(ctx, relayInfo, modelRatio, groupRatio, completionRatio,
                cacheTokens, cacheRatio,
                cacheCreationTokens, cacheCreationRatio,
                cacheCreationTokens5m, cacheCreationRatio5m,
                cacheCreationTokens1h, cacheCreationRatio1h,
                modelPrice, relayInfo.PriceData.GroupRatioInfo.GroupSpecialRatio)
        model.RecordConsumeLog(ctx, relayInfo.UserId, model.RecordConsumeLogParams{
                ChannelId:        relayInfo.ChannelId,
                PromptTokens:     promptTokens,
                CompletionTokens: completionTokens,
                ModelName:        modelName,
                TokenName:        tokenName,
                Quota:            quota,
                Content:          logContent,
                TokenId:          relayInfo.TokenId,
                UseTimeSeconds:   int(useTimeSeconds),
                IsStream:         relayInfo.IsStream,
                Group:            relayInfo.UsingGroup,
                Other:            other,
        })</span>

}

func CalcOpenRouterCacheCreateTokens(usage dto.Usage, priceData types.PriceData) int <span class="cov0" title="0">{
        if priceData.CacheCreationRatio == 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">quotaPrice := priceData.ModelRatio / common.QuotaPerUnit
        promptCacheCreatePrice := quotaPrice * priceData.CacheCreationRatio
        promptCacheReadPrice := quotaPrice * priceData.CacheRatio
        completionPrice := quotaPrice * priceData.CompletionRatio

        cost, _ := usage.Cost.(float64)
        totalPromptTokens := float64(usage.PromptTokens)
        completionTokens := float64(usage.CompletionTokens)
        promptCacheReadTokens := float64(usage.PromptTokensDetails.CachedTokens)

        return int(math.Round((cost -
                totalPromptTokens*quotaPrice +
                promptCacheReadTokens*(quotaPrice-promptCacheReadPrice) -
                completionTokens*completionPrice) /
                (promptCacheCreatePrice - quotaPrice)))</span>
}

func PostAudioConsumeQuota(ctx *gin.Context, relayInfo *relaycommon.RelayInfo, usage *dto.Usage, extraContent string) <span class="cov0" title="0">{

        useTimeSeconds := time.Now().Unix() - relayInfo.StartTime.Unix()
        textInputTokens := usage.PromptTokensDetails.TextTokens
        textOutTokens := usage.CompletionTokenDetails.TextTokens

        audioInputTokens := usage.PromptTokensDetails.AudioTokens
        audioOutTokens := usage.CompletionTokenDetails.AudioTokens

        tokenName := ctx.GetString("token_name")
        completionRatio := decimal.NewFromFloat(ratio_setting.GetCompletionRatio(relayInfo.OriginModelName))
        audioRatio := decimal.NewFromFloat(ratio_setting.GetAudioRatio(relayInfo.OriginModelName))
        audioCompletionRatio := decimal.NewFromFloat(ratio_setting.GetAudioCompletionRatio(relayInfo.OriginModelName))

        modelRatio := relayInfo.PriceData.ModelRatio
        groupRatio := relayInfo.PriceData.GroupRatioInfo.GroupRatio
        modelPrice := relayInfo.PriceData.ModelPrice
        usePrice := relayInfo.PriceData.UsePrice

        quotaInfo := QuotaInfo{
                InputDetails: TokenDetails{
                        TextTokens:  textInputTokens,
                        AudioTokens: audioInputTokens,
                },
                OutputDetails: TokenDetails{
                        TextTokens:  textOutTokens,
                        AudioTokens: audioOutTokens,
                },
                ModelName:  relayInfo.OriginModelName,
                UsePrice:   usePrice,
                ModelRatio: modelRatio,
                GroupRatio: groupRatio,
        }

        quota := calculateAudioQuota(quotaInfo)

        totalTokens := usage.TotalTokens
        var logContent string
        if !usePrice </span><span class="cov0" title="0">{
                logContent = fmt.Sprintf("模型倍率 %.2f，补全倍率 %.2f，音频倍率 %.2f，音频补全倍率 %.2f，分组倍率 %.2f",
                        modelRatio, completionRatio.InexactFloat64(), audioRatio.InexactFloat64(), audioCompletionRatio.InexactFloat64(), groupRatio)
        }</span> else<span class="cov0" title="0"> {
                logContent = fmt.Sprintf("模型价格 %.2f，分组倍率 %.2f", modelPrice, groupRatio)
        }</span>

        // record all the consume log even if quota is 0
        <span class="cov0" title="0">if totalTokens == 0 </span><span class="cov0" title="0">{
                // in this case, must be some error happened
                // we cannot just return, because we may have to return the pre-consumed quota
                quota = 0
                logContent += fmt.Sprintf("（可能是上游超时）")
                logger.LogError(ctx, fmt.Sprintf("total tokens is 0, cannot consume quota, userId %d, channelId %d, "+
                        "tokenId %d, model %s， pre-consumed quota %d", relayInfo.UserId, relayInfo.ChannelId, relayInfo.TokenId, relayInfo.OriginModelName, relayInfo.FinalPreConsumedQuota))
        }</span> else<span class="cov0" title="0"> {
                model.UpdateUserUsedQuotaAndRequestCount(relayInfo.UserId, quota)
                model.UpdateChannelUsedQuota(relayInfo.ChannelId, quota)
        }</span>

        <span class="cov0" title="0">quotaDelta := quota - relayInfo.FinalPreConsumedQuota

        if quotaDelta &gt; 0 </span><span class="cov0" title="0">{
                logger.LogInfo(ctx, fmt.Sprintf("预扣费后补扣费：%s（实际消耗：%s，预扣费：%s）",
                        logger.FormatQuota(quotaDelta),
                        logger.FormatQuota(quota),
                        logger.FormatQuota(relayInfo.FinalPreConsumedQuota),
                ))
        }</span> else<span class="cov0" title="0"> if quotaDelta &lt; 0 </span><span class="cov0" title="0">{
                logger.LogInfo(ctx, fmt.Sprintf("预扣费后返还扣费：%s（实际消耗：%s，预扣费：%s）",
                        logger.FormatQuota(-quotaDelta),
                        logger.FormatQuota(quota),
                        logger.FormatQuota(relayInfo.FinalPreConsumedQuota),
                ))
        }</span>

        <span class="cov0" title="0">if quotaDelta != 0 </span><span class="cov0" title="0">{
                err := PostConsumeQuota(relayInfo, quotaDelta, relayInfo.FinalPreConsumedQuota, true)
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(ctx, "error consuming token remain quota: "+err.Error())
                }</span>
        }

        <span class="cov0" title="0">logModel := relayInfo.OriginModelName
        if extraContent != "" </span><span class="cov0" title="0">{
                logContent += ", " + extraContent
        }</span>
        <span class="cov0" title="0">other := GenerateAudioOtherInfo(ctx, relayInfo, usage, modelRatio, groupRatio,
                completionRatio.InexactFloat64(), audioRatio.InexactFloat64(), audioCompletionRatio.InexactFloat64(), modelPrice, relayInfo.PriceData.GroupRatioInfo.GroupSpecialRatio)
        model.RecordConsumeLog(ctx, relayInfo.UserId, model.RecordConsumeLogParams{
                ChannelId:        relayInfo.ChannelId,
                PromptTokens:     usage.PromptTokens,
                CompletionTokens: usage.CompletionTokens,
                ModelName:        logModel,
                TokenName:        tokenName,
                Quota:            quota,
                Content:          logContent,
                TokenId:          relayInfo.TokenId,
                UseTimeSeconds:   int(useTimeSeconds),
                IsStream:         relayInfo.IsStream,
                Group:            relayInfo.UsingGroup,
                Other:            other,
        })</span>
}

func PreConsumeTokenQuota(relayInfo *relaycommon.RelayInfo, quota int) error <span class="cov0" title="0">{
        if quota &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("quota 不能为负数！")
        }</span>
        <span class="cov0" title="0">if relayInfo.IsPlayground </span><span class="cov0" title="0">{
                return nil
        }</span>
        //if relayInfo.TokenUnlimited {
        //        return nil
        //}
        <span class="cov0" title="0">token, err := model.GetTokenByKey(relayInfo.TokenKey, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !relayInfo.TokenUnlimited &amp;&amp; token.RemainQuota &lt; quota </span><span class="cov0" title="0">{
                return fmt.Errorf("token quota is not enough, token remain quota: %s, need quota: %s", logger.FormatQuota(token.RemainQuota), logger.FormatQuota(quota))
        }</span>
        <span class="cov0" title="0">err = model.DecreaseTokenQuota(relayInfo.TokenId, relayInfo.TokenKey, quota)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func PostConsumeQuota(relayInfo *relaycommon.RelayInfo, quota int, preConsumedQuota int, sendEmail bool) (err error) <span class="cov0" title="0">{

        if quota &gt; 0 </span><span class="cov0" title="0">{
                err = model.DecreaseUserQuota(relayInfo.UserId, quota)
        }</span> else<span class="cov0" title="0"> {
                err = model.IncreaseUserQuota(relayInfo.UserId, -quota, false)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !relayInfo.IsPlayground </span><span class="cov0" title="0">{
                if quota &gt; 0 </span><span class="cov0" title="0">{
                        err = model.DecreaseTokenQuota(relayInfo.TokenId, relayInfo.TokenKey, quota)
                }</span> else<span class="cov0" title="0"> {
                        err = model.IncreaseTokenQuota(relayInfo.TokenId, relayInfo.TokenKey, -quota)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if sendEmail </span><span class="cov0" title="0">{
                if (quota + preConsumedQuota) != 0 </span><span class="cov0" title="0">{
                        checkAndSendQuotaNotify(relayInfo, quota, preConsumedQuota)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func checkAndSendQuotaNotify(relayInfo *relaycommon.RelayInfo, quota int, preConsumedQuota int) <span class="cov0" title="0">{
        gopool.Go(func() </span><span class="cov0" title="0">{
                userSetting := relayInfo.UserSetting
                threshold := common.QuotaRemindThreshold
                if userSetting.QuotaWarningThreshold != 0 </span><span class="cov0" title="0">{
                        threshold = int(userSetting.QuotaWarningThreshold)
                }</span>

                //noMoreQuota := userCache.Quota-(quota+preConsumedQuota) &lt;= 0
                <span class="cov0" title="0">quotaTooLow := false
                consumeQuota := quota + preConsumedQuota
                if relayInfo.UserQuota-consumeQuota &lt; threshold </span><span class="cov0" title="0">{
                        quotaTooLow = true
                }</span>
                <span class="cov0" title="0">if quotaTooLow </span><span class="cov0" title="0">{
                        prompt := "您的额度即将用尽"
                        topUpLink := fmt.Sprintf("%s/console/topup", system_setting.ServerAddress)

                        // 根据通知方式生成不同的内容格式
                        var content string
                        var values []interface{}

                        notifyType := userSetting.NotifyType
                        if notifyType == "" </span><span class="cov0" title="0">{
                                notifyType = dto.NotifyTypeEmail
                        }</span>

                        <span class="cov0" title="0">if notifyType == dto.NotifyTypeBark </span><span class="cov0" title="0">{
                                // Bark推送使用简短文本，不支持HTML
                                content = "{{value}}，剩余额度：{{value}}，请及时充值"
                                values = []interface{}{prompt, logger.FormatQuota(relayInfo.UserQuota)}
                        }</span> else<span class="cov0" title="0"> if notifyType == dto.NotifyTypeGotify </span><span class="cov0" title="0">{
                                content = "{{value}}，当前剩余额度为 {{value}}，请及时充值。"
                                values = []interface{}{prompt, logger.FormatQuota(relayInfo.UserQuota)}
                        }</span> else<span class="cov0" title="0"> {
                                // 默认内容格式，适用于Email和Webhook（支持HTML）
                                content = "{{value}}，当前剩余额度为 {{value}}，为了不影响您的使用，请及时充值。&lt;br/&gt;充值链接：&lt;a href='{{value}}'&gt;{{value}}&lt;/a&gt;"
                                values = []interface{}{prompt, logger.FormatQuota(relayInfo.UserQuota), topUpLink, topUpLink}
                        }</span>

                        <span class="cov0" title="0">err := NotifyUser(relayInfo.UserId, relayInfo.UserEmail, relayInfo.UserSetting, dto.NewNotify(dto.NotifyTypeQuotaExceed, prompt, content, values))
                        if err != nil </span><span class="cov0" title="0">{
                                common.SysError(fmt.Sprintf("failed to send quota notify to user %d: %s", relayInfo.UserId, err.Error()))
                        }</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package service

import (
        "errors"
        "strings"

        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/setting"
)

func CheckSensitiveMessages(messages []dto.Message) ([]string, error) <span class="cov0" title="0">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">for _, message := range messages </span><span class="cov0" title="0">{
                arrayContent := message.ParseContent()
                for _, m := range arrayContent </span><span class="cov0" title="0">{
                        if m.Type == "image_url" </span><span class="cov0" title="0">{
                                // TODO: check image url
                                continue</span>
                        }
                        // 检查 text 是否为空
                        <span class="cov0" title="0">if m.Text == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if ok, words := SensitiveWordContains(m.Text); ok </span><span class="cov0" title="0">{
                                return words, errors.New("sensitive words detected")
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func CheckSensitiveText(text string) (bool, []string) <span class="cov0" title="0">{
        return SensitiveWordContains(text)
}</span>

// SensitiveWordContains 是否包含敏感词，返回是否包含敏感词和敏感词列表
func SensitiveWordContains(text string) (bool, []string) <span class="cov0" title="0">{
        if len(setting.SensitiveWords) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if len(text) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">checkText := strings.ToLower(text)
        return AcSearch(checkText, setting.SensitiveWords, true)</span>
}

// SensitiveWordReplace 敏感词替换，返回是否包含敏感词和替换后的文本
func SensitiveWordReplace(text string, returnImmediately bool) (bool, []string, string) <span class="cov0" title="0">{
        if len(setting.SensitiveWords) == 0 </span><span class="cov0" title="0">{
                return false, nil, text
        }</span>
        <span class="cov0" title="0">checkText := strings.ToLower(text)
        m := getOrBuildAC(setting.SensitiveWords)
        hits := m.MultiPatternSearch([]rune(checkText), returnImmediately)
        if len(hits) &gt; 0 </span><span class="cov0" title="0">{
                words := make([]string, 0, len(hits))
                var builder strings.Builder
                builder.Grow(len(text))
                lastPos := 0

                for _, hit := range hits </span><span class="cov0" title="0">{
                        pos := hit.Pos
                        word := string(hit.Word)
                        builder.WriteString(text[lastPos:pos])
                        builder.WriteString("**###**")
                        lastPos = pos + len(word)
                        words = append(words, word)
                }</span>
                <span class="cov0" title="0">builder.WriteString(text[lastPos:])
                return true, words, builder.String()</span>
        }
        <span class="cov0" title="0">return false, nil, text</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package service

import (
        "bytes"
        "fmt"
        "hash/fnv"
        "sort"
        "strings"
        "sync"

        goahocorasick "github.com/anknown/ahocorasick"
)

func SundaySearch(text string, pattern string) bool <span class="cov0" title="0">{
        // 计算偏移表
        offset := make(map[rune]int)
        for i, c := range pattern </span><span class="cov0" title="0">{
                offset[c] = len(pattern) - i
        }</span>

        // 文本串长度和模式串长度
        <span class="cov0" title="0">n, m := len(text), len(pattern)

        // 主循环，i表示当前对齐的文本串位置
        for i := 0; i &lt;= n-m; </span><span class="cov0" title="0">{
                // 检查子串
                j := 0
                for j &lt; m &amp;&amp; text[i+j] == pattern[j] </span><span class="cov0" title="0">{
                        j++
                }</span>
                // 如果完全匹配，返回匹配位置
                <span class="cov0" title="0">if j == m </span><span class="cov0" title="0">{
                        return true
                }</span>

                // 如果还有剩余字符，则检查下一位字符在偏移表中的值
                <span class="cov0" title="0">if i+m &lt; n </span><span class="cov0" title="0">{
                        next := rune(text[i+m])
                        if val, ok := offset[next]; ok </span><span class="cov0" title="0">{
                                i += val // 存在于偏移表中，进行跳跃
                        }</span> else<span class="cov0" title="0"> {
                                i += len(pattern) + 1 // 不存在于偏移表中，跳过整个模式串长度
                        }</span>
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">return false</span> // 如果没有找到匹配，返回-1
}

func RemoveDuplicate(s []string) []string <span class="cov0" title="0">{
        result := make([]string, 0, len(s))
        temp := map[string]struct{}{}
        for _, item := range s </span><span class="cov0" title="0">{
                if _, ok := temp[item]; !ok </span><span class="cov0" title="0">{
                        temp[item] = struct{}{}
                        result = append(result, item)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func InitAc(dict []string) *goahocorasick.Machine <span class="cov0" title="0">{
        m := new(goahocorasick.Machine)
        runes := readRunes(dict)
        if err := m.Build(runes); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return nil
        }</span>
        <span class="cov0" title="0">return m</span>
}

var acCache sync.Map

func acKey(dict []string) string <span class="cov0" title="0">{
        if len(dict) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">normalized := make([]string, 0, len(dict))
        for _, w := range dict </span><span class="cov0" title="0">{
                w = strings.ToLower(strings.TrimSpace(w))
                if w != "" </span><span class="cov0" title="0">{
                        normalized = append(normalized, w)
                }</span>
        }
        <span class="cov0" title="0">if len(normalized) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">sort.Strings(normalized)
        hasher := fnv.New64a()
        for _, w := range normalized </span><span class="cov0" title="0">{
                hasher.Write([]byte{0})
                hasher.Write([]byte(w))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum64())</span>
}

func getOrBuildAC(dict []string) *goahocorasick.Machine <span class="cov0" title="0">{
        key := acKey(dict)
        if key == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if v, ok := acCache.Load(key); ok </span><span class="cov0" title="0">{
                if m, ok2 := v.(*goahocorasick.Machine); ok2 </span><span class="cov0" title="0">{
                        return m
                }</span>
        }
        <span class="cov0" title="0">m := InitAc(dict)
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if actual, loaded := acCache.LoadOrStore(key, m); loaded </span><span class="cov0" title="0">{
                if cached, ok := actual.(*goahocorasick.Machine); ok </span><span class="cov0" title="0">{
                        return cached
                }</span>
        }
        <span class="cov0" title="0">return m</span>
}

func readRunes(dict []string) [][]rune <span class="cov0" title="0">{
        var runes [][]rune

        for _, word := range dict </span><span class="cov0" title="0">{
                word = strings.ToLower(word)
                l := bytes.TrimSpace([]byte(word))
                runes = append(runes, bytes.Runes(l))
        }</span>

        <span class="cov0" title="0">return runes</span>
}

func AcSearch(findText string, dict []string, stopImmediately bool) (bool, []string) <span class="cov0" title="0">{
        if len(dict) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if len(findText) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">m := getOrBuildAC(dict)
        if m == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">hits := m.MultiPatternSearch([]rune(findText), stopImmediately)
        if len(hits) &gt; 0 </span><span class="cov0" title="0">{
                words := make([]string, 0)
                for _, hit := range hits </span><span class="cov0" title="0">{
                        words = append(words, string(hit.Word))
                }</span>
                <span class="cov0" title="0">return true, words</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package service

import (
        "strings"

        "github.com/QuantumNous/new-api/constant"
)

func CoverTaskActionToModelName(platform constant.TaskPlatform, action string) string <span class="cov0" title="0">{
        return strings.ToLower(string(platform)) + "_" + strings.ToLower(action)
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "fmt"
        "image"
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"
        "log"
        "math"
        "path/filepath"
        "strings"
        "sync"
        "unicode/utf8"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        relaycommon "github.com/QuantumNous/new-api/relay/common"
        constant2 "github.com/QuantumNous/new-api/relay/constant"
        "github.com/QuantumNous/new-api/types"

        "github.com/gin-gonic/gin"
        "github.com/tiktoken-go/tokenizer"
        "github.com/tiktoken-go/tokenizer/codec"
)

// tokenEncoderMap won't grow after initialization
var defaultTokenEncoder tokenizer.Codec

// tokenEncoderMap is used to store token encoders for different models
var tokenEncoderMap = make(map[string]tokenizer.Codec)

// tokenEncoderMutex protects tokenEncoderMap for concurrent access
var tokenEncoderMutex sync.RWMutex

func InitTokenEncoders() <span class="cov0" title="0">{
        common.SysLog("initializing token encoders")
        defaultTokenEncoder = codec.NewCl100kBase()
        common.SysLog("token encoders initialized")
}</span>

func getTokenEncoder(model string) tokenizer.Codec <span class="cov0" title="0">{
        // First, try to get the encoder from cache with read lock
        tokenEncoderMutex.RLock()
        if encoder, exists := tokenEncoderMap[model]; exists </span><span class="cov0" title="0">{
                tokenEncoderMutex.RUnlock()
                return encoder
        }</span>
        <span class="cov0" title="0">tokenEncoderMutex.RUnlock()

        // If not in cache, create new encoder with write lock
        tokenEncoderMutex.Lock()
        defer tokenEncoderMutex.Unlock()

        // Double-check if another goroutine already created the encoder
        if encoder, exists := tokenEncoderMap[model]; exists </span><span class="cov0" title="0">{
                return encoder
        }</span>

        // Create new encoder
        <span class="cov0" title="0">modelCodec, err := tokenizer.ForModel(tokenizer.Model(model))
        if err != nil </span><span class="cov0" title="0">{
                // Cache the default encoder for this model to avoid repeated failures
                tokenEncoderMap[model] = defaultTokenEncoder
                return defaultTokenEncoder
        }</span>

        // Cache the new encoder
        <span class="cov0" title="0">tokenEncoderMap[model] = modelCodec
        return modelCodec</span>
}

func getTokenNum(tokenEncoder tokenizer.Codec, text string) int <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">tkm, _ := tokenEncoder.Count(text)
        return tkm</span>
}

func getImageToken(fileMeta *types.FileMeta, model string, stream bool) (int, error) <span class="cov0" title="0">{
        if fileMeta == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("image_url_is_nil")
        }</span>

        // Defaults for 4o/4.1/4.5 family unless overridden below
        <span class="cov0" title="0">baseTokens := 85
        tileTokens := 170

        // Model classification
        lowerModel := strings.ToLower(model)

        // Special cases from existing behavior
        if strings.HasPrefix(lowerModel, "glm-4") </span><span class="cov0" title="0">{
                return 1047, nil
        }</span>

        // Patch-based models (32x32 patches, capped at 1536, with multiplier)
        <span class="cov0" title="0">isPatchBased := false
        multiplier := 1.0
        switch </span>{
        case strings.Contains(lowerModel, "gpt-4.1-mini"):<span class="cov0" title="0">
                isPatchBased = true
                multiplier = 1.62</span>
        case strings.Contains(lowerModel, "gpt-4.1-nano"):<span class="cov0" title="0">
                isPatchBased = true
                multiplier = 2.46</span>
        case strings.HasPrefix(lowerModel, "o4-mini"):<span class="cov0" title="0">
                isPatchBased = true
                multiplier = 1.72</span>
        case strings.HasPrefix(lowerModel, "gpt-5-mini"):<span class="cov0" title="0">
                isPatchBased = true
                multiplier = 1.62</span>
        case strings.HasPrefix(lowerModel, "gpt-5-nano"):<span class="cov0" title="0">
                isPatchBased = true
                multiplier = 2.46</span>
        }

        // Tile-based model tokens and bases per doc
        <span class="cov0" title="0">if !isPatchBased </span><span class="cov0" title="0">{
                if strings.HasPrefix(lowerModel, "gpt-4o-mini") </span><span class="cov0" title="0">{
                        baseTokens = 2833
                        tileTokens = 5667
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(lowerModel, "gpt-5-chat-latest") || (strings.HasPrefix(lowerModel, "gpt-5") &amp;&amp; !strings.Contains(lowerModel, "mini") &amp;&amp; !strings.Contains(lowerModel, "nano")) </span><span class="cov0" title="0">{
                        baseTokens = 70
                        tileTokens = 140
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(lowerModel, "o1") || strings.HasPrefix(lowerModel, "o3") || strings.HasPrefix(lowerModel, "o1-pro") </span><span class="cov0" title="0">{
                        baseTokens = 75
                        tileTokens = 150
                }</span> else<span class="cov0" title="0"> if strings.Contains(lowerModel, "computer-use-preview") </span><span class="cov0" title="0">{
                        baseTokens = 65
                        tileTokens = 129
                }</span> else<span class="cov0" title="0"> if strings.Contains(lowerModel, "4.1") || strings.Contains(lowerModel, "4o") || strings.Contains(lowerModel, "4.5") </span><span class="cov0" title="0">{
                        baseTokens = 85
                        tileTokens = 170
                }</span>
        }

        // Respect existing feature flags/short-circuits
        <span class="cov0" title="0">if fileMeta.Detail == "low" &amp;&amp; !isPatchBased </span><span class="cov0" title="0">{
                return baseTokens, nil
        }</span>

        // Whether to count image tokens at all
        <span class="cov0" title="0">if !constant.GetMediaToken </span><span class="cov0" title="0">{
                return 3 * baseTokens, nil
        }</span>

        <span class="cov0" title="0">if !constant.GetMediaTokenNotStream &amp;&amp; !stream </span><span class="cov0" title="0">{
                return 3 * baseTokens, nil
        }</span>
        // Normalize detail
        <span class="cov0" title="0">if fileMeta.Detail == "auto" || fileMeta.Detail == "" </span><span class="cov0" title="0">{
                fileMeta.Detail = "high"
        }</span>

        // Decode image to get dimensions
        <span class="cov0" title="0">var config image.Config
        var err error
        var format string
        var b64str string

        if fileMeta.ParsedData != nil </span><span class="cov0" title="0">{
                config, format, b64str, err = DecodeBase64ImageData(fileMeta.ParsedData.Base64Data)
        }</span> else<span class="cov0" title="0"> {
                if strings.HasPrefix(fileMeta.OriginData, "http") </span><span class="cov0" title="0">{
                        config, format, err = DecodeUrlImageData(fileMeta.OriginData)
                }</span> else<span class="cov0" title="0"> {
                        common.SysLog(fmt.Sprintf("decoding image"))
                        config, format, b64str, err = DecodeBase64ImageData(fileMeta.OriginData)
                }</span>
                <span class="cov0" title="0">fileMeta.MimeType = format</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if config.Width == 0 || config.Height == 0 </span><span class="cov0" title="0">{
                // not an image
                if format != "" &amp;&amp; b64str != "" </span><span class="cov0" title="0">{
                        // file type
                        return 3 * baseTokens, nil
                }</span>
                <span class="cov0" title="0">return 0, errors.New(fmt.Sprintf("fail to decode base64 config: %s", fileMeta.OriginData))</span>
        }

        <span class="cov0" title="0">width := config.Width
        height := config.Height
        log.Printf("format: %s, width: %d, height: %d", format, width, height)

        if isPatchBased </span><span class="cov0" title="0">{
                // 32x32 patch-based calculation with 1536 cap and model multiplier
                ceilDiv := func(a, b int) int </span><span class="cov0" title="0">{ return (a + b - 1) / b }</span>
                <span class="cov0" title="0">rawPatchesW := ceilDiv(width, 32)
                rawPatchesH := ceilDiv(height, 32)
                rawPatches := rawPatchesW * rawPatchesH
                if rawPatches &gt; 1536 </span><span class="cov0" title="0">{
                        // scale down
                        area := float64(width * height)
                        r := math.Sqrt(float64(32*32*1536) / area)
                        wScaled := float64(width) * r
                        hScaled := float64(height) * r
                        // adjust to fit whole number of patches after scaling
                        adjW := math.Floor(wScaled/32.0) / (wScaled / 32.0)
                        adjH := math.Floor(hScaled/32.0) / (hScaled / 32.0)
                        adj := math.Min(adjW, adjH)
                        if !math.IsNaN(adj) &amp;&amp; adj &gt; 0 </span><span class="cov0" title="0">{
                                r = r * adj
                        }</span>
                        <span class="cov0" title="0">wScaled = float64(width) * r
                        hScaled = float64(height) * r
                        patchesW := math.Ceil(wScaled / 32.0)
                        patchesH := math.Ceil(hScaled / 32.0)
                        imageTokens := int(patchesW * patchesH)
                        if imageTokens &gt; 1536 </span><span class="cov0" title="0">{
                                imageTokens = 1536
                        }</span>
                        <span class="cov0" title="0">return int(math.Round(float64(imageTokens) * multiplier)), nil</span>
                }
                // below cap
                <span class="cov0" title="0">imageTokens := rawPatches
                return int(math.Round(float64(imageTokens) * multiplier)), nil</span>
        }

        // Tile-based calculation for 4o/4.1/4.5/o1/o3/etc.
        // Step 1: fit within 2048x2048 square
        <span class="cov0" title="0">maxSide := math.Max(float64(width), float64(height))
        fitScale := 1.0
        if maxSide &gt; 2048 </span><span class="cov0" title="0">{
                fitScale = maxSide / 2048.0
        }</span>
        <span class="cov0" title="0">fitW := int(math.Round(float64(width) / fitScale))
        fitH := int(math.Round(float64(height) / fitScale))

        // Step 2: scale so that shortest side is exactly 768
        minSide := math.Min(float64(fitW), float64(fitH))
        if minSide == 0 </span><span class="cov0" title="0">{
                return baseTokens, nil
        }</span>
        <span class="cov0" title="0">shortScale := 768.0 / minSide
        finalW := int(math.Round(float64(fitW) * shortScale))
        finalH := int(math.Round(float64(fitH) * shortScale))

        // Count 512px tiles
        tilesW := (finalW + 512 - 1) / 512
        tilesH := (finalH + 512 - 1) / 512
        tiles := tilesW * tilesH

        if common.DebugEnabled </span><span class="cov0" title="0">{
                log.Printf("scaled to: %dx%d, tiles: %d", finalW, finalH, tiles)
        }</span>

        <span class="cov0" title="0">return tiles*tileTokens + baseTokens, nil</span>
}

func CountRequestToken(c *gin.Context, meta *types.TokenCountMeta, info *relaycommon.RelayInfo) (int, error) <span class="cov0" title="0">{
        // 是否统计token
        if !constant.CountToken </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if meta == nil </span><span class="cov0" title="0">{
                return 0, errors.New("token count meta is nil")
        }</span>

        <span class="cov0" title="0">if info.RelayFormat == types.RelayFormatOpenAIRealtime </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if info.RelayMode == constant2.RelayModeAudioTranscription || info.RelayMode == constant2.RelayModeAudioTranslation </span><span class="cov0" title="0">{
                multiForm, err := common.ParseMultipartFormReusable(c)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("error parsing multipart form: %v", err)
                }</span>
                <span class="cov0" title="0">fileHeaders := multiForm.File["file"]
                totalAudioToken := 0
                for _, fileHeader := range fileHeaders </span><span class="cov0" title="0">{
                        file, err := fileHeader.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("error opening audio file: %v", err)
                        }</span>
                        <span class="cov0" title="0">defer file.Close()
                        // get ext and io.seeker
                        ext := filepath.Ext(fileHeader.Filename)
                        duration, err := common.GetAudioDuration(c.Request.Context(), file, ext)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("error getting audio duration: %v", err)
                        }</span>
                        // 一分钟 1000 token，与 $price / minute 对齐
                        <span class="cov0" title="0">totalAudioToken += int(math.Round(math.Ceil(duration) / 60.0 * 1000))</span>
                }
                <span class="cov0" title="0">return totalAudioToken, nil</span>
        }

        <span class="cov0" title="0">model := common.GetContextKeyString(c, constant.ContextKeyOriginalModel)
        tkm := 0

        if meta.TokenType == types.TokenTypeTextNumber </span><span class="cov0" title="0">{
                tkm += utf8.RuneCountInString(meta.CombineText)
        }</span> else<span class="cov0" title="0"> {
                tkm += CountTextToken(meta.CombineText, model)
        }</span>

        <span class="cov0" title="0">if info.RelayFormat == types.RelayFormatOpenAI </span><span class="cov0" title="0">{
                tkm += meta.ToolsCount * 8
                tkm += meta.MessagesCount * 3 // 每条消息的格式化token数量
                tkm += meta.NameCount * 3
                tkm += 3
        }</span>

        <span class="cov0" title="0">shouldFetchFiles := true

        if info.RelayFormat == types.RelayFormatGemini </span><span class="cov0" title="0">{
                shouldFetchFiles = false
        }</span>

        // 是否本地计算媒体token数量
        <span class="cov0" title="0">if !constant.GetMediaToken </span><span class="cov0" title="0">{
                shouldFetchFiles = false
        }</span>

        // 是否在非流模式下本地计算媒体token数量
        <span class="cov0" title="0">if !constant.GetMediaTokenNotStream &amp;&amp; !info.IsStream </span><span class="cov0" title="0">{
                shouldFetchFiles = false
        }</span>

        <span class="cov0" title="0">for _, file := range meta.Files </span><span class="cov0" title="0">{
                if strings.HasPrefix(file.OriginData, "http") </span><span class="cov0" title="0">{
                        if shouldFetchFiles </span><span class="cov0" title="0">{
                                mineType, err := GetFileTypeFromUrl(c, file.OriginData, "token_counter")
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("error getting file base64 from url: %v", err)
                                }</span>
                                <span class="cov0" title="0">if strings.HasPrefix(mineType, "image/") </span><span class="cov0" title="0">{
                                        file.FileType = types.FileTypeImage
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(mineType, "video/") </span><span class="cov0" title="0">{
                                        file.FileType = types.FileTypeVideo
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(mineType, "audio/") </span><span class="cov0" title="0">{
                                        file.FileType = types.FileTypeAudio
                                }</span> else<span class="cov0" title="0"> {
                                        file.FileType = types.FileTypeFile
                                }</span>
                                <span class="cov0" title="0">file.MimeType = mineType</span>
                        }
                } else<span class="cov0" title="0"> if strings.HasPrefix(file.OriginData, "data:") </span><span class="cov0" title="0">{
                        // get mime type from base64 header
                        parts := strings.SplitN(file.OriginData, ",", 2)
                        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                                header := parts[0]
                                // Extract mime type from "data:mime/type;base64" format
                                if strings.Contains(header, ":") &amp;&amp; strings.Contains(header, ";") </span><span class="cov0" title="0">{
                                        mimeStart := strings.Index(header, ":") + 1
                                        mimeEnd := strings.Index(header, ";")
                                        if mimeStart &lt; mimeEnd </span><span class="cov0" title="0">{
                                                mineType := header[mimeStart:mimeEnd]
                                                if strings.HasPrefix(mineType, "image/") </span><span class="cov0" title="0">{
                                                        file.FileType = types.FileTypeImage
                                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(mineType, "video/") </span><span class="cov0" title="0">{
                                                        file.FileType = types.FileTypeVideo
                                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(mineType, "audio/") </span><span class="cov0" title="0">{
                                                        file.FileType = types.FileTypeAudio
                                                }</span> else<span class="cov0" title="0"> {
                                                        file.FileType = types.FileTypeFile
                                                }</span>
                                                <span class="cov0" title="0">file.MimeType = mineType</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">for i, file := range meta.Files </span><span class="cov0" title="0">{
                switch file.FileType </span>{
                case types.FileTypeImage:<span class="cov0" title="0">
                        if info.RelayFormat == types.RelayFormatGemini </span><span class="cov0" title="0">{
                                tkm += 520 // gemini per input image tokens
                        }</span> else<span class="cov0" title="0"> {
                                token, err := getImageToken(file, model, info.IsStream)
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("error counting image token, media index[%d], original data[%s], err: %v", i, file.OriginData, err)
                                }</span>
                                <span class="cov0" title="0">tkm += token</span>
                        }
                case types.FileTypeAudio:<span class="cov0" title="0">
                        tkm += 256</span>
                case types.FileTypeVideo:<span class="cov0" title="0">
                        tkm += 4096 * 2</span>
                case types.FileTypeFile:<span class="cov0" title="0">
                        tkm += 4096</span>
                default:<span class="cov0" title="0">
                        tkm += 4096</span> // Default case for unknown file types
                }
        }

        <span class="cov0" title="0">common.SetContextKey(c, constant.ContextKeyPromptTokens, tkm)
        return tkm, nil</span>
}

func CountTokenClaudeRequest(request dto.ClaudeRequest, model string) (int, error) <span class="cov0" title="0">{
        tkm := 0

        // Count tokens in messages
        msgTokens, err := CountTokenClaudeMessages(request.Messages, model, request.Stream)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">tkm += msgTokens

        // Count tokens in system message
        if request.System != "" </span><span class="cov0" title="0">{
                systemTokens := CountTokenInput(request.System, model)
                tkm += systemTokens
        }</span>

        <span class="cov0" title="0">if request.Tools != nil </span><span class="cov0" title="0">{
                // check is array
                if tools, ok := request.Tools.([]any); ok </span><span class="cov0" title="0">{
                        if len(tools) &gt; 0 </span><span class="cov0" title="0">{
                                parsedTools, err1 := common.Any2Type[[]dto.Tool](request.Tools)
                                if err1 != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("tools: Input should be a valid list: %v", err)
                                }</span>
                                <span class="cov0" title="0">toolTokens, err2 := CountTokenClaudeTools(parsedTools, model)
                                if err2 != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("tools: %v", err)
                                }</span>
                                <span class="cov0" title="0">tkm += toolTokens</span>
                        }
                } else<span class="cov0" title="0"> {
                        return 0, errors.New("tools: Input should be a valid list")
                }</span>
        }

        <span class="cov0" title="0">return tkm, nil</span>
}

func CountTokenClaudeMessages(messages []dto.ClaudeMessage, model string, stream bool) (int, error) <span class="cov0" title="0">{
        tokenEncoder := getTokenEncoder(model)
        tokenNum := 0

        for _, message := range messages </span><span class="cov0" title="0">{
                // Count tokens for role
                tokenNum += getTokenNum(tokenEncoder, message.Role)
                if message.IsStringContent() </span><span class="cov0" title="0">{
                        tokenNum += getTokenNum(tokenEncoder, message.GetStringContent())
                }</span> else<span class="cov0" title="0"> {
                        content, err := message.ParseContent()
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">for _, mediaMessage := range content </span><span class="cov0" title="0">{
                                switch mediaMessage.Type </span>{
                                case "text":<span class="cov0" title="0">
                                        tokenNum += getTokenNum(tokenEncoder, mediaMessage.GetText())</span>
                                case "image":<span class="cov0" title="0">
                                        //imageTokenNum, err := getClaudeImageToken(mediaMsg.Source, model, stream)
                                        //if err != nil {
                                        //        return 0, err
                                        //}
                                        tokenNum += 1000</span>
                                case "tool_use":<span class="cov0" title="0">
                                        if mediaMessage.Input != nil </span><span class="cov0" title="0">{
                                                tokenNum += getTokenNum(tokenEncoder, mediaMessage.Name)
                                                inputJSON, _ := json.Marshal(mediaMessage.Input)
                                                tokenNum += getTokenNum(tokenEncoder, string(inputJSON))
                                        }</span>
                                case "tool_result":<span class="cov0" title="0">
                                        if mediaMessage.Content != nil </span><span class="cov0" title="0">{
                                                contentJSON, _ := json.Marshal(mediaMessage.Content)
                                                tokenNum += getTokenNum(tokenEncoder, string(contentJSON))
                                        }</span>
                                }
                        }
                }
        }

        // Add a constant for message formatting (this may need adjustment based on Claude's exact formatting)
        <span class="cov0" title="0">tokenNum += len(messages) * 2 // Assuming 2 tokens per message for formatting

        return tokenNum, nil</span>
}

func CountTokenClaudeTools(tools []dto.Tool, model string) (int, error) <span class="cov0" title="0">{
        tokenEncoder := getTokenEncoder(model)
        tokenNum := 0

        for _, tool := range tools </span><span class="cov0" title="0">{
                tokenNum += getTokenNum(tokenEncoder, tool.Name)
                tokenNum += getTokenNum(tokenEncoder, tool.Description)

                schemaJSON, err := json.Marshal(tool.InputSchema)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, errors.New(fmt.Sprintf("marshal_tool_schema_fail: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">tokenNum += getTokenNum(tokenEncoder, string(schemaJSON))</span>
        }

        // Add a constant for tool formatting (this may need adjustment based on Claude's exact formatting)
        <span class="cov0" title="0">tokenNum += len(tools) * 3 // Assuming 3 tokens per tool for formatting

        return tokenNum, nil</span>
}

func CountTokenRealtime(info *relaycommon.RelayInfo, request dto.RealtimeEvent, model string) (int, int, error) <span class="cov0" title="0">{
        audioToken := 0
        textToken := 0
        switch request.Type </span>{
        case dto.RealtimeEventTypeSessionUpdate:<span class="cov0" title="0">
                if request.Session != nil </span><span class="cov0" title="0">{
                        msgTokens := CountTextToken(request.Session.Instructions, model)
                        textToken += msgTokens
                }</span>
        case dto.RealtimeEventResponseAudioDelta:<span class="cov0" title="0">
                // count audio token
                atk, err := CountAudioTokenOutput(request.Delta, info.OutputAudioFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("error counting audio token: %v", err)
                }</span>
                <span class="cov0" title="0">audioToken += atk</span>
        case dto.RealtimeEventResponseAudioTranscriptionDelta, dto.RealtimeEventResponseFunctionCallArgumentsDelta:<span class="cov0" title="0">
                // count text token
                tkm := CountTextToken(request.Delta, model)
                textToken += tkm</span>
        case dto.RealtimeEventInputAudioBufferAppend:<span class="cov0" title="0">
                // count audio token
                atk, err := CountAudioTokenInput(request.Audio, info.InputAudioFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("error counting audio token: %v", err)
                }</span>
                <span class="cov0" title="0">audioToken += atk</span>
        case dto.RealtimeEventConversationItemCreated:<span class="cov0" title="0">
                if request.Item != nil </span><span class="cov0" title="0">{
                        switch request.Item.Type </span>{
                        case "message":<span class="cov0" title="0">
                                for _, content := range request.Item.Content </span><span class="cov0" title="0">{
                                        if content.Type == "input_text" </span><span class="cov0" title="0">{
                                                tokens := CountTextToken(content.Text, model)
                                                textToken += tokens
                                        }</span>
                                }
                        }
                }
        case dto.RealtimeEventTypeResponseDone:<span class="cov0" title="0">
                // count tools token
                if !info.IsFirstRequest </span><span class="cov0" title="0">{
                        if info.RealtimeTools != nil &amp;&amp; len(info.RealtimeTools) &gt; 0 </span><span class="cov0" title="0">{
                                for _, tool := range info.RealtimeTools </span><span class="cov0" title="0">{
                                        toolTokens := CountTokenInput(tool, model)
                                        textToken += 8
                                        textToken += toolTokens
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return textToken, audioToken, nil</span>
}

func CountTokenInput(input any, model string) int <span class="cov0" title="0">{
        switch v := input.(type) </span>{
        case string:<span class="cov0" title="0">
                return CountTextToken(v, model)</span>
        case []string:<span class="cov0" title="0">
                text := ""
                for _, s := range v </span><span class="cov0" title="0">{
                        text += s
                }</span>
                <span class="cov0" title="0">return CountTextToken(text, model)</span>
        case []interface{}:<span class="cov0" title="0">
                text := ""
                for _, item := range v </span><span class="cov0" title="0">{
                        text += fmt.Sprintf("%v", item)
                }</span>
                <span class="cov0" title="0">return CountTextToken(text, model)</span>
        }
        <span class="cov0" title="0">return CountTokenInput(fmt.Sprintf("%v", input), model)</span>
}

func CountTokenStreamChoices(messages []dto.ChatCompletionsStreamResponseChoice, model string) int <span class="cov0" title="0">{
        tokens := 0
        for _, message := range messages </span><span class="cov0" title="0">{
                tkm := CountTokenInput(message.Delta.GetContentString(), model)
                tokens += tkm
                if message.Delta.ToolCalls != nil </span><span class="cov0" title="0">{
                        for _, tool := range message.Delta.ToolCalls </span><span class="cov0" title="0">{
                                tkm := CountTokenInput(tool.Function.Name, model)
                                tokens += tkm
                                tkm = CountTokenInput(tool.Function.Arguments, model)
                                tokens += tkm
                        }</span>
                }
        }
        <span class="cov0" title="0">return tokens</span>
}

func CountTTSToken(text string, model string) int <span class="cov0" title="0">{
        if strings.HasPrefix(model, "tts") </span><span class="cov0" title="0">{
                return utf8.RuneCountInString(text)
        }</span> else<span class="cov0" title="0"> {
                return CountTextToken(text, model)
        }</span>
}

func CountAudioTokenInput(audioBase64 string, audioFormat string) (int, error) <span class="cov0" title="0">{
        if audioBase64 == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">duration, err := parseAudio(audioBase64, audioFormat)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(duration / 60 * 100 / 0.06), nil</span>
}

func CountAudioTokenOutput(audioBase64 string, audioFormat string) (int, error) <span class="cov0" title="0">{
        if audioBase64 == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">duration, err := parseAudio(audioBase64, audioFormat)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(duration / 60 * 200 / 0.24), nil</span>
}

//func CountAudioToken(sec float64, audioType string) {
//        if audioType == "input" {
//
//        }
//}

// CountTextToken 统计文本的token数量，仅当文本包含敏感词，返回错误，同时返回token数量
func CountTextToken(text string, model string) int <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">tokenEncoder := getTokenEncoder(model)
        return getTokenNum(tokenEncoder, text)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package service

import (
        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/constant"
        "github.com/QuantumNous/new-api/dto"
        "github.com/gin-gonic/gin"
)

//func GetPromptTokens(textRequest dto.GeneralOpenAIRequest, relayMode int) (int, error) {
//        switch relayMode {
//        case constant.RelayModeChatCompletions:
//                return CountTokenMessages(textRequest.Messages, textRequest.Model)
//        case constant.RelayModeCompletions:
//                return CountTokenInput(textRequest.Prompt, textRequest.Model), nil
//        case constant.RelayModeModerations:
//                return CountTokenInput(textRequest.Input, textRequest.Model), nil
//        }
//        return 0, errors.New("unknown relay mode")
//}

func ResponseText2Usage(c *gin.Context, responseText string, modeName string, promptTokens int) *dto.Usage <span class="cov0" title="0">{
        common.SetContextKey(c, constant.ContextKeyLocalCountTokens, true)
        usage := &amp;dto.Usage{}
        usage.PromptTokens = promptTokens
        ctkm := CountTextToken(responseText, modeName)
        usage.CompletionTokens = ctkm
        usage.TotalTokens = usage.PromptTokens + usage.CompletionTokens
        return usage
}</span>

func ValidUsage(usage *dto.Usage) bool <span class="cov0" title="0">{
        return usage != nil &amp;&amp; (usage.PromptTokens != 0 || usage.CompletionTokens != 0)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package service

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/model"
        "github.com/QuantumNous/new-api/setting/system_setting"
)

func NotifyRootUser(t string, subject string, content string) <span class="cov0" title="0">{
        user := model.GetRootUser().ToBaseUser()
        err := NotifyUser(user.Id, user.Email, user.GetSetting(), dto.NewNotify(t, subject, content, nil))
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to notify root user: %s", err.Error()))
        }</span>
}

func NotifyUser(userId int, userEmail string, userSetting dto.UserSetting, data dto.Notify) error <span class="cov0" title="0">{
        notifyType := userSetting.NotifyType
        if notifyType == "" </span><span class="cov0" title="0">{
                notifyType = dto.NotifyTypeEmail
        }</span>

        // Check notification limit
        <span class="cov0" title="0">canSend, err := CheckNotificationLimit(userId, data.Type)
        if err != nil </span><span class="cov0" title="0">{
                common.SysLog(fmt.Sprintf("failed to check notification limit: %s", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">if !canSend </span><span class="cov0" title="0">{
                return fmt.Errorf("notification limit exceeded for user %d with type %s", userId, notifyType)
        }</span>

        <span class="cov0" title="0">switch notifyType </span>{
        case dto.NotifyTypeEmail:<span class="cov0" title="0">
                // 优先使用设置中的通知邮箱，如果为空则使用用户的默认邮箱
                emailToUse := userSetting.NotificationEmail
                if emailToUse == "" </span><span class="cov0" title="0">{
                        emailToUse = userEmail
                }</span>
                <span class="cov0" title="0">if emailToUse == "" </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("user %d has no email, skip sending email", userId))
                        return nil
                }</span>
                <span class="cov0" title="0">return sendEmailNotify(emailToUse, data)</span>
        case dto.NotifyTypeWebhook:<span class="cov0" title="0">
                webhookURLStr := userSetting.WebhookUrl
                if webhookURLStr == "" </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("user %d has no webhook url, skip sending webhook", userId))
                        return nil
                }</span>

                // 获取 webhook secret
                <span class="cov0" title="0">webhookSecret := userSetting.WebhookSecret
                return SendWebhookNotify(webhookURLStr, webhookSecret, data)</span>
        case dto.NotifyTypeBark:<span class="cov0" title="0">
                barkURL := userSetting.BarkUrl
                if barkURL == "" </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("user %d has no bark url, skip sending bark", userId))
                        return nil
                }</span>
                <span class="cov0" title="0">return sendBarkNotify(barkURL, data)</span>
        case dto.NotifyTypeGotify:<span class="cov0" title="0">
                gotifyUrl := userSetting.GotifyUrl
                gotifyToken := userSetting.GotifyToken
                if gotifyUrl == "" || gotifyToken == "" </span><span class="cov0" title="0">{
                        common.SysLog(fmt.Sprintf("user %d has no gotify url or token, skip sending gotify", userId))
                        return nil
                }</span>
                <span class="cov0" title="0">return sendGotifyNotify(gotifyUrl, gotifyToken, userSetting.GotifyPriority, data)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func sendEmailNotify(userEmail string, data dto.Notify) error <span class="cov0" title="0">{
        // make email content
        content := data.Content
        // 处理占位符
        for _, value := range data.Values </span><span class="cov0" title="0">{
                content = strings.Replace(content, dto.ContentValueParam, fmt.Sprintf("%v", value), 1)
        }</span>
        <span class="cov0" title="0">return common.SendEmail(data.Title, userEmail, content)</span>
}

func sendBarkNotify(barkURL string, data dto.Notify) error <span class="cov0" title="0">{
        // 处理占位符
        content := data.Content
        for _, value := range data.Values </span><span class="cov0" title="0">{
                content = strings.Replace(content, dto.ContentValueParam, fmt.Sprintf("%v", value), 1)
        }</span>

        // 替换模板变量
        <span class="cov0" title="0">finalURL := strings.ReplaceAll(barkURL, "{{title}}", url.QueryEscape(data.Title))
        finalURL = strings.ReplaceAll(finalURL, "{{content}}", url.QueryEscape(content))

        // 发送GET请求到Bark
        var req *http.Request
        var resp *http.Response
        var err error

        if system_setting.EnableWorker() </span><span class="cov0" title="0">{
                // 使用worker发送请求
                workerReq := &amp;WorkerRequest{
                        URL:    finalURL,
                        Key:    system_setting.WorkerValidKey,
                        Method: http.MethodGet,
                        Headers: map[string]string{
                                "User-Agent": "OneAPI-Bark-Notify/1.0",
                        },
                }

                resp, err = DoWorkerRequest(workerReq)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send bark request through worker: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("bark request failed with status code: %d", resp.StatusCode)
                }</span>
        } else<span class="cov0" title="0"> {
                // SSRF防护：验证Bark URL（非Worker模式）
                fetchSetting := system_setting.GetFetchSetting()
                if err := common.ValidateURLWithFetchSetting(finalURL, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("request reject: %v", err)
                }</span>

                // 直接发送请求
                <span class="cov0" title="0">req, err = http.NewRequest(http.MethodGet, finalURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create bark request: %v", err)
                }</span>

                // 设置User-Agent
                <span class="cov0" title="0">req.Header.Set("User-Agent", "OneAPI-Bark-Notify/1.0")

                // 发送请求
                client := GetHttpClient()
                resp, err = client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send bark request: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("bark request failed with status code: %d", resp.StatusCode)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func sendGotifyNotify(gotifyUrl string, gotifyToken string, priority int, data dto.Notify) error <span class="cov0" title="0">{
        // 处理占位符
        content := data.Content
        for _, value := range data.Values </span><span class="cov0" title="0">{
                content = strings.Replace(content, dto.ContentValueParam, fmt.Sprintf("%v", value), 1)
        }</span>

        // 构建完整的 Gotify API URL
        // 确保 URL 以 /message 结尾
        <span class="cov0" title="0">finalURL := strings.TrimSuffix(gotifyUrl, "/") + "/message?token=" + url.QueryEscape(gotifyToken)

        // Gotify优先级范围0-10，如果超出范围则使用默认值5
        if priority &lt; 0 || priority &gt; 10 </span><span class="cov0" title="0">{
                priority = 5
        }</span>

        // 构建 JSON payload
        <span class="cov0" title="0">type GotifyMessage struct {
                Title    string `json:"title"`
                Message  string `json:"message"`
                Priority int    `json:"priority"`
        }

        payload := GotifyMessage{
                Title:    data.Title,
                Message:  content,
                Priority: priority,
        }

        // 序列化为 JSON
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal gotify payload: %v", err)
        }</span>

        <span class="cov0" title="0">var req *http.Request
        var resp *http.Response

        if system_setting.EnableWorker() </span><span class="cov0" title="0">{
                // 使用worker发送请求
                workerReq := &amp;WorkerRequest{
                        URL:    finalURL,
                        Key:    system_setting.WorkerValidKey,
                        Method: http.MethodPost,
                        Headers: map[string]string{
                                "Content-Type": "application/json; charset=utf-8",
                                "User-Agent":   "OneAPI-Gotify-Notify/1.0",
                        },
                        Body: payloadBytes,
                }

                resp, err = DoWorkerRequest(workerReq)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send gotify request through worker: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("gotify request failed with status code: %d", resp.StatusCode)
                }</span>
        } else<span class="cov0" title="0"> {
                // SSRF防护：验证Gotify URL（非Worker模式）
                fetchSetting := system_setting.GetFetchSetting()
                if err := common.ValidateURLWithFetchSetting(finalURL, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("request reject: %v", err)
                }</span>

                // 直接发送请求
                <span class="cov0" title="0">req, err = http.NewRequest(http.MethodPost, finalURL, bytes.NewBuffer(payloadBytes))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create gotify request: %v", err)
                }</span>

                // 设置请求头
                <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json; charset=utf-8")
                req.Header.Set("User-Agent", "NewAPI-Gotify-Notify/1.0")

                // 发送请求
                client := GetHttpClient()
                resp, err = client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send gotify request: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("gotify request failed with status code: %d", resp.StatusCode)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package service

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/QuantumNous/new-api/common"
        "github.com/QuantumNous/new-api/dto"
        "github.com/QuantumNous/new-api/setting/system_setting"
)

// WebhookPayload webhook 通知的负载数据
type WebhookPayload struct {
        Type      string        `json:"type"`
        Title     string        `json:"title"`
        Content   string        `json:"content"`
        Values    []interface{} `json:"values,omitempty"`
        Timestamp int64         `json:"timestamp"`
}

// generateSignature 生成 webhook 签名
func generateSignature(secret string, payload []byte) string <span class="cov0" title="0">{
        h := hmac.New(sha256.New, []byte(secret))
        h.Write(payload)
        return hex.EncodeToString(h.Sum(nil))
}</span>

// SendWebhookNotify 发送 webhook 通知
func SendWebhookNotify(webhookURL string, secret string, data dto.Notify) error <span class="cov0" title="0">{
        // 处理占位符
        content := data.Content
        for _, value := range data.Values </span><span class="cov0" title="0">{
                content = fmt.Sprintf(content, value)
        }</span>

        // 构建 webhook 负载
        <span class="cov0" title="0">payload := WebhookPayload{
                Type:      data.Type,
                Title:     data.Title,
                Content:   content,
                Values:    data.Values,
                Timestamp: time.Now().Unix(),
        }

        // 序列化负载
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal webhook payload: %v", err)
        }</span>

        // 创建 HTTP 请求
        <span class="cov0" title="0">var req *http.Request
        var resp *http.Response

        if system_setting.EnableWorker() </span><span class="cov0" title="0">{
                // 构建worker请求数据
                workerReq := &amp;WorkerRequest{
                        URL:    webhookURL,
                        Key:    system_setting.WorkerValidKey,
                        Method: http.MethodPost,
                        Headers: map[string]string{
                                "Content-Type": "application/json",
                        },
                        Body: payloadBytes,
                }

                // 如果有secret，添加签名到headers
                if secret != "" </span><span class="cov0" title="0">{
                        signature := generateSignature(secret, payloadBytes)
                        workerReq.Headers["X-Webhook-Signature"] = signature
                        workerReq.Headers["Authorization"] = "Bearer " + secret
                }</span>

                <span class="cov0" title="0">resp, err = DoWorkerRequest(workerReq)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send webhook request through worker: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("webhook request failed with status code: %d", resp.StatusCode)
                }</span>
        } else<span class="cov0" title="0"> {
                // SSRF防护：验证Webhook URL（非Worker模式）
                fetchSetting := system_setting.GetFetchSetting()
                if err := common.ValidateURLWithFetchSetting(webhookURL, fetchSetting.EnableSSRFProtection, fetchSetting.AllowPrivateIp, fetchSetting.DomainFilterMode, fetchSetting.IpFilterMode, fetchSetting.DomainList, fetchSetting.IpList, fetchSetting.AllowedPorts, fetchSetting.ApplyIPFilterForDomain); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("request reject: %v", err)
                }</span>

                <span class="cov0" title="0">req, err = http.NewRequest(http.MethodPost, webhookURL, bytes.NewBuffer(payloadBytes))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create webhook request: %v", err)
                }</span>

                // 设置请求头
                <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

                // 如果有 secret，生成签名
                if secret != "" </span><span class="cov0" title="0">{
                        signature := generateSignature(secret, payloadBytes)
                        req.Header.Set("X-Webhook-Signature", signature)
                }</span>

                // 发送请求
                <span class="cov0" title="0">client := GetHttpClient()
                resp, err = client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send webhook request: %v", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // 检查响应状态
                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("webhook request failed with status code: %d", resp.StatusCode)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

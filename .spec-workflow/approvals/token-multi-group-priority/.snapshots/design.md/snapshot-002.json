{
  "id": "snapshot_1764508906296_6ibay8c4h",
  "approvalId": "approval_1764508555479_q3gpcdu86",
  "approvalTitle": "设计规格文档 - 令牌多分组优先级管理",
  "version": 2,
  "timestamp": "2025-11-30T13:21:46.296Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# 设计规格文档: 令牌多分组优先级管理\n\n**项目**: New API - AI网关与资产管理系统\n**功能**: 令牌多分组优先级管理\n**创建日期**: 2025-11-30\n**文档状态**: 草稿\n\n---\n\n## 1. 架构设计\n\n### 1.1 整体架构\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         前端层 (React)                        │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ EditTokenModal                                       │   │\n│  │ - 多分组选择器 (带拖动排序)                          │   │\n│  │ - 自动智能分组开关                                    │   │\n│  │ - 功能说明提示                                        │   │\n│  └─────────────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ TokensTable                                          │   │\n│  │ - 分组优先级展示 (group1 > group2 > group3)         │   │\n│  └─────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n                              ↓ HTTP API\n┌─────────────────────────────────────────────────────────────┐\n│                      后端层 (Go + Gin)                        │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ controller/token.go                                  │   │\n│  │ - AddToken() / UpdateToken()                         │   │\n│  │ - 验证并保存多分组配置                                │   │\n│  └─────────────────────────────────────────────────────┘   │\n│                              ↓                               │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ middleware/distributor.go                            │   │\n│  │ - Distribute() 中间件                                 │   │\n│  │ - 多分组优先级转发逻辑                                │   │\n│  └─────────────────────────────────────────────────────┘   │\n│                              ↓                               │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ service/channel_select.go (新增)                     │   │\n│  │ - SelectChannelWithPriority()                        │   │\n│  │ - 按优先级遍历分组选择渠道                            │   │\n│  │ - 自动智能分组降级逻辑                                │   │\n│  └─────────────────────────────────────────────────────┘   │\n│                              ↓                               │\n│  ┌─────────────────────────────────────────────────────┐   │\n│  │ model/token.go                                       │   │\n│  │ - Token struct (新增 GroupPriorities 字段)           │   │\n│  │ - GetGroupPriorities() / SetGroupPriorities()        │   │\n│  └─────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────┐\n│                       存储层                                 │\n│  ┌─────────────┐           ┌───────────────────────────┐   │\n│  │   Redis     │           │   PostgreSQL/MySQL        │   │\n│  │   缓存层     │  ←同步→   │   持久化层                 │   │\n│  │  token:xxx  │           │   tokens 表                │   │\n│  └─────────────┘           └───────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### 1.2 分层职责\n\n#### Controller 层\n- **职责**: 处理 HTTP 请求、参数验证、响应格式化\n- **核心逻辑**:\n  - 验证多分组配置的合法性\n  - 调用 Model 层保存数据\n  - 不包含业务逻辑\n\n#### Middleware 层\n- **职责**: 请求拦截、令牌验证、分组选择\n- **核心逻辑**:\n  - 从 context 获取令牌信息\n  - 调用 Service 层选择合适的渠道\n  - 设置 context 供后续处理使用\n\n#### Service 层\n- **职责**: 实现核心业务逻辑\n- **核心逻辑**:\n  - 多分组优先级遍历\n  - 自动智能分组降级\n  - 渠道可用性判断\n\n#### Model 层\n- **职责**: 数据模型定义、数据库操作、缓存操作\n- **核心逻辑**:\n  - Token 结构体扩展\n  - GroupPriorities JSON 序列化/反序列化\n  - Redis 缓存同步\n\n---\n\n## 2. 数据模型设计\n\n### 2.1 数据库表结构\n\n#### tokens 表 (已有表，新增字段)\n\n```sql\n-- 新增字段\nALTER TABLE tokens ADD COLUMN group_priorities VARCHAR(2048) DEFAULT '' COMMENT 'JSON格式的多分组优先级配置';\nALTER TABLE tokens ADD COLUMN auto_smart_group BOOLEAN DEFAULT false COMMENT '是否启用自动智能分组';\n\n-- 保留原有 group 字段用于向后兼容\n-- group VARCHAR(255) DEFAULT '' COMMENT '单分组(向后兼容)';\n```\n\n### 2.2 Go 数据结构\n\n#### Token 结构体扩展\n\n```go\n// model/token.go\n\ntype Token struct {\n    Id                 int            `json:\"id\"`\n    UserId             int            `json:\"user_id\" gorm:\"index\"`\n    Key                string         `json:\"key\" gorm:\"type:char(48);uniqueIndex\"`\n    Status             int            `json:\"status\" gorm:\"default:1\"`\n    Name               string         `json:\"name\" gorm:\"index\"`\n    CreatedTime        int64          `json:\"created_time\" gorm:\"bigint\"`\n    AccessedTime       int64          `json:\"accessed_time\" gorm:\"bigint\"`\n    ExpiredTime        int64          `json:\"expired_time\" gorm:\"bigint;default:-1\"`\n    RemainQuota        int            `json:\"remain_quota\" gorm:\"default:0\"`\n    UnlimitedQuota     bool           `json:\"unlimited_quota\"`\n    ModelLimitsEnabled bool           `json:\"model_limits_enabled\"`\n    ModelLimits        string         `json:\"model_limits\" gorm:\"type:varchar(1024);default:''\"`\n    AllowIps           *string        `json:\"allow_ips\" gorm:\"default:''\"`\n    Group              string         `json:\"group\" gorm:\"default:''\"` // 向后兼容\n    GroupPriorities    string         `json:\"group_priorities\" gorm:\"type:varchar(2048);default:''\"` // 新增\n    AutoSmartGroup     bool           `json:\"auto_smart_group\" gorm:\"default:false\"` // 新增\n    DeletedAt          gorm.DeletedAt `gorm:\"index\"`\n}\n\n// GroupPriority 分组优先级结构\ntype GroupPriority struct {\n    Group    string `json:\"group\"`\n    Priority int    `json:\"priority\"`\n}\n\n// GetGroupPriorities 获取分组优先级列表\nfunc (token *Token) GetGroupPriorities() ([]GroupPriority, error) {\n    if token.GroupPriorities == \"\" {\n        // 向后兼容：如果没有配置多分组，使用 Group 字段\n        if token.Group != \"\" {\n            return []GroupPriority{{Group: token.Group, Priority: 1}}, nil\n        }\n        return []GroupPriority{}, nil\n    }\n\n    var priorities []GroupPriority\n    err := json.Unmarshal([]byte(token.GroupPriorities), &priorities)\n    if err != nil {\n        return nil, err\n    }\n\n    // 按优先级排序\n    sort.Slice(priorities, func(i, j int) bool {\n        return priorities[i].Priority < priorities[j].Priority\n    })\n\n    return priorities, nil\n}\n\n// SetGroupPriorities 设置分组优先级列表\nfunc (token *Token) SetGroupPriorities(priorities []GroupPriority) error {\n    if len(priorities) == 0 {\n        token.GroupPriorities = \"\"\n        return nil\n    }\n\n    // 验证优先级\n    for i, p := range priorities {\n        if p.Group == \"\" {\n            return errors.New(\"分组名称不能为空\")\n        }\n        if p.Priority < 1 {\n            return errors.New(\"优先级必须大于0\")\n        }\n        // 检查重复\n        for j := i + 1; j < len(priorities); j++ {\n            if priorities[j].Group == p.Group {\n                return errors.New(\"分组不能重复\")\n            }\n        }\n    }\n\n    data, err := json.Marshal(priorities)\n    if err != nil {\n        return err\n    }\n\n    token.GroupPriorities = string(data)\n\n    // 同步更新 Group 字段为第一个分组（向后兼容）\n    if len(priorities) > 0 {\n        sort.Slice(priorities, func(i, j int) bool {\n            return priorities[i].Priority < priorities[j].Priority\n        })\n        token.Group = priorities[0].Group\n    }\n\n    return nil\n}\n```\n\n### 2.3 前端数据结构\n\n```typescript\n// web/src/types/token.ts\n\ninterface GroupPriority {\n  group: string;\n  priority: number;\n}\n\ninterface Token {\n  id: number;\n  user_id: number;\n  name: string;\n  status: number;\n  created_time: number;\n  accessed_time: number;\n  expired_time: number;\n  remain_quota: number;\n  unlimited_quota: boolean;\n  model_limits_enabled: boolean;\n  model_limits: string;\n  allow_ips: string;\n  group: string; // 单分组（向后兼容）\n  group_priorities: string; // JSON 字符串\n  auto_smart_group: boolean; // 自动智能分组\n}\n\n// 辅助函数\nfunction parseGroupPriorities(token: Token): GroupPriority[] {\n  if (!token.group_priorities) {\n    // 向后兼容：返回单分组\n    if (token.group) {\n      return [{ group: token.group, priority: 1 }];\n    }\n    return [];\n  }\n  try {\n    const priorities: GroupPriority[] = JSON.parse(token.group_priorities);\n    return priorities.sort((a, b) => a.priority - b.priority);\n  } catch (e) {\n    console.error('Failed to parse group_priorities:', e);\n    return [];\n  }\n}\n\nfunction formatGroupPrioritiesDisplay(token: Token): string {\n  const priorities = parseGroupPriorities(token);\n  return priorities.map(p => p.group).join(' > ');\n}\n```\n\n---\n\n## 3. API 设计\n\n### 3.1 创建令牌 API\n\n**现有 API**: `POST /api/token/`\n\n**Request Body 扩展**:\n```json\n{\n  \"name\": \"my-token\",\n  \"expired_time\": 1735660800,\n  \"remain_quota\": 5000000,\n  \"unlimited_quota\": false,\n  \"model_limits_enabled\": false,\n  \"model_limits\": \"\",\n  \"allow_ips\": \"\",\n  \"group\": \"default\", // 保留向后兼容\n  \"group_priorities\": [ // 新增\n    { \"group\": \"gpt-4-group\", \"priority\": 1 },\n    { \"group\": \"claude-group\", \"priority\": 2 },\n    { \"group\": \"default\", \"priority\": 3 }\n  ],\n  \"auto_smart_group\": true // 新增\n}\n```\n\n**Response**:\n```json\n{\n  \"success\": true,\n  \"message\": \"\",\n  \"data\": null\n}\n```\n\n**Controller 层处理逻辑**:\n```go\n// controller/token.go\n\nfunc AddToken(c *gin.Context) {\n    var tokenInput struct {\n        Name               string                  `json:\"name\"`\n        ExpiredTime        int64                   `json:\"expired_time\"`\n        RemainQuota        int                     `json:\"remain_quota\"`\n        UnlimitedQuota     bool                    `json:\"unlimited_quota\"`\n        ModelLimitsEnabled bool                    `json:\"model_limits_enabled\"`\n        ModelLimits        string                  `json:\"model_limits\"`\n        AllowIps           *string                 `json:\"allow_ips\"`\n        Group              string                  `json:\"group\"` // 向后兼容\n        GroupPriorities    []model.GroupPriority   `json:\"group_priorities\"` // 新增\n        AutoSmartGroup     bool                    `json:\"auto_smart_group\"` // 新增\n    }\n\n    err := c.ShouldBindJSON(&tokenInput)\n    if err != nil {\n        common.ApiError(c, err)\n        return\n    }\n\n    // 验证分组配置\n    if len(tokenInput.GroupPriorities) > 10 {\n        c.JSON(http.StatusOK, gin.H{\n            \"success\": false,\n            \"message\": \"最多支持配置10个分组\",\n        })\n        return\n    }\n\n    // 生成令牌key\n    key, err := common.GenerateKey()\n    if err != nil {\n        c.JSON(http.StatusOK, gin.H{\n            \"success\": false,\n            \"message\": \"生成令牌失败\",\n        })\n        return\n    }\n\n    cleanToken := model.Token{\n        UserId:             c.GetInt(\"id\"),\n        Name:               tokenInput.Name,\n        Key:                key,\n        CreatedTime:        common.GetTimestamp(),\n        AccessedTime:       common.GetTimestamp(),\n        ExpiredTime:        tokenInput.ExpiredTime,\n        RemainQuota:        tokenInput.RemainQuota,\n        UnlimitedQuota:     tokenInput.UnlimitedQuota,\n        ModelLimitsEnabled: tokenInput.ModelLimitsEnabled,\n        ModelLimits:        tokenInput.ModelLimits,\n        AllowIps:           tokenInput.AllowIps,\n        AutoSmartGroup:     tokenInput.AutoSmartGroup,\n    }\n\n    // 设置分组优先级\n    if len(tokenInput.GroupPriorities) > 0 {\n        err = cleanToken.SetGroupPriorities(tokenInput.GroupPriorities)\n        if err != nil {\n            c.JSON(http.StatusOK, gin.H{\n                \"success\": false,\n                \"message\": \"分组配置错误: \" + err.Error(),\n            })\n            return\n        }\n    } else if tokenInput.Group != \"\" {\n        // 向后兼容：单分组\n        cleanToken.Group = tokenInput.Group\n    }\n\n    err = cleanToken.Insert()\n    if err != nil {\n        common.ApiError(c, err)\n        return\n    }\n\n    c.JSON(http.StatusOK, gin.H{\n        \"success\": true,\n        \"message\": \"\",\n    })\n}\n```\n\n### 3.2 更新令牌 API\n\n**现有 API**: `PUT /api/token/`\n\n**处理逻辑**: 与创建类似，增加对 `group_priorities` 和 `auto_smart_group` 的更新\n\n```go\n// model/token.go 的 Update 方法需要扩展\n\nfunc (token *Token) Update() (err error) {\n    defer func() {\n        if shouldUpdateRedis(true, err) {\n            gopool.Go(func() {\n                err := cacheSetToken(*token)\n                if err != nil {\n                    common.SysLog(\"failed to update token cache: \" + err.Error())\n                }\n            })\n        }\n    }()\n    err = DB.Model(token).Select(\"name\", \"status\", \"expired_time\", \"remain_quota\", \"unlimited_quota\",\n        \"model_limits_enabled\", \"model_limits\", \"allow_ips\", \"group\", \"group_priorities\", \"auto_smart_group\").Updates(token).Error\n    return err\n}\n```\n\n### 3.3 获取令牌列表 API\n\n**现有 API**: `GET /api/token/`\n\n**Response 扩展**:\n```json\n{\n  \"success\": true,\n  \"message\": \"\",\n  \"data\": {\n    \"items\": [\n      {\n        \"id\": 1,\n        \"name\": \"my-token\",\n        \"status\": 1,\n        \"group\": \"gpt-4-group\",\n        \"group_priorities\": \"[{\\\"group\\\":\\\"gpt-4-group\\\",\\\"priority\\\":1},{\\\"group\\\":\\\"claude-group\\\",\\\"priority\\\":2}]\",\n        \"auto_smart_group\": true,\n        ...\n      }\n    ],\n    \"total\": 10,\n    \"page\": 1,\n    \"page_size\": 10\n  }\n}\n```\n\n---\n\n## 4. 转发逻辑设计\n\n### 4.1 多分组优先级选择流程\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ 1. middleware/distributor.go: Distribute()              │\n│    - 从 token 获取 group_priorities 配置                 │\n│    - 调用 SelectChannelWithPriority()                   │\n└─────────────────────────────────────────────────────────┘\n                         ↓\n┌─────────────────────────────────────────────────────────┐\n│ 2. service/channel_select.go: SelectChannelWithPriority│\n│    - 获取分组优先级列表                                   │\n│    - 按优先级从高到低遍历                                 │\n└─────────────────────────────────────────────────────────┘\n                         ↓\n        ┌────────────────┴────────────────┐\n        ↓                                  ↓\n┌───────────────────────┐      ┌──────────────────────────┐\n│ 3a. 尝试分组1          │      │ 3b. 分组1失败             │\n│ - 查找可用渠道         │  →   │ - 记录失败日志            │\n│ - 模型匹配             │      │ - 尝试下一个分组          │\n└───────────────────────┘      └──────────────────────────┘\n        ↓ 成功                          ↓ 继续\n┌───────────────────────┐      ┌──────────────────────────┐\n│ 4. 返回选中渠道        │      │ 4. 遍历所有分组           │\n│ - 设置 context         │      │ - 分组2, 分组3...         │\n│ - 记录使用日志         │      └──────────────────────────┘\n└───────────────────────┘                  ↓ 全部失败\n                                ┌──────────────────────────┐\n                                │ 5. 自动智能分组判断       │\n                                │ - 检查 auto_smart_group   │\n                                └──────────────────────────┘\n                 ┌──────────────┴──────────────┐\n                 ↓ true                         ↓ false\n    ┌────────────────────────┐      ┌─────────────────────┐\n    │ 6a. 启用智能分组        │      │ 6b. 返回错误         │\n    │ - 按费率排序所有分组    │      │ - 无可用渠道         │\n    │ - 从低到高尝试          │      └─────────────────────┘\n    └────────────────────────┘\n                 ↓\n    ┌────────────────────────┐\n    │ 7. 记录实际使用的分组   │\n    │ - 日志记录              │\n    └────────────────────────┘\n```\n\n### 4.2 核心代码实现\n\n#### service/channel_select.go (新增函数)\n\n```go\npackage service\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    \"github.com/QuantumNous/new-api/common\"\n    \"github.com/QuantumNous/new-api/constant\"\n    \"github.com/QuantumNous/new-api/logger\"\n    \"github.com/QuantumNous/new-api/model\"\n    \"github.com/QuantumNous/new-api/setting\"\n    \"github.com/gin-gonic/gin\"\n)\n\n// SelectChannelWithPriority 按分组优先级选择渠道\nfunc SelectChannelWithPriority(c *gin.Context, token *model.Token, modelName string, retry int) (*model.Channel, string, error) {\n    // 获取分组优先级列表\n    priorities, err := token.GetGroupPriorities()\n    if err != nil {\n        logger.LogError(c, \"Failed to parse group priorities: \"+err.Error())\n        // 降级到单分组模式\n        return CacheGetRandomSatisfiedChannel(c, token.Group, modelName, retry)\n    }\n\n    if len(priorities) == 0 {\n        // 没有配置分组，使用默认逻辑\n        userGroup := common.GetContextKeyString(c, constant.ContextKeyUserGroup)\n        return CacheGetRandomSatisfiedChannel(c, userGroup, modelName, retry)\n    }\n\n    // 按优先级遍历分组\n    for _, p := range priorities {\n        logger.LogDebug(c, fmt.Sprintf(\"Trying group: %s (priority: %d)\", p.Group, p.Priority))\n\n        channel, err := model.GetRandomSatisfiedChannel(p.Group, modelName, retry)\n        if err != nil {\n            logger.LogDebug(c, fmt.Sprintf(\"Group %s failed: %s\", p.Group, err.Error()))\n            continue\n        }\n\n        if channel != nil {\n            logger.LogInfo(c, fmt.Sprintf(\"Selected channel from group: %s\", p.Group))\n            common.SetContextKey(c, constant.ContextKeySelectedGroup, p.Group)\n            return channel, p.Group, nil\n        }\n    }\n\n    // 所有配置的分组都失败\n    logger.LogWarn(c, \"All configured groups failed\")\n\n    // 检查是否启用自动智能分组\n    if token.AutoSmartGroup {\n        logger.LogInfo(c, \"Auto smart group enabled, trying all groups by ratio\")\n        return selectChannelByRatio(c, modelName, retry, priorities)\n    }\n\n    return nil, \"\", errors.New(\"所有配置的分组都无可用渠道\")\n}\n\n// selectChannelByRatio 按费率从低到高选择分组\nfunc selectChannelByRatio(c *gin.Context, modelName string, retry int, excludePriorities []model.GroupPriority) (*model.Channel, string, error) {\n    // 获取所有可用分组\n    allGroups := setting.GetAllGroups()\n    if len(allGroups) == 0 {\n        return nil, \"\", errors.New(\"系统未配置任何分组\")\n    }\n\n    // 排除已尝试的分组\n    excludeMap := make(map[string]bool)\n    for _, p := range excludePriorities {\n        excludeMap[p.Group] = true\n    }\n\n    // 构建候选分组列表\n    type groupWithRatio struct {\n        group string\n        ratio float64\n    }\n    var candidates []groupWithRatio\n\n    for group, info := range allGroups {\n        if excludeMap[group] {\n            continue\n        }\n        candidates = append(candidates, groupWithRatio{\n            group: group,\n            ratio: info.Ratio,\n        })\n    }\n\n    if len(candidates) == 0 {\n        return nil, \"\", errors.New(\"没有可用的备用分组\")\n    }\n\n    // 按费率从低到高排序\n    sort.Slice(candidates, func(i, j int) bool {\n        return candidates[i].ratio < candidates[j].ratio\n    })\n\n    // 依次尝试\n    for _, c := range candidates {\n        logger.LogDebug(c, fmt.Sprintf(\"Auto smart group trying: %s (ratio: %.2f)\", c.group, c.ratio))\n\n        channel, err := model.GetRandomSatisfiedChannel(c.group, modelName, retry)\n        if err != nil {\n            logger.LogDebug(c, fmt.Sprintf(\"Auto smart group %s failed: %s\", c.group, err.Error()))\n            continue\n        }\n\n        if channel != nil {\n            logger.LogInfo(c, fmt.Sprintf(\"Auto smart group selected: %s\", c.group))\n            common.SetContextKey(c, constant.ContextKeySelectedGroup, c.group)\n            common.SetContextKey(c, constant.ContextKeyAutoSmartGroupUsed, true)\n            return channel, c.group, nil\n        }\n    }\n\n    return nil, \"\", errors.New(\"自动智能分组也无法找到可用渠道\")\n}\n```\n\n#### middleware/distributor.go (修改)\n\n```go\n// 修改 Distribute 函数中的渠道选择逻辑\n\nfunc Distribute() func(c *gin.Context) {\n    return func(c *gin.Context) {\n        // ... 现有代码 ...\n\n        if shouldSelectChannel {\n            // ... 模型验证代码 ...\n\n            var selectGroup string\n            var channel *model.Channel\n            var err error\n\n            // 检查是否是令牌请求\n            tokenId := c.GetInt(\"token_id\")\n            if tokenId > 0 {\n                // 获取令牌信息\n                token, err := model.GetTokenById(tokenId)\n                if err == nil && token != nil {\n                    // 使用多分组优先级选择\n                    channel, selectGroup, err = service.SelectChannelWithPriority(c, token, modelRequest.Model, 0)\n                } else {\n                    // 降级到原有逻辑\n                    usingGroup := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)\n                    channel, selectGroup, err = service.CacheGetRandomSatisfiedChannel(c, usingGroup, modelRequest.Model, 0)\n                }\n            } else {\n                // 非令牌请求，使用原有逻辑\n                usingGroup := common.GetContextKeyString(c, constant.ContextKeyUsingGroup)\n                channel, selectGroup, err = service.CacheGetRandomSatisfiedChannel(c, usingGroup, modelRequest.Model, 0)\n            }\n\n            if err != nil {\n                message := fmt.Sprintf(\"获取模型 %s 的可用渠道失败: %s\", modelRequest.Model, err.Error())\n                abortWithOpenAiMessage(c, http.StatusServiceUnavailable, message, string(types.ErrorCodeModelNotFound))\n                return\n            }\n\n            if channel == nil {\n                abortWithOpenAiMessage(c, http.StatusServiceUnavailable, fmt.Sprintf(\"模型 %s 无可用渠道\", modelRequest.Model), string(types.ErrorCodeModelNotFound))\n                return\n            }\n        }\n\n        common.SetContextKey(c, constant.ContextKeyRequestStartTime, time.Now())\n        SetupContextForSelectedChannel(c, channel, modelRequest.Model)\n        c.Next()\n    }\n}\n```\n\n---\n\n## 5. 缓存策略设计\n\n### 5.1 Redis 缓存结构\n\n```\nKey: token:<HMAC(token_key)>\nType: Hash\nFields:\n  - id: token ID\n  - user_id: 用户ID\n  - name: 令牌名称\n  - status: 状态\n  - group: 单分组（向后兼容）\n  - group_priorities: 多分组优先级 JSON\n  - auto_smart_group: 自动智能分组开关\n  - remain_quota: 剩余额度\n  - ... 其他字段\nTTL: 按配置设置（default: 3600秒）\n```\n\n### 5.2 缓存同步逻辑\n\n```go\n// model/token_cache.go\n\nfunc cacheSetToken(token Token) error {\n    key := common.GenerateHMAC(token.Key)\n    token.Clean() // 清理敏感信息\n\n    // 将整个 token 对象序列化为 JSON 存入 Redis\n    err := common.RedisHSetObj(fmt.Sprintf(\"token:%s\", key), &token,\n        time.Duration(common.RedisKeyCacheSeconds())*time.Second)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc cacheGetTokenByKey(key string) (*Token, error) {\n    hmacKey := common.GenerateHMAC(key)\n    if !common.RedisEnabled {\n        return nil, fmt.Errorf(\"redis is not enabled\")\n    }\n    var token Token\n    err := common.RedisHGetObj(fmt.Sprintf(\"token:%s\", hmacKey), &token)\n    if err != nil {\n        return nil, err\n    }\n    token.Key = key\n    return &token, nil\n}\n```\n\n### 5.3 缓存失效策略\n\n- **创建令牌**: 自动写入缓存\n- **更新令牌**: 更新数据库后异步更新缓存\n- **删除令牌**: 删除数据库后异步删除缓存\n- **缓存过期**: 按 TTL 自动过期，查询时重新加载\n\n---\n\n## 6. 前端设计\n\n### 6.1 EditTokenModal 组件改造\n\n#### 6.1.1 多分组选择器组件\n\n```jsx\n// web/src/components/table/tokens/modals/EditTokenModal.jsx\n\nimport React, { useState } from 'react';\nimport { Form, Select, Tag, Space, Button, Tooltip } from '@douyinfe/semi-ui';\nimport { IconArrowUp, IconArrowDown, IconDelete } from '@douyinfe/semi-icons';\n\nconst GroupPrioritiesSelector = ({ value, onChange, groups }) => {\n  const [selectedGroups, setSelectedGroups] = useState(value || []);\n\n  const handleAddGroup = (group) => {\n    if (selectedGroups.find(g => g.group === group)) {\n      return; // 已存在\n    }\n    const newPriority = selectedGroups.length + 1;\n    const newGroups = [...selectedGroups, { group, priority: newPriority }];\n    setSelectedGroups(newGroups);\n    onChange(newGroups);\n  };\n\n  const handleRemoveGroup = (group) => {\n    const newGroups = selectedGroups\n      .filter(g => g.group !== group)\n      .map((g, index) => ({ ...g, priority: index + 1 })); // 重新排序\n    setSelectedGroups(newGroups);\n    onChange(newGroups);\n  };\n\n  const handleMoveUp = (index) => {\n    if (index === 0) return;\n    const newGroups = [...selectedGroups];\n    [newGroups[index - 1], newGroups[index]] = [newGroups[index], newGroups[index - 1]];\n    // 更新优先级\n    newGroups.forEach((g, i) => g.priority = i + 1);\n    setSelectedGroups(newGroups);\n    onChange(newGroups);\n  };\n\n  const handleMoveDown = (index) => {\n    if (index === selectedGroups.length - 1) return;\n    const newGroups = [...selectedGroups];\n    [newGroups[index], newGroups[index + 1]] = [newGroups[index + 1], newGroups[index]];\n    // 更新优先级\n    newGroups.forEach((g, i) => g.priority = i + 1);\n    setSelectedGroups(newGroups);\n    onChange(newGroups);\n  };\n\n  return (\n    <div>\n      <Select\n        placeholder=\"选择分组\"\n        optionList={groups.filter(g => !selectedGroups.find(sg => sg.group === g.value))}\n        onChange={handleAddGroup}\n        showClear\n        style={{ width: '100%', marginBottom: 12 }}\n      />\n\n      <div>\n        {selectedGroups.map((item, index) => (\n          <div key={item.group} className=\"flex items-center gap-2 mb-2 p-2 border rounded\">\n            <Tag color=\"blue\" size=\"large\">\n              ☆{item.priority}\n            </Tag>\n            <span className=\"flex-1 font-medium\">{item.group}</span>\n            <Space>\n              <Button\n                icon={<IconArrowUp />}\n                size=\"small\"\n                disabled={index === 0}\n                onClick={() => handleMoveUp(index)}\n              />\n              <Button\n                icon={<IconArrowDown />}\n                size=\"small\"\n                disabled={index === selectedGroups.length - 1}\n                onClick={() => handleMoveDown(index)}\n              />\n              <Button\n                icon={<IconDelete />}\n                size=\"small\"\n                type=\"danger\"\n                onClick={() => handleRemoveGroup(item.group)}\n              />\n            </Space>\n          </div>\n        ))}\n      </div>\n\n      {selectedGroups.length > 0 && (\n        <div className=\"mt-2 text-sm text-gray-600\">\n          当前优先级顺序: {selectedGroups.map(g => g.group).join(' > ')}\n        </div>\n      )}\n    </div>\n  );\n};\n```\n\n#### 6.1.2 表单字段集成\n\n```jsx\n// EditTokenModal.jsx 表单部分\n\n<Form.Slot\n  label={\n    <Space>\n      <span>令牌分组优先级</span>\n      <Tooltip content=\"配置多个分组,系统将按优先级顺序依次尝试。数字越小优先级越高。\">\n        <IconHelpCircle />\n      </Tooltip>\n    </Space>\n  }\n>\n  <GroupPrioritiesSelector\n    value={formApi.getValue('group_priorities')}\n    onChange={(value) => formApi.setValue('group_priorities', value)}\n    groups={groups}\n  />\n  <div className=\"text-xs text-gray-500 mt-1\">\n    请求转发时,系统会按优先级从高到低依次尝试各分组,直到成功或全部失败。\n  </div>\n</Form.Slot>\n\n<Form.Switch\n  field=\"auto_smart_group\"\n  label={\n    <Space>\n      <span>自动智能分组</span>\n      <Tooltip content=\"当所有配置的分组都失败时,自动从其他可用分组中按费率从低到高选择。\">\n        <IconHelpCircle />\n      </Tooltip>\n    </Space>\n  }\n  extraText=\"启用后,配置的分组全部失败时,系统会自动尝试其他可用分组,按费率从低到高选择,提高请求成功率。\"\n  size=\"large\"\n/>\n```\n\n### 6.2 TokensTable 列展示\n\n```jsx\n// web/src/components/table/tokens/TokensColumnDefs.jsx\n\n{\n  title: '分组',\n  dataIndex: 'group_priorities',\n  key: 'group_priorities',\n  render: (text, record) => {\n    // 解析分组优先级\n    const formatGroupDisplay = (token) => {\n      if (!token.group_priorities) {\n        // 向后兼容：显示单分组\n        return token.group || '-';\n      }\n      try {\n        const priorities = JSON.parse(token.group_priorities);\n        const sorted = priorities.sort((a, b) => a.priority - b.priority);\n        return sorted.map(p => p.group).join(' > ');\n      } catch (e) {\n        return token.group || '-';\n      }\n    };\n\n    const display = formatGroupDisplay(record);\n\n    return (\n      <div>\n        <div className=\"font-medium\">{display}</div>\n        {record.auto_smart_group && (\n          <Tag size=\"small\" color=\"green\" className=\"mt-1\">\n            智能分组\n          </Tag>\n        )}\n      </div>\n    );\n  },\n}\n```\n\n---\n\n## 7. 数据迁移方案\n\n### 7.1 数据库迁移 SQL\n\n```sql\n-- PostgreSQL\nALTER TABLE tokens ADD COLUMN IF NOT EXISTS group_priorities VARCHAR(2048) DEFAULT '';\nALTER TABLE tokens ADD COLUMN IF NOT EXISTS auto_smart_group BOOLEAN DEFAULT false;\n\n-- MySQL\nALTER TABLE tokens ADD COLUMN group_priorities VARCHAR(2048) DEFAULT '' COMMENT 'JSON格式的多分组优先级配置';\nALTER TABLE tokens ADD COLUMN auto_smart_group TINYINT(1) DEFAULT 0 COMMENT '是否启用自动智能分组';\n\n-- SQLite\nALTER TABLE tokens ADD COLUMN group_priorities TEXT DEFAULT '';\nALTER TABLE tokens ADD COLUMN auto_smart_group INTEGER DEFAULT 0;\n```\n\n### 7.2 数据迁移脚本\n\n不需要迁移现有数据，因为：\n1. 保留了 `group` 字段，现有令牌继续使用单分组模式\n2. 新字段 `group_priorities` 默认为空，向后兼容逻辑会使用 `group` 字段\n3. `auto_smart_group` 默认为 `false`，不改变现有行为\n\n### 7.3 回滚方案\n\n如果需要回滚：\n```sql\n-- 删除新增字段\nALTER TABLE tokens DROP COLUMN group_priorities;\nALTER TABLE tokens DROP COLUMN auto_smart_group;\n```\n\n---\n\n## 8. 错误处理与日志\n\n### 8.1 错误类型定义\n\n```go\n// types/error.go\n\nconst (\n    ErrorCodeGroupConfigInvalid = \"GROUP_CONFIG_INVALID\"\n    ErrorCodeNoAvailableGroup   = \"NO_AVAILABLE_GROUP\"\n    ErrorCodeAllGroupsFailed    = \"ALL_GROUPS_FAILED\"\n)\n```\n\n### 8.2 日志记录点\n\n```go\n// 关键日志记录点\n\n// 1. 分组选择开始\nlogger.LogInfo(c, fmt.Sprintf(\"Token %d group priorities: %v\", tokenId, priorities))\n\n// 2. 每个分组尝试\nlogger.LogDebug(c, fmt.Sprintf(\"Trying group: %s (priority: %d)\", group, priority))\n\n// 3. 分组失败\nlogger.LogWarn(c, fmt.Sprintf(\"Group %s failed: %s\", group, err.Error()))\n\n// 4. 分组成功\nlogger.LogInfo(c, fmt.Sprintf(\"Selected channel from group: %s, channel_id: %d\", group, channelId))\n\n// 5. 自动智能分组触发\nlogger.LogInfo(c, \"Auto smart group enabled, trying fallback groups by ratio\")\n\n// 6. 最终失败\nlogger.LogError(c, fmt.Sprintf(\"All groups failed for token %d, model %s\", tokenId, model))\n```\n\n---\n\n## 9. 测试策略\n\n### 9.1 单元测试\n\n#### model/token_test.go\n```go\nfunc TestToken_GetGroupPriorities(t *testing.T) {\n    tests := []struct {\n        name          string\n        token         Token\n        want          []GroupPriority\n        wantErr       bool\n    }{\n        {\n            name: \"正常多分组\",\n            token: Token{\n                GroupPriorities: `[{\"group\":\"g1\",\"priority\":1},{\"group\":\"g2\",\"priority\":2}]`,\n            },\n            want: []GroupPriority{\n                {Group: \"g1\", Priority: 1},\n                {Group: \"g2\", Priority: 2},\n            },\n            wantErr: false,\n        },\n        {\n            name: \"向后兼容单分组\",\n            token: Token{\n                Group: \"default\",\n                GroupPriorities: \"\",\n            },\n            want: []GroupPriority{\n                {Group: \"default\", Priority: 1},\n            },\n            wantErr: false,\n        },\n        {\n            name: \"无效JSON\",\n            token: Token{\n                GroupPriorities: \"invalid json\",\n            },\n            want: nil,\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := tt.token.GetGroupPriorities()\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"GetGroupPriorities() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"GetGroupPriorities() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\n### 9.2 集成测试\n\n#### service/channel_select_test.go\n```go\nfunc TestSelectChannelWithPriority(t *testing.T) {\n    // Mock setup\n    // ...\n\n    tests := []struct {\n        name          string\n        token         *Token\n        modelName     string\n        wantGroup     string\n        wantErr       bool\n    }{\n        {\n            name: \"优先级1成功\",\n            token: &Token{\n                GroupPriorities: `[{\"group\":\"high\",\"priority\":1},{\"group\":\"low\",\"priority\":2}]`,\n            },\n            modelName: \"gpt-4\",\n            wantGroup: \"high\",\n            wantErr: false,\n        },\n        {\n            name: \"优先级1失败,降级到2\",\n            token: &Token{\n                GroupPriorities: `[{\"group\":\"unavailable\",\"priority\":1},{\"group\":\"available\",\"priority\":2}]`,\n            },\n            modelName: \"gpt-4\",\n            wantGroup: \"available\",\n            wantErr: false,\n        },\n        {\n            name: \"所有分组失败,自动智能分组\",\n            token: &Token{\n                GroupPriorities: `[{\"group\":\"g1\",\"priority\":1}]`,\n                AutoSmartGroup: true,\n            },\n            modelName: \"gpt-4\",\n            wantGroup: \"fallback-group\", // 按费率最低的分组\n            wantErr: false,\n        },\n    }\n\n    // 测试实现...\n}\n```\n\n### 9.3 E2E 测试场景\n\n1. **场景1**: 创建多分组令牌\n   - 前端选择3个分组并拖动排序\n   - 提交保存\n   - 验证数据库存储正确\n   - 验证 Redis 缓存同步\n\n2. **场景2**: 多分组优先级转发\n   - 使用令牌发起请求\n   - 验证按优先级顺序尝试分组\n   - 验证日志记录完整\n\n3. **场景3**: 自动智能分组降级\n   - 配置的分组全部不可用\n   - 启用自动智能分组\n   - 验证按费率选择备用分组\n   - 验证成功响应\n\n4. **场景4**: 向后兼容性\n   - 使用旧的单分组令牌\n   - 验证正常工作\n   - 编辑后升级为多分组\n   - 验证功能正常\n\n---\n\n## 10. 性能优化\n\n### 10.1 优化点\n\n1. **缓存优先**: 令牌验证优先从 Redis 读取，减少数据库查询\n2. **异步更新**: 缓存更新采用异步方式，不阻塞主流程\n3. **批量查询**: 渠道查询使用现有的批量查询逻辑\n4. **早返回**: 分组匹配成功后立即返回，避免不必要的遍历\n\n### 10.2 性能指标\n\n| 指标 | 目标 | 测量方法 |\n|------|------|----------|\n| 分组选择延迟 | < 50ms | 中间件耗时统计 |\n| Redis 缓存命中率 | ≥ 95% | Redis 监控指标 |\n| 数据库查询次数 | 缓存命中: 0次<br/>未命中: ≤1次 | SQL 日志统计 |\n| QPS 支持 | ≥ 1000 | 压力测试 |\n\n---\n\n## 11. 安全性考虑\n\n### 11.1 输入验证\n\n```go\n// 分组配置验证\nfunc validateGroupPriorities(priorities []GroupPriority) error {\n    if len(priorities) > 10 {\n        return errors.New(\"最多支持10个分组\")\n    }\n\n    groupMap := make(map[string]bool)\n    for _, p := range priorities {\n        if p.Group == \"\" {\n            return errors.New(\"分组名称不能为空\")\n        }\n        if p.Priority < 1 {\n            return errors.New(\"优先级必须大于0\")\n        }\n        if groupMap[p.Group] {\n            return errors.New(\"分组不能重复\")\n        }\n        groupMap[p.Group] = true\n    }\n\n    return nil\n}\n```\n\n### 11.2 权限控制\n\n```go\n// 验证用户是否有权访问配置的分组\nfunc validateUserGroupAccess(userId int, groupPriorities []GroupPriority) error {\n    user, err := model.GetUserById(userId, false)\n    if err != nil {\n        return err\n    }\n\n    userGroups := GetUserUsableGroups(user.Group)\n\n    for _, p := range groupPriorities {\n        if !contains(userGroups, p.Group) {\n            return errors.New(fmt.Sprintf(\"无权访问分组: %s\", p.Group))\n        }\n    }\n\n    return nil\n}\n```\n\n### 11.3 注入防护\n\n- JSON 序列化使用标准库 `encoding/json`\n- 数据库操作使用 GORM 参数化查询\n- 前端使用 React 自动转义\n\n---\n\n## 12. 监控与告警\n\n### 12.1 监控指标\n\n```go\n// metrics/token.go\n\nvar (\n    // 多分组选择计数器\n    multiGroupSelectCounter = prometheus.NewCounterVec(\n        prometheus.CounterOpts{\n            Name: \"token_multi_group_select_total\",\n            Help: \"Total number of multi-group selections\",\n        },\n        []string{\"group\", \"priority\", \"status\"},\n    )\n\n    // 自动智能分组计数器\n    autoSmartGroupCounter = prometheus.NewCounter(\n        prometheus.CounterOpts{\n            Name: \"token_auto_smart_group_total\",\n            Help: \"Total number of auto smart group fallbacks\",\n        },\n    )\n\n    // 分组选择耗时\n    groupSelectDuration = prometheus.NewHistogramVec(\n        prometheus.HistogramOpts{\n            Name: \"token_group_select_duration_seconds\",\n            Help: \"Duration of group selection\",\n            Buckets: prometheus.DefBuckets,\n        },\n        []string{\"status\"},\n    )\n)\n```\n\n### 12.2 告警规则\n\n```yaml\ngroups:\n  - name: token_multi_group\n    rules:\n      - alert: HighGroupFailureRate\n        expr: rate(token_multi_group_select_total{status=\"failed\"}[5m]) > 0.1\n        for: 5m\n        annotations:\n          summary: \"分组失败率过高\"\n          description: \"分组选择失败率超过10%\"\n\n      - alert: FrequentAutoSmartGroup\n        expr: rate(token_auto_smart_group_total[5m]) > 10\n        for: 5m\n        annotations:\n          summary: \"自动智能分组频繁触发\"\n          description: \"可能配置的分组不可用\"\n```\n\n---\n\n## 13. 部署方案\n\n### 13.1 灰度发布流程\n\n1. **Phase 1 (5% 流量)**:\n   - 数据库迁移（新增字段）\n   - 部署后端代码\n   - 监控错误日志和性能指标\n\n2. **Phase 2 (20% 流量)**:\n   - 部署前端代码\n   - 允许部分用户使用新功能\n   - 收集用户反馈\n\n3. **Phase 3 (50% 流量)**:\n   - 扩大测试范围\n   - 性能调优\n\n4. **Phase 4 (100% 流量)**:\n   - 全量发布\n   - 持续监控\n\n### 13.2 回滚方案\n\n- 保留 `group` 字段，可以快速回滚到单分组模式\n- 新功能通过特性开关控制，可以动态关闭\n- 数据库字段可以保留，不影响旧版本运行\n\n---\n\n## 14. 文档修订历史\n\n| 版本 | 日期 | 作者 | 修改内容 |\n|------|------|------|----------|\n| 1.0 | 2025-11-30 | Claude Code | 初始版本 |\n",
  "fileStats": {
    "size": 43855,
    "lines": 1310,
    "lastModified": "2025-11-30T13:15:23.678Z"
  },
  "comments": []
}